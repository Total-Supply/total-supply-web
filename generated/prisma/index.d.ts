
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model ContactMessage
 * 
 */
export type ContactMessage = $Result.DefaultSelection<Prisma.$ContactMessagePayload>
/**
 * Model FoodCategory
 * 
 */
export type FoodCategory = $Result.DefaultSelection<Prisma.$FoodCategoryPayload>
/**
 * Model FoodItem
 * 
 */
export type FoodItem = $Result.DefaultSelection<Prisma.$FoodItemPayload>
/**
 * Model FoodImage
 * 
 */
export type FoodImage = $Result.DefaultSelection<Prisma.$FoodImagePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderStatusHistory
 * 
 */
export type OrderStatusHistory = $Result.DefaultSelection<Prisma.$OrderStatusHistoryPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model DeliveryProof
 * 
 */
export type DeliveryProof = $Result.DefaultSelection<Prisma.$DeliveryProofPayload>
/**
 * Model ServiceRequest
 * 
 */
export type ServiceRequest = $Result.DefaultSelection<Prisma.$ServiceRequestPayload>
/**
 * Model ServiceAssignment
 * 
 */
export type ServiceAssignment = $Result.DefaultSelection<Prisma.$ServiceAssignmentPayload>
/**
 * Model ServicePhoto
 * 
 */
export type ServicePhoto = $Result.DefaultSelection<Prisma.$ServicePhotoPayload>
/**
 * Model ServiceRating
 * 
 */
export type ServiceRating = $Result.DefaultSelection<Prisma.$ServiceRatingPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  CUSTOMER: 'CUSTOMER',
  ADMIN: 'ADMIN',
  SALESMAN: 'SALESMAN',
  DRIVER: 'DRIVER',
  CLEANER: 'CLEANER',
  IT_STAFF: 'IT_STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  REJECTED: 'REJECTED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  PREPARING: 'PREPARING',
  OUT_FOR_DELIVERY: 'OUT_FOR_DELIVERY',
  DELIVERED: 'DELIVERED',
  CANCELED: 'CANCELED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const ServiceType: {
  CLEANING: 'CLEANING',
  IT_SUPPORT: 'IT_SUPPORT'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const ServiceStatus: {
  RECEIVED: 'RECEIVED',
  ASSIGNED: 'ASSIGNED',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CANCELED: 'CANCELED'
};

export type ServiceStatus = (typeof ServiceStatus)[keyof typeof ServiceStatus]


export const ServicePriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type ServicePriority = (typeof ServicePriority)[keyof typeof ServicePriority]


export const AuditEntityType: {
  USER: 'USER',
  ORDER: 'ORDER',
  SERVICE_REQUEST: 'SERVICE_REQUEST',
  CONTACT_MESSAGE: 'CONTACT_MESSAGE',
  FOOD_ITEM: 'FOOD_ITEM',
  FOOD_CATEGORY: 'FOOD_CATEGORY'
};

export type AuditEntityType = (typeof AuditEntityType)[keyof typeof AuditEntityType]


export const AuditAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  STATUS_CHANGE: 'STATUS_CHANGE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT'
};

export type AuditAction = (typeof AuditAction)[keyof typeof AuditAction]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type ServiceStatus = $Enums.ServiceStatus

export const ServiceStatus: typeof $Enums.ServiceStatus

export type ServicePriority = $Enums.ServicePriority

export const ServicePriority: typeof $Enums.ServicePriority

export type AuditEntityType = $Enums.AuditEntityType

export const AuditEntityType: typeof $Enums.AuditEntityType

export type AuditAction = $Enums.AuditAction

export const AuditAction: typeof $Enums.AuditAction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs>;

  /**
   * `prisma.contactMessage`: Exposes CRUD operations for the **ContactMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactMessages
    * const contactMessages = await prisma.contactMessage.findMany()
    * ```
    */
  get contactMessage(): Prisma.ContactMessageDelegate<ExtArgs>;

  /**
   * `prisma.foodCategory`: Exposes CRUD operations for the **FoodCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodCategories
    * const foodCategories = await prisma.foodCategory.findMany()
    * ```
    */
  get foodCategory(): Prisma.FoodCategoryDelegate<ExtArgs>;

  /**
   * `prisma.foodItem`: Exposes CRUD operations for the **FoodItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodItems
    * const foodItems = await prisma.foodItem.findMany()
    * ```
    */
  get foodItem(): Prisma.FoodItemDelegate<ExtArgs>;

  /**
   * `prisma.foodImage`: Exposes CRUD operations for the **FoodImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FoodImages
    * const foodImages = await prisma.foodImage.findMany()
    * ```
    */
  get foodImage(): Prisma.FoodImageDelegate<ExtArgs>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.orderStatusHistory`: Exposes CRUD operations for the **OrderStatusHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderStatusHistories
    * const orderStatusHistories = await prisma.orderStatusHistory.findMany()
    * ```
    */
  get orderStatusHistory(): Prisma.OrderStatusHistoryDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.deliveryProof`: Exposes CRUD operations for the **DeliveryProof** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryProofs
    * const deliveryProofs = await prisma.deliveryProof.findMany()
    * ```
    */
  get deliveryProof(): Prisma.DeliveryProofDelegate<ExtArgs>;

  /**
   * `prisma.serviceRequest`: Exposes CRUD operations for the **ServiceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRequests
    * const serviceRequests = await prisma.serviceRequest.findMany()
    * ```
    */
  get serviceRequest(): Prisma.ServiceRequestDelegate<ExtArgs>;

  /**
   * `prisma.serviceAssignment`: Exposes CRUD operations for the **ServiceAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceAssignments
    * const serviceAssignments = await prisma.serviceAssignment.findMany()
    * ```
    */
  get serviceAssignment(): Prisma.ServiceAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.servicePhoto`: Exposes CRUD operations for the **ServicePhoto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePhotos
    * const servicePhotos = await prisma.servicePhoto.findMany()
    * ```
    */
  get servicePhoto(): Prisma.ServicePhotoDelegate<ExtArgs>;

  /**
   * `prisma.serviceRating`: Exposes CRUD operations for the **ServiceRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRatings
    * const serviceRatings = await prisma.serviceRating.findMany()
    * ```
    */
  get serviceRating(): Prisma.ServiceRatingDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Address: 'Address',
    ContactMessage: 'ContactMessage',
    FoodCategory: 'FoodCategory',
    FoodItem: 'FoodItem',
    FoodImage: 'FoodImage',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderStatusHistory: 'OrderStatusHistory',
    Payment: 'Payment',
    DeliveryProof: 'DeliveryProof',
    ServiceRequest: 'ServiceRequest',
    ServiceAssignment: 'ServiceAssignment',
    ServicePhoto: 'ServicePhoto',
    ServiceRating: 'ServiceRating',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "address" | "contactMessage" | "foodCategory" | "foodItem" | "foodImage" | "order" | "orderItem" | "orderStatusHistory" | "payment" | "deliveryProof" | "serviceRequest" | "serviceAssignment" | "servicePhoto" | "serviceRating" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      ContactMessage: {
        payload: Prisma.$ContactMessagePayload<ExtArgs>
        fields: Prisma.ContactMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findFirst: {
            args: Prisma.ContactMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          findMany: {
            args: Prisma.ContactMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          create: {
            args: Prisma.ContactMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          createMany: {
            args: Prisma.ContactMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>[]
          }
          delete: {
            args: Prisma.ContactMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          update: {
            args: Prisma.ContactMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          deleteMany: {
            args: Prisma.ContactMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ContactMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactMessagePayload>
          }
          aggregate: {
            args: Prisma.ContactMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactMessage>
          }
          groupBy: {
            args: Prisma.ContactMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ContactMessageCountAggregateOutputType> | number
          }
        }
      }
      FoodCategory: {
        payload: Prisma.$FoodCategoryPayload<ExtArgs>
        fields: Prisma.FoodCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          findFirst: {
            args: Prisma.FoodCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          findMany: {
            args: Prisma.FoodCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>[]
          }
          create: {
            args: Prisma.FoodCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          createMany: {
            args: Prisma.FoodCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>[]
          }
          delete: {
            args: Prisma.FoodCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          update: {
            args: Prisma.FoodCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          deleteMany: {
            args: Prisma.FoodCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodCategoryPayload>
          }
          aggregate: {
            args: Prisma.FoodCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodCategory>
          }
          groupBy: {
            args: Prisma.FoodCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<FoodCategoryCountAggregateOutputType> | number
          }
        }
      }
      FoodItem: {
        payload: Prisma.$FoodItemPayload<ExtArgs>
        fields: Prisma.FoodItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          findFirst: {
            args: Prisma.FoodItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          findMany: {
            args: Prisma.FoodItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>[]
          }
          create: {
            args: Prisma.FoodItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          createMany: {
            args: Prisma.FoodItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>[]
          }
          delete: {
            args: Prisma.FoodItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          update: {
            args: Prisma.FoodItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          deleteMany: {
            args: Prisma.FoodItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodItemPayload>
          }
          aggregate: {
            args: Prisma.FoodItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodItem>
          }
          groupBy: {
            args: Prisma.FoodItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodItemCountArgs<ExtArgs>
            result: $Utils.Optional<FoodItemCountAggregateOutputType> | number
          }
        }
      }
      FoodImage: {
        payload: Prisma.$FoodImagePayload<ExtArgs>
        fields: Prisma.FoodImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FoodImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FoodImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          findFirst: {
            args: Prisma.FoodImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FoodImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          findMany: {
            args: Prisma.FoodImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>[]
          }
          create: {
            args: Prisma.FoodImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          createMany: {
            args: Prisma.FoodImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FoodImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>[]
          }
          delete: {
            args: Prisma.FoodImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          update: {
            args: Prisma.FoodImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          deleteMany: {
            args: Prisma.FoodImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FoodImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FoodImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FoodImagePayload>
          }
          aggregate: {
            args: Prisma.FoodImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFoodImage>
          }
          groupBy: {
            args: Prisma.FoodImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<FoodImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.FoodImageCountArgs<ExtArgs>
            result: $Utils.Optional<FoodImageCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderStatusHistory: {
        payload: Prisma.$OrderStatusHistoryPayload<ExtArgs>
        fields: Prisma.OrderStatusHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderStatusHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderStatusHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          findFirst: {
            args: Prisma.OrderStatusHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderStatusHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          findMany: {
            args: Prisma.OrderStatusHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>[]
          }
          create: {
            args: Prisma.OrderStatusHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          createMany: {
            args: Prisma.OrderStatusHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderStatusHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>[]
          }
          delete: {
            args: Prisma.OrderStatusHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          update: {
            args: Prisma.OrderStatusHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          deleteMany: {
            args: Prisma.OrderStatusHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderStatusHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderStatusHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderStatusHistoryPayload>
          }
          aggregate: {
            args: Prisma.OrderStatusHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderStatusHistory>
          }
          groupBy: {
            args: Prisma.OrderStatusHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderStatusHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<OrderStatusHistoryCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      DeliveryProof: {
        payload: Prisma.$DeliveryProofPayload<ExtArgs>
        fields: Prisma.DeliveryProofFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryProofFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryProofFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          findFirst: {
            args: Prisma.DeliveryProofFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryProofFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          findMany: {
            args: Prisma.DeliveryProofFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>[]
          }
          create: {
            args: Prisma.DeliveryProofCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          createMany: {
            args: Prisma.DeliveryProofCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryProofCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>[]
          }
          delete: {
            args: Prisma.DeliveryProofDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          update: {
            args: Prisma.DeliveryProofUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          deleteMany: {
            args: Prisma.DeliveryProofDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryProofUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeliveryProofUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryProofPayload>
          }
          aggregate: {
            args: Prisma.DeliveryProofAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryProof>
          }
          groupBy: {
            args: Prisma.DeliveryProofGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryProofGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryProofCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryProofCountAggregateOutputType> | number
          }
        }
      }
      ServiceRequest: {
        payload: Prisma.$ServiceRequestPayload<ExtArgs>
        fields: Prisma.ServiceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findFirst: {
            args: Prisma.ServiceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          findMany: {
            args: Prisma.ServiceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          create: {
            args: Prisma.ServiceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          createMany: {
            args: Prisma.ServiceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>[]
          }
          delete: {
            args: Prisma.ServiceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          update: {
            args: Prisma.ServiceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRequestPayload>
          }
          aggregate: {
            args: Prisma.ServiceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRequest>
          }
          groupBy: {
            args: Prisma.ServiceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRequestCountAggregateOutputType> | number
          }
        }
      }
      ServiceAssignment: {
        payload: Prisma.$ServiceAssignmentPayload<ExtArgs>
        fields: Prisma.ServiceAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ServiceAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          findMany: {
            args: Prisma.ServiceAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
          }
          create: {
            args: Prisma.ServiceAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          createMany: {
            args: Prisma.ServiceAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ServiceAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          update: {
            args: Prisma.ServiceAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ServiceAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ServiceAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceAssignment>
          }
          groupBy: {
            args: Prisma.ServiceAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceAssignmentCountAggregateOutputType> | number
          }
        }
      }
      ServicePhoto: {
        payload: Prisma.$ServicePhotoPayload<ExtArgs>
        fields: Prisma.ServicePhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePhotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePhotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          findFirst: {
            args: Prisma.ServicePhotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePhotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          findMany: {
            args: Prisma.ServicePhotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>[]
          }
          create: {
            args: Prisma.ServicePhotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          createMany: {
            args: Prisma.ServicePhotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePhotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>[]
          }
          delete: {
            args: Prisma.ServicePhotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          update: {
            args: Prisma.ServicePhotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          deleteMany: {
            args: Prisma.ServicePhotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePhotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePhotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePhotoPayload>
          }
          aggregate: {
            args: Prisma.ServicePhotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePhoto>
          }
          groupBy: {
            args: Prisma.ServicePhotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePhotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePhotoCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePhotoCountAggregateOutputType> | number
          }
        }
      }
      ServiceRating: {
        payload: Prisma.$ServiceRatingPayload<ExtArgs>
        fields: Prisma.ServiceRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          findFirst: {
            args: Prisma.ServiceRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          findMany: {
            args: Prisma.ServiceRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>[]
          }
          create: {
            args: Prisma.ServiceRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          createMany: {
            args: Prisma.ServiceRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceRatingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>[]
          }
          delete: {
            args: Prisma.ServiceRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          update: {
            args: Prisma.ServiceRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          aggregate: {
            args: Prisma.ServiceRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRating>
          }
          groupBy: {
            args: Prisma.ServiceRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    addresses: number
    orders: number
    serviceRequests: number
    salesmanOrders: number
    driverOrders: number
    staffServices: number
    contactMessages: number
    handledMessages: number
    ratings: number
    ratedServices: number
    sessions: number
    auditLogs: number
    orderStatusChanges: number
    deliveryProofs: number
    serviceAssignments: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    serviceRequests?: boolean | UserCountOutputTypeCountServiceRequestsArgs
    salesmanOrders?: boolean | UserCountOutputTypeCountSalesmanOrdersArgs
    driverOrders?: boolean | UserCountOutputTypeCountDriverOrdersArgs
    staffServices?: boolean | UserCountOutputTypeCountStaffServicesArgs
    contactMessages?: boolean | UserCountOutputTypeCountContactMessagesArgs
    handledMessages?: boolean | UserCountOutputTypeCountHandledMessagesArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    ratedServices?: boolean | UserCountOutputTypeCountRatedServicesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    orderStatusChanges?: boolean | UserCountOutputTypeCountOrderStatusChangesArgs
    deliveryProofs?: boolean | UserCountOutputTypeCountDeliveryProofsArgs
    serviceAssignments?: boolean | UserCountOutputTypeCountServiceAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesmanOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDriverOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStaffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountContactMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHandledMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrderStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeliveryProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryProofWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServiceAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
  }


  /**
   * Count Type AddressCountOutputType
   */

  export type AddressCountOutputType = {
    orders: number
    serviceRequests: number
  }

  export type AddressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | AddressCountOutputTypeCountOrdersArgs
    serviceRequests?: boolean | AddressCountOutputTypeCountServiceRequestsArgs
  }

  // Custom InputTypes
  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AddressCountOutputType
     */
    select?: AddressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * AddressCountOutputType without action
   */
  export type AddressCountOutputTypeCountServiceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
  }


  /**
   * Count Type FoodCategoryCountOutputType
   */

  export type FoodCategoryCountOutputType = {
    items: number
  }

  export type FoodCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FoodCategoryCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * FoodCategoryCountOutputType without action
   */
  export type FoodCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategoryCountOutputType
     */
    select?: FoodCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodCategoryCountOutputType without action
   */
  export type FoodCategoryCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodItemWhereInput
  }


  /**
   * Count Type FoodItemCountOutputType
   */

  export type FoodItemCountOutputType = {
    images: number
    orderItems: number
  }

  export type FoodItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | FoodItemCountOutputTypeCountImagesArgs
    orderItems?: boolean | FoodItemCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * FoodItemCountOutputType without action
   */
  export type FoodItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItemCountOutputType
     */
    select?: FoodItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FoodItemCountOutputType without action
   */
  export type FoodItemCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodImageWhereInput
  }

  /**
   * FoodItemCountOutputType without action
   */
  export type FoodItemCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    statusHistory: number
    items: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    statusHistory?: boolean | OrderCountOutputTypeCountStatusHistoryArgs
    items?: boolean | OrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusHistoryWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type ServiceRequestCountOutputType
   */

  export type ServiceRequestCountOutputType = {
    photos: number
    assignments: number
    ratings: number
  }

  export type ServiceRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    photos?: boolean | ServiceRequestCountOutputTypeCountPhotosArgs
    assignments?: boolean | ServiceRequestCountOutputTypeCountAssignmentsArgs
    ratings?: boolean | ServiceRequestCountOutputTypeCountRatingsArgs
  }

  // Custom InputTypes
  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequestCountOutputType
     */
    select?: ServiceRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePhotoWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
  }

  /**
   * ServiceRequestCountOutputType without action
   */
  export type ServiceRequestCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    emailVerified: Date | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    passwordHash: string | null
    name: string | null
    phone: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    emailVerified: Date | null
    profileImage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    phone: number
    role: number
    status: number
    emailVerified: number
    profileImage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    emailVerified?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    emailVerified?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    phone?: true
    role?: true
    status?: true
    emailVerified?: true
    profileImage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    passwordHash: string
    name: string
    phone: string | null
    role: $Enums.UserRole
    status: $Enums.UserStatus
    emailVerified: Date | null
    profileImage: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    addresses?: boolean | User$addressesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    serviceRequests?: boolean | User$serviceRequestsArgs<ExtArgs>
    salesmanOrders?: boolean | User$salesmanOrdersArgs<ExtArgs>
    driverOrders?: boolean | User$driverOrdersArgs<ExtArgs>
    staffServices?: boolean | User$staffServicesArgs<ExtArgs>
    contactMessages?: boolean | User$contactMessagesArgs<ExtArgs>
    handledMessages?: boolean | User$handledMessagesArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    ratedServices?: boolean | User$ratedServicesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    orderStatusChanges?: boolean | User$orderStatusChangesArgs<ExtArgs>
    deliveryProofs?: boolean | User$deliveryProofsArgs<ExtArgs>
    serviceAssignments?: boolean | User$serviceAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    phone?: boolean
    role?: boolean
    status?: boolean
    emailVerified?: boolean
    profileImage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | User$addressesArgs<ExtArgs>
    orders?: boolean | User$ordersArgs<ExtArgs>
    serviceRequests?: boolean | User$serviceRequestsArgs<ExtArgs>
    salesmanOrders?: boolean | User$salesmanOrdersArgs<ExtArgs>
    driverOrders?: boolean | User$driverOrdersArgs<ExtArgs>
    staffServices?: boolean | User$staffServicesArgs<ExtArgs>
    contactMessages?: boolean | User$contactMessagesArgs<ExtArgs>
    handledMessages?: boolean | User$handledMessagesArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    ratedServices?: boolean | User$ratedServicesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    orderStatusChanges?: boolean | User$orderStatusChangesArgs<ExtArgs>
    deliveryProofs?: boolean | User$deliveryProofsArgs<ExtArgs>
    serviceAssignments?: boolean | User$serviceAssignmentsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      orders: Prisma.$OrderPayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
      salesmanOrders: Prisma.$OrderPayload<ExtArgs>[]
      driverOrders: Prisma.$OrderPayload<ExtArgs>[]
      staffServices: Prisma.$ServiceAssignmentPayload<ExtArgs>[]
      contactMessages: Prisma.$ContactMessagePayload<ExtArgs>[]
      handledMessages: Prisma.$ContactMessagePayload<ExtArgs>[]
      ratings: Prisma.$ServiceRatingPayload<ExtArgs>[]
      ratedServices: Prisma.$ServiceRatingPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      orderStatusChanges: Prisma.$OrderStatusHistoryPayload<ExtArgs>[]
      deliveryProofs: Prisma.$DeliveryProofPayload<ExtArgs>[]
      serviceAssignments: Prisma.$ServiceAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      passwordHash: string
      name: string
      phone: string | null
      role: $Enums.UserRole
      status: $Enums.UserStatus
      emailVerified: Date | null
      profileImage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    serviceRequests<T extends User$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany"> | Null>
    salesmanOrders<T extends User$salesmanOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$salesmanOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    driverOrders<T extends User$driverOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$driverOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    staffServices<T extends User$staffServicesArgs<ExtArgs> = {}>(args?: Subset<T, User$staffServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    contactMessages<T extends User$contactMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$contactMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany"> | Null>
    handledMessages<T extends User$handledMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$handledMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany"> | Null>
    ratedServices<T extends User$ratedServicesArgs<ExtArgs> = {}>(args?: Subset<T, User$ratedServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    orderStatusChanges<T extends User$orderStatusChangesArgs<ExtArgs> = {}>(args?: Subset<T, User$orderStatusChangesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    deliveryProofs<T extends User$deliveryProofsArgs<ExtArgs> = {}>(args?: Subset<T, User$deliveryProofsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findMany"> | Null>
    serviceAssignments<T extends User$serviceAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$serviceAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.serviceRequests
   */
  export type User$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * User.salesmanOrders
   */
  export type User$salesmanOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.driverOrders
   */
  export type User$driverOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.staffServices
   */
  export type User$staffServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    cursor?: ServiceAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * User.contactMessages
   */
  export type User$contactMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    cursor?: ContactMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * User.handledMessages
   */
  export type User$handledMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    cursor?: ContactMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    cursor?: ServiceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * User.ratedServices
   */
  export type User$ratedServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    cursor?: ServiceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.orderStatusChanges
   */
  export type User$orderStatusChangesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    where?: OrderStatusHistoryWhereInput
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    cursor?: OrderStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusHistoryScalarFieldEnum | OrderStatusHistoryScalarFieldEnum[]
  }

  /**
   * User.deliveryProofs
   */
  export type User$deliveryProofsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    where?: DeliveryProofWhereInput
    orderBy?: DeliveryProofOrderByWithRelationInput | DeliveryProofOrderByWithRelationInput[]
    cursor?: DeliveryProofWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeliveryProofScalarFieldEnum | DeliveryProofScalarFieldEnum[]
  }

  /**
   * User.serviceAssignments
   */
  export type User$serviceAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    cursor?: ServiceAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    createdAt: Date
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly userId: FieldRef<"Session", 'Int'>
    readonly token: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type AddressMinAggregateOutputType = {
    id: number | null
    userId: number | null
    label: string | null
    line1: string | null
    line2: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    label: string | null
    line1: string | null
    line2: string | null
    city: string | null
    postalCode: string | null
    country: string | null
    isDefault: boolean | null
    createdAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    label: number
    line1: number
    line2: number
    city: number
    postalCode: number
    country: number
    isDefault: number
    createdAt: number
    _all: number
  }


  export type AddressAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    label?: true
    line1?: true
    line2?: true
    city?: true
    postalCode?: true
    country?: true
    isDefault?: true
    createdAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AddressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AddressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _avg?: AddressAvgAggregateInputType
    _sum?: AddressSumAggregateInputType
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: number
    userId: number
    label: string | null
    line1: string
    line2: string | null
    city: string
    postalCode: string
    country: string
    isDefault: boolean
    createdAt: Date
    _count: AddressCountAggregateOutputType | null
    _avg: AddressAvgAggregateOutputType | null
    _sum: AddressSumAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Address$ordersArgs<ExtArgs>
    serviceRequests?: boolean | Address$serviceRequestsArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    userId?: boolean
    label?: boolean
    line1?: boolean
    line2?: boolean
    city?: boolean
    postalCode?: boolean
    country?: boolean
    isDefault?: boolean
    createdAt?: boolean
  }

  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    orders?: boolean | Address$ordersArgs<ExtArgs>
    serviceRequests?: boolean | Address$serviceRequestsArgs<ExtArgs>
    _count?: boolean | AddressCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      orders: Prisma.$OrderPayload<ExtArgs>[]
      serviceRequests: Prisma.$ServiceRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      label: string | null
      line1: string
      line2: string | null
      city: string
      postalCode: string
      country: string
      isDefault: boolean
      createdAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends Address$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Address$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany"> | Null>
    serviceRequests<T extends Address$serviceRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Address$serviceRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */ 
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'Int'>
    readonly userId: FieldRef<"Address", 'Int'>
    readonly label: FieldRef<"Address", 'String'>
    readonly line1: FieldRef<"Address", 'String'>
    readonly line2: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly postalCode: FieldRef<"Address", 'String'>
    readonly country: FieldRef<"Address", 'String'>
    readonly isDefault: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
  }

  /**
   * Address.orders
   */
  export type Address$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Address.serviceRequests
   */
  export type Address$serviceRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    cursor?: ServiceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model ContactMessage
   */

  export type AggregateContactMessage = {
    _count: ContactMessageCountAggregateOutputType | null
    _avg: ContactMessageAvgAggregateOutputType | null
    _sum: ContactMessageSumAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  export type ContactMessageAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    handledById: number | null
  }

  export type ContactMessageSumAggregateOutputType = {
    id: number | null
    userId: number | null
    handledById: number | null
  }

  export type ContactMessageMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    userId: number | null
    handledById: number | null
    handledAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ContactMessageMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phone: string | null
    subject: string | null
    message: string | null
    userId: number | null
    handledById: number | null
    handledAt: Date | null
    status: string | null
    createdAt: Date | null
  }

  export type ContactMessageCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    subject: number
    message: number
    userId: number
    handledById: number
    handledAt: number
    status: number
    createdAt: number
    _all: number
  }


  export type ContactMessageAvgAggregateInputType = {
    id?: true
    userId?: true
    handledById?: true
  }

  export type ContactMessageSumAggregateInputType = {
    id?: true
    userId?: true
    handledById?: true
  }

  export type ContactMessageMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    userId?: true
    handledById?: true
    handledAt?: true
    status?: true
    createdAt?: true
  }

  export type ContactMessageMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    userId?: true
    handledById?: true
    handledAt?: true
    status?: true
    createdAt?: true
  }

  export type ContactMessageCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    subject?: true
    message?: true
    userId?: true
    handledById?: true
    handledAt?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type ContactMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessage to aggregate.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactMessages
    **/
    _count?: true | ContactMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMessageMaxAggregateInputType
  }

  export type GetContactMessageAggregateType<T extends ContactMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateContactMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactMessage[P]>
      : GetScalarType<T[P], AggregateContactMessage[P]>
  }




  export type ContactMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactMessageWhereInput
    orderBy?: ContactMessageOrderByWithAggregationInput | ContactMessageOrderByWithAggregationInput[]
    by: ContactMessageScalarFieldEnum[] | ContactMessageScalarFieldEnum
    having?: ContactMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactMessageCountAggregateInputType | true
    _avg?: ContactMessageAvgAggregateInputType
    _sum?: ContactMessageSumAggregateInputType
    _min?: ContactMessageMinAggregateInputType
    _max?: ContactMessageMaxAggregateInputType
  }

  export type ContactMessageGroupByOutputType = {
    id: number
    name: string
    email: string
    phone: string | null
    subject: string
    message: string
    userId: number | null
    handledById: number | null
    handledAt: Date | null
    status: string
    createdAt: Date
    _count: ContactMessageCountAggregateOutputType | null
    _avg: ContactMessageAvgAggregateOutputType | null
    _sum: ContactMessageSumAggregateOutputType | null
    _min: ContactMessageMinAggregateOutputType | null
    _max: ContactMessageMaxAggregateOutputType | null
  }

  type GetContactMessageGroupByPayload<T extends ContactMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ContactMessageGroupByOutputType[P]>
        }
      >
    >


  export type ContactMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    userId?: boolean
    handledById?: boolean
    handledAt?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    handledBy?: boolean | ContactMessage$handledByArgs<ExtArgs>
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    userId?: boolean
    handledById?: boolean
    handledAt?: boolean
    status?: boolean
    createdAt?: boolean
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    handledBy?: boolean | ContactMessage$handledByArgs<ExtArgs>
  }, ExtArgs["result"]["contactMessage"]>

  export type ContactMessageSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    subject?: boolean
    message?: boolean
    userId?: boolean
    handledById?: boolean
    handledAt?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type ContactMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    handledBy?: boolean | ContactMessage$handledByArgs<ExtArgs>
  }
  export type ContactMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ContactMessage$userArgs<ExtArgs>
    handledBy?: boolean | ContactMessage$handledByArgs<ExtArgs>
  }

  export type $ContactMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactMessage"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      handledBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phone: string | null
      subject: string
      message: string
      userId: number | null
      handledById: number | null
      handledAt: Date | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["contactMessage"]>
    composites: {}
  }

  type ContactMessageGetPayload<S extends boolean | null | undefined | ContactMessageDefaultArgs> = $Result.GetResult<Prisma.$ContactMessagePayload, S>

  type ContactMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ContactMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactMessageCountAggregateInputType | true
    }

  export interface ContactMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactMessage'], meta: { name: 'ContactMessage' } }
    /**
     * Find zero or one ContactMessage that matches the filter.
     * @param {ContactMessageFindUniqueArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactMessageFindUniqueArgs>(args: SelectSubset<T, ContactMessageFindUniqueArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ContactMessageFindUniqueOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactMessageFindFirstArgs>(args?: SelectSubset<T, ContactMessageFindFirstArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindFirstOrThrowArgs} args - Arguments to find a ContactMessage
     * @example
     * // Get one ContactMessage
     * const contactMessage = await prisma.contactMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ContactMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany()
     * 
     * // Get first 10 ContactMessages
     * const contactMessages = await prisma.contactMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactMessageFindManyArgs>(args?: SelectSubset<T, ContactMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactMessage.
     * @param {ContactMessageCreateArgs} args - Arguments to create a ContactMessage.
     * @example
     * // Create one ContactMessage
     * const ContactMessage = await prisma.contactMessage.create({
     *   data: {
     *     // ... data to create a ContactMessage
     *   }
     * })
     * 
     */
    create<T extends ContactMessageCreateArgs>(args: SelectSubset<T, ContactMessageCreateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ContactMessages.
     * @param {ContactMessageCreateManyArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactMessageCreateManyArgs>(args?: SelectSubset<T, ContactMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactMessages and returns the data saved in the database.
     * @param {ContactMessageCreateManyAndReturnArgs} args - Arguments to create many ContactMessages.
     * @example
     * // Create many ContactMessages
     * const contactMessage = await prisma.contactMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactMessages and only return the `id`
     * const contactMessageWithIdOnly = await prisma.contactMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ContactMessage.
     * @param {ContactMessageDeleteArgs} args - Arguments to delete one ContactMessage.
     * @example
     * // Delete one ContactMessage
     * const ContactMessage = await prisma.contactMessage.delete({
     *   where: {
     *     // ... filter to delete one ContactMessage
     *   }
     * })
     * 
     */
    delete<T extends ContactMessageDeleteArgs>(args: SelectSubset<T, ContactMessageDeleteArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactMessage.
     * @param {ContactMessageUpdateArgs} args - Arguments to update one ContactMessage.
     * @example
     * // Update one ContactMessage
     * const contactMessage = await prisma.contactMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactMessageUpdateArgs>(args: SelectSubset<T, ContactMessageUpdateArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ContactMessages.
     * @param {ContactMessageDeleteManyArgs} args - Arguments to filter ContactMessages to delete.
     * @example
     * // Delete a few ContactMessages
     * const { count } = await prisma.contactMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactMessageDeleteManyArgs>(args?: SelectSubset<T, ContactMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactMessages
     * const contactMessage = await prisma.contactMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactMessageUpdateManyArgs>(args: SelectSubset<T, ContactMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactMessage.
     * @param {ContactMessageUpsertArgs} args - Arguments to update or create a ContactMessage.
     * @example
     * // Update or create a ContactMessage
     * const contactMessage = await prisma.contactMessage.upsert({
     *   create: {
     *     // ... data to create a ContactMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactMessage we want to update
     *   }
     * })
     */
    upsert<T extends ContactMessageUpsertArgs>(args: SelectSubset<T, ContactMessageUpsertArgs<ExtArgs>>): Prisma__ContactMessageClient<$Result.GetResult<Prisma.$ContactMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ContactMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageCountArgs} args - Arguments to filter ContactMessages to count.
     * @example
     * // Count the number of ContactMessages
     * const count = await prisma.contactMessage.count({
     *   where: {
     *     // ... the filter for the ContactMessages we want to count
     *   }
     * })
    **/
    count<T extends ContactMessageCountArgs>(
      args?: Subset<T, ContactMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactMessageAggregateArgs>(args: Subset<T, ContactMessageAggregateArgs>): Prisma.PrismaPromise<GetContactMessageAggregateType<T>>

    /**
     * Group by ContactMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactMessageGroupByArgs['orderBy'] }
        : { orderBy?: ContactMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactMessage model
   */
  readonly fields: ContactMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ContactMessage$userArgs<ExtArgs> = {}>(args?: Subset<T, ContactMessage$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    handledBy<T extends ContactMessage$handledByArgs<ExtArgs> = {}>(args?: Subset<T, ContactMessage$handledByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactMessage model
   */ 
  interface ContactMessageFieldRefs {
    readonly id: FieldRef<"ContactMessage", 'Int'>
    readonly name: FieldRef<"ContactMessage", 'String'>
    readonly email: FieldRef<"ContactMessage", 'String'>
    readonly phone: FieldRef<"ContactMessage", 'String'>
    readonly subject: FieldRef<"ContactMessage", 'String'>
    readonly message: FieldRef<"ContactMessage", 'String'>
    readonly userId: FieldRef<"ContactMessage", 'Int'>
    readonly handledById: FieldRef<"ContactMessage", 'Int'>
    readonly handledAt: FieldRef<"ContactMessage", 'DateTime'>
    readonly status: FieldRef<"ContactMessage", 'String'>
    readonly createdAt: FieldRef<"ContactMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactMessage findUnique
   */
  export type ContactMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findUniqueOrThrow
   */
  export type ContactMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage findFirst
   */
  export type ContactMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findFirstOrThrow
   */
  export type ContactMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessage to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactMessages.
     */
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage findMany
   */
  export type ContactMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter, which ContactMessages to fetch.
     */
    where?: ContactMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactMessages to fetch.
     */
    orderBy?: ContactMessageOrderByWithRelationInput | ContactMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactMessages.
     */
    cursor?: ContactMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactMessages.
     */
    skip?: number
    distinct?: ContactMessageScalarFieldEnum | ContactMessageScalarFieldEnum[]
  }

  /**
   * ContactMessage create
   */
  export type ContactMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactMessage.
     */
    data: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
  }

  /**
   * ContactMessage createMany
   */
  export type ContactMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactMessage createManyAndReturn
   */
  export type ContactMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ContactMessages.
     */
    data: ContactMessageCreateManyInput | ContactMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactMessage update
   */
  export type ContactMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactMessage.
     */
    data: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
    /**
     * Choose, which ContactMessage to update.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage updateMany
   */
  export type ContactMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactMessages.
     */
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyInput>
    /**
     * Filter which ContactMessages to update
     */
    where?: ContactMessageWhereInput
  }

  /**
   * ContactMessage upsert
   */
  export type ContactMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactMessage to update in case it exists.
     */
    where: ContactMessageWhereUniqueInput
    /**
     * In case the ContactMessage found by the `where` argument doesn't exist, create a new ContactMessage with this data.
     */
    create: XOR<ContactMessageCreateInput, ContactMessageUncheckedCreateInput>
    /**
     * In case the ContactMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactMessageUpdateInput, ContactMessageUncheckedUpdateInput>
  }

  /**
   * ContactMessage delete
   */
  export type ContactMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
    /**
     * Filter which ContactMessage to delete.
     */
    where: ContactMessageWhereUniqueInput
  }

  /**
   * ContactMessage deleteMany
   */
  export type ContactMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactMessages to delete
     */
    where?: ContactMessageWhereInput
  }

  /**
   * ContactMessage.user
   */
  export type ContactMessage$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContactMessage.handledBy
   */
  export type ContactMessage$handledByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ContactMessage without action
   */
  export type ContactMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactMessage
     */
    select?: ContactMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactMessageInclude<ExtArgs> | null
  }


  /**
   * Model FoodCategory
   */

  export type AggregateFoodCategory = {
    _count: FoodCategoryCountAggregateOutputType | null
    _avg: FoodCategoryAvgAggregateOutputType | null
    _sum: FoodCategorySumAggregateOutputType | null
    _min: FoodCategoryMinAggregateOutputType | null
    _max: FoodCategoryMaxAggregateOutputType | null
  }

  export type FoodCategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type FoodCategorySumAggregateOutputType = {
    id: number | null
  }

  export type FoodCategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    imageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    imageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodCategoryAvgAggregateInputType = {
    id?: true
  }

  export type FoodCategorySumAggregateInputType = {
    id?: true
  }

  export type FoodCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    imageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCategory to aggregate.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodCategories
    **/
    _count?: true | FoodCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodCategoryMaxAggregateInputType
  }

  export type GetFoodCategoryAggregateType<T extends FoodCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodCategory[P]>
      : GetScalarType<T[P], AggregateFoodCategory[P]>
  }




  export type FoodCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodCategoryWhereInput
    orderBy?: FoodCategoryOrderByWithAggregationInput | FoodCategoryOrderByWithAggregationInput[]
    by: FoodCategoryScalarFieldEnum[] | FoodCategoryScalarFieldEnum
    having?: FoodCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodCategoryCountAggregateInputType | true
    _avg?: FoodCategoryAvgAggregateInputType
    _sum?: FoodCategorySumAggregateInputType
    _min?: FoodCategoryMinAggregateInputType
    _max?: FoodCategoryMaxAggregateInputType
  }

  export type FoodCategoryGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    imageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodCategoryCountAggregateOutputType | null
    _avg: FoodCategoryAvgAggregateOutputType | null
    _sum: FoodCategorySumAggregateOutputType | null
    _min: FoodCategoryMinAggregateOutputType | null
    _max: FoodCategoryMaxAggregateOutputType | null
  }

  type GetFoodCategoryGroupByPayload<T extends FoodCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], FoodCategoryGroupByOutputType[P]>
        }
      >
    >


  export type FoodCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    items?: boolean | FoodCategory$itemsArgs<ExtArgs>
    _count?: boolean | FoodCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodCategory"]>

  export type FoodCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["foodCategory"]>

  export type FoodCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | FoodCategory$itemsArgs<ExtArgs>
    _count?: boolean | FoodCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FoodCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodCategory"
    objects: {
      items: Prisma.$FoodItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      imageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodCategory"]>
    composites: {}
  }

  type FoodCategoryGetPayload<S extends boolean | null | undefined | FoodCategoryDefaultArgs> = $Result.GetResult<Prisma.$FoodCategoryPayload, S>

  type FoodCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodCategoryCountAggregateInputType | true
    }

  export interface FoodCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodCategory'], meta: { name: 'FoodCategory' } }
    /**
     * Find zero or one FoodCategory that matches the filter.
     * @param {FoodCategoryFindUniqueArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodCategoryFindUniqueArgs>(args: SelectSubset<T, FoodCategoryFindUniqueArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoodCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodCategoryFindUniqueOrThrowArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoodCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindFirstArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodCategoryFindFirstArgs>(args?: SelectSubset<T, FoodCategoryFindFirstArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoodCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindFirstOrThrowArgs} args - Arguments to find a FoodCategory
     * @example
     * // Get one FoodCategory
     * const foodCategory = await prisma.foodCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoodCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodCategories
     * const foodCategories = await prisma.foodCategory.findMany()
     * 
     * // Get first 10 FoodCategories
     * const foodCategories = await prisma.foodCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodCategoryWithIdOnly = await prisma.foodCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodCategoryFindManyArgs>(args?: SelectSubset<T, FoodCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoodCategory.
     * @param {FoodCategoryCreateArgs} args - Arguments to create a FoodCategory.
     * @example
     * // Create one FoodCategory
     * const FoodCategory = await prisma.foodCategory.create({
     *   data: {
     *     // ... data to create a FoodCategory
     *   }
     * })
     * 
     */
    create<T extends FoodCategoryCreateArgs>(args: SelectSubset<T, FoodCategoryCreateArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoodCategories.
     * @param {FoodCategoryCreateManyArgs} args - Arguments to create many FoodCategories.
     * @example
     * // Create many FoodCategories
     * const foodCategory = await prisma.foodCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodCategoryCreateManyArgs>(args?: SelectSubset<T, FoodCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodCategories and returns the data saved in the database.
     * @param {FoodCategoryCreateManyAndReturnArgs} args - Arguments to create many FoodCategories.
     * @example
     * // Create many FoodCategories
     * const foodCategory = await prisma.foodCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodCategories and only return the `id`
     * const foodCategoryWithIdOnly = await prisma.foodCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FoodCategory.
     * @param {FoodCategoryDeleteArgs} args - Arguments to delete one FoodCategory.
     * @example
     * // Delete one FoodCategory
     * const FoodCategory = await prisma.foodCategory.delete({
     *   where: {
     *     // ... filter to delete one FoodCategory
     *   }
     * })
     * 
     */
    delete<T extends FoodCategoryDeleteArgs>(args: SelectSubset<T, FoodCategoryDeleteArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoodCategory.
     * @param {FoodCategoryUpdateArgs} args - Arguments to update one FoodCategory.
     * @example
     * // Update one FoodCategory
     * const foodCategory = await prisma.foodCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodCategoryUpdateArgs>(args: SelectSubset<T, FoodCategoryUpdateArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoodCategories.
     * @param {FoodCategoryDeleteManyArgs} args - Arguments to filter FoodCategories to delete.
     * @example
     * // Delete a few FoodCategories
     * const { count } = await prisma.foodCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodCategoryDeleteManyArgs>(args?: SelectSubset<T, FoodCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodCategories
     * const foodCategory = await prisma.foodCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodCategoryUpdateManyArgs>(args: SelectSubset<T, FoodCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodCategory.
     * @param {FoodCategoryUpsertArgs} args - Arguments to update or create a FoodCategory.
     * @example
     * // Update or create a FoodCategory
     * const foodCategory = await prisma.foodCategory.upsert({
     *   create: {
     *     // ... data to create a FoodCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodCategory we want to update
     *   }
     * })
     */
    upsert<T extends FoodCategoryUpsertArgs>(args: SelectSubset<T, FoodCategoryUpsertArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FoodCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryCountArgs} args - Arguments to filter FoodCategories to count.
     * @example
     * // Count the number of FoodCategories
     * const count = await prisma.foodCategory.count({
     *   where: {
     *     // ... the filter for the FoodCategories we want to count
     *   }
     * })
    **/
    count<T extends FoodCategoryCountArgs>(
      args?: Subset<T, FoodCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodCategoryAggregateArgs>(args: Subset<T, FoodCategoryAggregateArgs>): Prisma.PrismaPromise<GetFoodCategoryAggregateType<T>>

    /**
     * Group by FoodCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodCategoryGroupByArgs['orderBy'] }
        : { orderBy?: FoodCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodCategory model
   */
  readonly fields: FoodCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    items<T extends FoodCategory$itemsArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategory$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodCategory model
   */ 
  interface FoodCategoryFieldRefs {
    readonly id: FieldRef<"FoodCategory", 'Int'>
    readonly name: FieldRef<"FoodCategory", 'String'>
    readonly slug: FieldRef<"FoodCategory", 'String'>
    readonly description: FieldRef<"FoodCategory", 'String'>
    readonly imageUrl: FieldRef<"FoodCategory", 'String'>
    readonly createdAt: FieldRef<"FoodCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodCategory findUnique
   */
  export type FoodCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory findUniqueOrThrow
   */
  export type FoodCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory findFirst
   */
  export type FoodCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCategories.
     */
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory findFirstOrThrow
   */
  export type FoodCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategory to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodCategories.
     */
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory findMany
   */
  export type FoodCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter, which FoodCategories to fetch.
     */
    where?: FoodCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodCategories to fetch.
     */
    orderBy?: FoodCategoryOrderByWithRelationInput | FoodCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodCategories.
     */
    cursor?: FoodCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodCategories.
     */
    skip?: number
    distinct?: FoodCategoryScalarFieldEnum | FoodCategoryScalarFieldEnum[]
  }

  /**
   * FoodCategory create
   */
  export type FoodCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodCategory.
     */
    data: XOR<FoodCategoryCreateInput, FoodCategoryUncheckedCreateInput>
  }

  /**
   * FoodCategory createMany
   */
  export type FoodCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodCategories.
     */
    data: FoodCategoryCreateManyInput | FoodCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodCategory createManyAndReturn
   */
  export type FoodCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FoodCategories.
     */
    data: FoodCategoryCreateManyInput | FoodCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodCategory update
   */
  export type FoodCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodCategory.
     */
    data: XOR<FoodCategoryUpdateInput, FoodCategoryUncheckedUpdateInput>
    /**
     * Choose, which FoodCategory to update.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory updateMany
   */
  export type FoodCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodCategories.
     */
    data: XOR<FoodCategoryUpdateManyMutationInput, FoodCategoryUncheckedUpdateManyInput>
    /**
     * Filter which FoodCategories to update
     */
    where?: FoodCategoryWhereInput
  }

  /**
   * FoodCategory upsert
   */
  export type FoodCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodCategory to update in case it exists.
     */
    where: FoodCategoryWhereUniqueInput
    /**
     * In case the FoodCategory found by the `where` argument doesn't exist, create a new FoodCategory with this data.
     */
    create: XOR<FoodCategoryCreateInput, FoodCategoryUncheckedCreateInput>
    /**
     * In case the FoodCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodCategoryUpdateInput, FoodCategoryUncheckedUpdateInput>
  }

  /**
   * FoodCategory delete
   */
  export type FoodCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
    /**
     * Filter which FoodCategory to delete.
     */
    where: FoodCategoryWhereUniqueInput
  }

  /**
   * FoodCategory deleteMany
   */
  export type FoodCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodCategories to delete
     */
    where?: FoodCategoryWhereInput
  }

  /**
   * FoodCategory.items
   */
  export type FoodCategory$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    where?: FoodItemWhereInput
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    cursor?: FoodItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodCategory without action
   */
  export type FoodCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodCategory
     */
    select?: FoodCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodCategoryInclude<ExtArgs> | null
  }


  /**
   * Model FoodItem
   */

  export type AggregateFoodItem = {
    _count: FoodItemCountAggregateOutputType | null
    _avg: FoodItemAvgAggregateOutputType | null
    _sum: FoodItemSumAggregateOutputType | null
    _min: FoodItemMinAggregateOutputType | null
    _max: FoodItemMaxAggregateOutputType | null
  }

  export type FoodItemAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
    categoryId: number | null
  }

  export type FoodItemSumAggregateOutputType = {
    id: number | null
    price: Decimal | null
    stock: number | null
    categoryId: number | null
  }

  export type FoodItemMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    sku: string | null
    stock: number | null
    isActive: boolean | null
    categoryId: number | null
    mainImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodItemMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    price: Decimal | null
    sku: string | null
    stock: number | null
    isActive: boolean | null
    categoryId: number | null
    mainImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FoodItemCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    price: number
    sku: number
    stock: number
    isActive: number
    categoryId: number
    mainImageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FoodItemAvgAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    categoryId?: true
  }

  export type FoodItemSumAggregateInputType = {
    id?: true
    price?: true
    stock?: true
    categoryId?: true
  }

  export type FoodItemMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    isActive?: true
    categoryId?: true
    mainImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodItemMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    isActive?: true
    categoryId?: true
    mainImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FoodItemCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    price?: true
    sku?: true
    stock?: true
    isActive?: true
    categoryId?: true
    mainImageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FoodItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodItem to aggregate.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodItems
    **/
    _count?: true | FoodItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodItemMaxAggregateInputType
  }

  export type GetFoodItemAggregateType<T extends FoodItemAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodItem[P]>
      : GetScalarType<T[P], AggregateFoodItem[P]>
  }




  export type FoodItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodItemWhereInput
    orderBy?: FoodItemOrderByWithAggregationInput | FoodItemOrderByWithAggregationInput[]
    by: FoodItemScalarFieldEnum[] | FoodItemScalarFieldEnum
    having?: FoodItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodItemCountAggregateInputType | true
    _avg?: FoodItemAvgAggregateInputType
    _sum?: FoodItemSumAggregateInputType
    _min?: FoodItemMinAggregateInputType
    _max?: FoodItemMaxAggregateInputType
  }

  export type FoodItemGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    price: Decimal
    sku: string | null
    stock: number
    isActive: boolean
    categoryId: number
    mainImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: FoodItemCountAggregateOutputType | null
    _avg: FoodItemAvgAggregateOutputType | null
    _sum: FoodItemSumAggregateOutputType | null
    _min: FoodItemMinAggregateOutputType | null
    _max: FoodItemMaxAggregateOutputType | null
  }

  type GetFoodItemGroupByPayload<T extends FoodItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodItemGroupByOutputType[P]>
            : GetScalarType<T[P], FoodItemGroupByOutputType[P]>
        }
      >
    >


  export type FoodItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    isActive?: boolean
    categoryId?: boolean
    mainImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
    images?: boolean | FoodItem$imagesArgs<ExtArgs>
    orderItems?: boolean | FoodItem$orderItemsArgs<ExtArgs>
    _count?: boolean | FoodItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodItem"]>

  export type FoodItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    isActive?: boolean
    categoryId?: boolean
    mainImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodItem"]>

  export type FoodItemSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    price?: boolean
    sku?: boolean
    stock?: boolean
    isActive?: boolean
    categoryId?: boolean
    mainImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FoodItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
    images?: boolean | FoodItem$imagesArgs<ExtArgs>
    orderItems?: boolean | FoodItem$orderItemsArgs<ExtArgs>
    _count?: boolean | FoodItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FoodItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | FoodCategoryDefaultArgs<ExtArgs>
  }

  export type $FoodItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodItem"
    objects: {
      category: Prisma.$FoodCategoryPayload<ExtArgs>
      images: Prisma.$FoodImagePayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      price: Prisma.Decimal
      sku: string | null
      stock: number
      isActive: boolean
      categoryId: number
      mainImageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["foodItem"]>
    composites: {}
  }

  type FoodItemGetPayload<S extends boolean | null | undefined | FoodItemDefaultArgs> = $Result.GetResult<Prisma.$FoodItemPayload, S>

  type FoodItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodItemCountAggregateInputType | true
    }

  export interface FoodItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodItem'], meta: { name: 'FoodItem' } }
    /**
     * Find zero or one FoodItem that matches the filter.
     * @param {FoodItemFindUniqueArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodItemFindUniqueArgs>(args: SelectSubset<T, FoodItemFindUniqueArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoodItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodItemFindUniqueOrThrowArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodItemFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoodItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindFirstArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodItemFindFirstArgs>(args?: SelectSubset<T, FoodItemFindFirstArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoodItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindFirstOrThrowArgs} args - Arguments to find a FoodItem
     * @example
     * // Get one FoodItem
     * const foodItem = await prisma.foodItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodItemFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoodItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodItems
     * const foodItems = await prisma.foodItem.findMany()
     * 
     * // Get first 10 FoodItems
     * const foodItems = await prisma.foodItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodItemWithIdOnly = await prisma.foodItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodItemFindManyArgs>(args?: SelectSubset<T, FoodItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoodItem.
     * @param {FoodItemCreateArgs} args - Arguments to create a FoodItem.
     * @example
     * // Create one FoodItem
     * const FoodItem = await prisma.foodItem.create({
     *   data: {
     *     // ... data to create a FoodItem
     *   }
     * })
     * 
     */
    create<T extends FoodItemCreateArgs>(args: SelectSubset<T, FoodItemCreateArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoodItems.
     * @param {FoodItemCreateManyArgs} args - Arguments to create many FoodItems.
     * @example
     * // Create many FoodItems
     * const foodItem = await prisma.foodItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodItemCreateManyArgs>(args?: SelectSubset<T, FoodItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodItems and returns the data saved in the database.
     * @param {FoodItemCreateManyAndReturnArgs} args - Arguments to create many FoodItems.
     * @example
     * // Create many FoodItems
     * const foodItem = await prisma.foodItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodItems and only return the `id`
     * const foodItemWithIdOnly = await prisma.foodItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodItemCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FoodItem.
     * @param {FoodItemDeleteArgs} args - Arguments to delete one FoodItem.
     * @example
     * // Delete one FoodItem
     * const FoodItem = await prisma.foodItem.delete({
     *   where: {
     *     // ... filter to delete one FoodItem
     *   }
     * })
     * 
     */
    delete<T extends FoodItemDeleteArgs>(args: SelectSubset<T, FoodItemDeleteArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoodItem.
     * @param {FoodItemUpdateArgs} args - Arguments to update one FoodItem.
     * @example
     * // Update one FoodItem
     * const foodItem = await prisma.foodItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodItemUpdateArgs>(args: SelectSubset<T, FoodItemUpdateArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoodItems.
     * @param {FoodItemDeleteManyArgs} args - Arguments to filter FoodItems to delete.
     * @example
     * // Delete a few FoodItems
     * const { count } = await prisma.foodItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodItemDeleteManyArgs>(args?: SelectSubset<T, FoodItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodItems
     * const foodItem = await prisma.foodItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodItemUpdateManyArgs>(args: SelectSubset<T, FoodItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodItem.
     * @param {FoodItemUpsertArgs} args - Arguments to update or create a FoodItem.
     * @example
     * // Update or create a FoodItem
     * const foodItem = await prisma.foodItem.upsert({
     *   create: {
     *     // ... data to create a FoodItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodItem we want to update
     *   }
     * })
     */
    upsert<T extends FoodItemUpsertArgs>(args: SelectSubset<T, FoodItemUpsertArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FoodItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemCountArgs} args - Arguments to filter FoodItems to count.
     * @example
     * // Count the number of FoodItems
     * const count = await prisma.foodItem.count({
     *   where: {
     *     // ... the filter for the FoodItems we want to count
     *   }
     * })
    **/
    count<T extends FoodItemCountArgs>(
      args?: Subset<T, FoodItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodItemAggregateArgs>(args: Subset<T, FoodItemAggregateArgs>): Prisma.PrismaPromise<GetFoodItemAggregateType<T>>

    /**
     * Group by FoodItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodItemGroupByArgs['orderBy'] }
        : { orderBy?: FoodItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodItem model
   */
  readonly fields: FoodItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends FoodCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodCategoryDefaultArgs<ExtArgs>>): Prisma__FoodCategoryClient<$Result.GetResult<Prisma.$FoodCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    images<T extends FoodItem$imagesArgs<ExtArgs> = {}>(args?: Subset<T, FoodItem$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findMany"> | Null>
    orderItems<T extends FoodItem$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, FoodItem$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodItem model
   */ 
  interface FoodItemFieldRefs {
    readonly id: FieldRef<"FoodItem", 'Int'>
    readonly name: FieldRef<"FoodItem", 'String'>
    readonly slug: FieldRef<"FoodItem", 'String'>
    readonly description: FieldRef<"FoodItem", 'String'>
    readonly price: FieldRef<"FoodItem", 'Decimal'>
    readonly sku: FieldRef<"FoodItem", 'String'>
    readonly stock: FieldRef<"FoodItem", 'Int'>
    readonly isActive: FieldRef<"FoodItem", 'Boolean'>
    readonly categoryId: FieldRef<"FoodItem", 'Int'>
    readonly mainImageUrl: FieldRef<"FoodItem", 'String'>
    readonly createdAt: FieldRef<"FoodItem", 'DateTime'>
    readonly updatedAt: FieldRef<"FoodItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodItem findUnique
   */
  export type FoodItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem findUniqueOrThrow
   */
  export type FoodItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem findFirst
   */
  export type FoodItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodItems.
     */
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem findFirstOrThrow
   */
  export type FoodItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodItem to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodItems.
     */
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem findMany
   */
  export type FoodItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter, which FoodItems to fetch.
     */
    where?: FoodItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodItems to fetch.
     */
    orderBy?: FoodItemOrderByWithRelationInput | FoodItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodItems.
     */
    cursor?: FoodItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodItems.
     */
    skip?: number
    distinct?: FoodItemScalarFieldEnum | FoodItemScalarFieldEnum[]
  }

  /**
   * FoodItem create
   */
  export type FoodItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodItem.
     */
    data: XOR<FoodItemCreateInput, FoodItemUncheckedCreateInput>
  }

  /**
   * FoodItem createMany
   */
  export type FoodItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodItems.
     */
    data: FoodItemCreateManyInput | FoodItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodItem createManyAndReturn
   */
  export type FoodItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FoodItems.
     */
    data: FoodItemCreateManyInput | FoodItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodItem update
   */
  export type FoodItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodItem.
     */
    data: XOR<FoodItemUpdateInput, FoodItemUncheckedUpdateInput>
    /**
     * Choose, which FoodItem to update.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem updateMany
   */
  export type FoodItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodItems.
     */
    data: XOR<FoodItemUpdateManyMutationInput, FoodItemUncheckedUpdateManyInput>
    /**
     * Filter which FoodItems to update
     */
    where?: FoodItemWhereInput
  }

  /**
   * FoodItem upsert
   */
  export type FoodItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodItem to update in case it exists.
     */
    where: FoodItemWhereUniqueInput
    /**
     * In case the FoodItem found by the `where` argument doesn't exist, create a new FoodItem with this data.
     */
    create: XOR<FoodItemCreateInput, FoodItemUncheckedCreateInput>
    /**
     * In case the FoodItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodItemUpdateInput, FoodItemUncheckedUpdateInput>
  }

  /**
   * FoodItem delete
   */
  export type FoodItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
    /**
     * Filter which FoodItem to delete.
     */
    where: FoodItemWhereUniqueInput
  }

  /**
   * FoodItem deleteMany
   */
  export type FoodItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodItems to delete
     */
    where?: FoodItemWhereInput
  }

  /**
   * FoodItem.images
   */
  export type FoodItem$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    where?: FoodImageWhereInput
    orderBy?: FoodImageOrderByWithRelationInput | FoodImageOrderByWithRelationInput[]
    cursor?: FoodImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FoodImageScalarFieldEnum | FoodImageScalarFieldEnum[]
  }

  /**
   * FoodItem.orderItems
   */
  export type FoodItem$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * FoodItem without action
   */
  export type FoodItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodItem
     */
    select?: FoodItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodItemInclude<ExtArgs> | null
  }


  /**
   * Model FoodImage
   */

  export type AggregateFoodImage = {
    _count: FoodImageCountAggregateOutputType | null
    _avg: FoodImageAvgAggregateOutputType | null
    _sum: FoodImageSumAggregateOutputType | null
    _min: FoodImageMinAggregateOutputType | null
    _max: FoodImageMaxAggregateOutputType | null
  }

  export type FoodImageAvgAggregateOutputType = {
    id: number | null
    foodItemId: number | null
    position: number | null
  }

  export type FoodImageSumAggregateOutputType = {
    id: number | null
    foodItemId: number | null
    position: number | null
  }

  export type FoodImageMinAggregateOutputType = {
    id: number | null
    foodItemId: number | null
    url: string | null
    position: number | null
    createdAt: Date | null
  }

  export type FoodImageMaxAggregateOutputType = {
    id: number | null
    foodItemId: number | null
    url: string | null
    position: number | null
    createdAt: Date | null
  }

  export type FoodImageCountAggregateOutputType = {
    id: number
    foodItemId: number
    url: number
    position: number
    createdAt: number
    _all: number
  }


  export type FoodImageAvgAggregateInputType = {
    id?: true
    foodItemId?: true
    position?: true
  }

  export type FoodImageSumAggregateInputType = {
    id?: true
    foodItemId?: true
    position?: true
  }

  export type FoodImageMinAggregateInputType = {
    id?: true
    foodItemId?: true
    url?: true
    position?: true
    createdAt?: true
  }

  export type FoodImageMaxAggregateInputType = {
    id?: true
    foodItemId?: true
    url?: true
    position?: true
    createdAt?: true
  }

  export type FoodImageCountAggregateInputType = {
    id?: true
    foodItemId?: true
    url?: true
    position?: true
    createdAt?: true
    _all?: true
  }

  export type FoodImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodImage to aggregate.
     */
    where?: FoodImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodImages to fetch.
     */
    orderBy?: FoodImageOrderByWithRelationInput | FoodImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FoodImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FoodImages
    **/
    _count?: true | FoodImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FoodImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FoodImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FoodImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FoodImageMaxAggregateInputType
  }

  export type GetFoodImageAggregateType<T extends FoodImageAggregateArgs> = {
        [P in keyof T & keyof AggregateFoodImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFoodImage[P]>
      : GetScalarType<T[P], AggregateFoodImage[P]>
  }




  export type FoodImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FoodImageWhereInput
    orderBy?: FoodImageOrderByWithAggregationInput | FoodImageOrderByWithAggregationInput[]
    by: FoodImageScalarFieldEnum[] | FoodImageScalarFieldEnum
    having?: FoodImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FoodImageCountAggregateInputType | true
    _avg?: FoodImageAvgAggregateInputType
    _sum?: FoodImageSumAggregateInputType
    _min?: FoodImageMinAggregateInputType
    _max?: FoodImageMaxAggregateInputType
  }

  export type FoodImageGroupByOutputType = {
    id: number
    foodItemId: number
    url: string
    position: number
    createdAt: Date
    _count: FoodImageCountAggregateOutputType | null
    _avg: FoodImageAvgAggregateOutputType | null
    _sum: FoodImageSumAggregateOutputType | null
    _min: FoodImageMinAggregateOutputType | null
    _max: FoodImageMaxAggregateOutputType | null
  }

  type GetFoodImageGroupByPayload<T extends FoodImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FoodImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FoodImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FoodImageGroupByOutputType[P]>
            : GetScalarType<T[P], FoodImageGroupByOutputType[P]>
        }
      >
    >


  export type FoodImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodItemId?: boolean
    url?: boolean
    position?: boolean
    createdAt?: boolean
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodImage"]>

  export type FoodImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    foodItemId?: boolean
    url?: boolean
    position?: boolean
    createdAt?: boolean
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foodImage"]>

  export type FoodImageSelectScalar = {
    id?: boolean
    foodItemId?: boolean
    url?: boolean
    position?: boolean
    createdAt?: boolean
  }

  export type FoodImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }
  export type FoodImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }

  export type $FoodImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FoodImage"
    objects: {
      foodItem: Prisma.$FoodItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      foodItemId: number
      url: string
      position: number
      createdAt: Date
    }, ExtArgs["result"]["foodImage"]>
    composites: {}
  }

  type FoodImageGetPayload<S extends boolean | null | undefined | FoodImageDefaultArgs> = $Result.GetResult<Prisma.$FoodImagePayload, S>

  type FoodImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FoodImageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FoodImageCountAggregateInputType | true
    }

  export interface FoodImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FoodImage'], meta: { name: 'FoodImage' } }
    /**
     * Find zero or one FoodImage that matches the filter.
     * @param {FoodImageFindUniqueArgs} args - Arguments to find a FoodImage
     * @example
     * // Get one FoodImage
     * const foodImage = await prisma.foodImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FoodImageFindUniqueArgs>(args: SelectSubset<T, FoodImageFindUniqueArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FoodImage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FoodImageFindUniqueOrThrowArgs} args - Arguments to find a FoodImage
     * @example
     * // Get one FoodImage
     * const foodImage = await prisma.foodImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FoodImageFindUniqueOrThrowArgs>(args: SelectSubset<T, FoodImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FoodImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageFindFirstArgs} args - Arguments to find a FoodImage
     * @example
     * // Get one FoodImage
     * const foodImage = await prisma.foodImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FoodImageFindFirstArgs>(args?: SelectSubset<T, FoodImageFindFirstArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FoodImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageFindFirstOrThrowArgs} args - Arguments to find a FoodImage
     * @example
     * // Get one FoodImage
     * const foodImage = await prisma.foodImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FoodImageFindFirstOrThrowArgs>(args?: SelectSubset<T, FoodImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FoodImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FoodImages
     * const foodImages = await prisma.foodImage.findMany()
     * 
     * // Get first 10 FoodImages
     * const foodImages = await prisma.foodImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foodImageWithIdOnly = await prisma.foodImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FoodImageFindManyArgs>(args?: SelectSubset<T, FoodImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FoodImage.
     * @param {FoodImageCreateArgs} args - Arguments to create a FoodImage.
     * @example
     * // Create one FoodImage
     * const FoodImage = await prisma.foodImage.create({
     *   data: {
     *     // ... data to create a FoodImage
     *   }
     * })
     * 
     */
    create<T extends FoodImageCreateArgs>(args: SelectSubset<T, FoodImageCreateArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FoodImages.
     * @param {FoodImageCreateManyArgs} args - Arguments to create many FoodImages.
     * @example
     * // Create many FoodImages
     * const foodImage = await prisma.foodImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FoodImageCreateManyArgs>(args?: SelectSubset<T, FoodImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FoodImages and returns the data saved in the database.
     * @param {FoodImageCreateManyAndReturnArgs} args - Arguments to create many FoodImages.
     * @example
     * // Create many FoodImages
     * const foodImage = await prisma.foodImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FoodImages and only return the `id`
     * const foodImageWithIdOnly = await prisma.foodImage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FoodImageCreateManyAndReturnArgs>(args?: SelectSubset<T, FoodImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FoodImage.
     * @param {FoodImageDeleteArgs} args - Arguments to delete one FoodImage.
     * @example
     * // Delete one FoodImage
     * const FoodImage = await prisma.foodImage.delete({
     *   where: {
     *     // ... filter to delete one FoodImage
     *   }
     * })
     * 
     */
    delete<T extends FoodImageDeleteArgs>(args: SelectSubset<T, FoodImageDeleteArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FoodImage.
     * @param {FoodImageUpdateArgs} args - Arguments to update one FoodImage.
     * @example
     * // Update one FoodImage
     * const foodImage = await prisma.foodImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FoodImageUpdateArgs>(args: SelectSubset<T, FoodImageUpdateArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FoodImages.
     * @param {FoodImageDeleteManyArgs} args - Arguments to filter FoodImages to delete.
     * @example
     * // Delete a few FoodImages
     * const { count } = await prisma.foodImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FoodImageDeleteManyArgs>(args?: SelectSubset<T, FoodImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FoodImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FoodImages
     * const foodImage = await prisma.foodImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FoodImageUpdateManyArgs>(args: SelectSubset<T, FoodImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FoodImage.
     * @param {FoodImageUpsertArgs} args - Arguments to update or create a FoodImage.
     * @example
     * // Update or create a FoodImage
     * const foodImage = await prisma.foodImage.upsert({
     *   create: {
     *     // ... data to create a FoodImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FoodImage we want to update
     *   }
     * })
     */
    upsert<T extends FoodImageUpsertArgs>(args: SelectSubset<T, FoodImageUpsertArgs<ExtArgs>>): Prisma__FoodImageClient<$Result.GetResult<Prisma.$FoodImagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FoodImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageCountArgs} args - Arguments to filter FoodImages to count.
     * @example
     * // Count the number of FoodImages
     * const count = await prisma.foodImage.count({
     *   where: {
     *     // ... the filter for the FoodImages we want to count
     *   }
     * })
    **/
    count<T extends FoodImageCountArgs>(
      args?: Subset<T, FoodImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FoodImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FoodImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FoodImageAggregateArgs>(args: Subset<T, FoodImageAggregateArgs>): Prisma.PrismaPromise<GetFoodImageAggregateType<T>>

    /**
     * Group by FoodImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FoodImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FoodImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FoodImageGroupByArgs['orderBy'] }
        : { orderBy?: FoodImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FoodImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFoodImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FoodImage model
   */
  readonly fields: FoodImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FoodImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FoodImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    foodItem<T extends FoodItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodItemDefaultArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FoodImage model
   */ 
  interface FoodImageFieldRefs {
    readonly id: FieldRef<"FoodImage", 'Int'>
    readonly foodItemId: FieldRef<"FoodImage", 'Int'>
    readonly url: FieldRef<"FoodImage", 'String'>
    readonly position: FieldRef<"FoodImage", 'Int'>
    readonly createdAt: FieldRef<"FoodImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FoodImage findUnique
   */
  export type FoodImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter, which FoodImage to fetch.
     */
    where: FoodImageWhereUniqueInput
  }

  /**
   * FoodImage findUniqueOrThrow
   */
  export type FoodImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter, which FoodImage to fetch.
     */
    where: FoodImageWhereUniqueInput
  }

  /**
   * FoodImage findFirst
   */
  export type FoodImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter, which FoodImage to fetch.
     */
    where?: FoodImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodImages to fetch.
     */
    orderBy?: FoodImageOrderByWithRelationInput | FoodImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodImages.
     */
    cursor?: FoodImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodImages.
     */
    distinct?: FoodImageScalarFieldEnum | FoodImageScalarFieldEnum[]
  }

  /**
   * FoodImage findFirstOrThrow
   */
  export type FoodImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter, which FoodImage to fetch.
     */
    where?: FoodImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodImages to fetch.
     */
    orderBy?: FoodImageOrderByWithRelationInput | FoodImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FoodImages.
     */
    cursor?: FoodImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FoodImages.
     */
    distinct?: FoodImageScalarFieldEnum | FoodImageScalarFieldEnum[]
  }

  /**
   * FoodImage findMany
   */
  export type FoodImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter, which FoodImages to fetch.
     */
    where?: FoodImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FoodImages to fetch.
     */
    orderBy?: FoodImageOrderByWithRelationInput | FoodImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FoodImages.
     */
    cursor?: FoodImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FoodImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FoodImages.
     */
    skip?: number
    distinct?: FoodImageScalarFieldEnum | FoodImageScalarFieldEnum[]
  }

  /**
   * FoodImage create
   */
  export type FoodImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * The data needed to create a FoodImage.
     */
    data: XOR<FoodImageCreateInput, FoodImageUncheckedCreateInput>
  }

  /**
   * FoodImage createMany
   */
  export type FoodImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FoodImages.
     */
    data: FoodImageCreateManyInput | FoodImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FoodImage createManyAndReturn
   */
  export type FoodImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FoodImages.
     */
    data: FoodImageCreateManyInput | FoodImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FoodImage update
   */
  export type FoodImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * The data needed to update a FoodImage.
     */
    data: XOR<FoodImageUpdateInput, FoodImageUncheckedUpdateInput>
    /**
     * Choose, which FoodImage to update.
     */
    where: FoodImageWhereUniqueInput
  }

  /**
   * FoodImage updateMany
   */
  export type FoodImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FoodImages.
     */
    data: XOR<FoodImageUpdateManyMutationInput, FoodImageUncheckedUpdateManyInput>
    /**
     * Filter which FoodImages to update
     */
    where?: FoodImageWhereInput
  }

  /**
   * FoodImage upsert
   */
  export type FoodImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * The filter to search for the FoodImage to update in case it exists.
     */
    where: FoodImageWhereUniqueInput
    /**
     * In case the FoodImage found by the `where` argument doesn't exist, create a new FoodImage with this data.
     */
    create: XOR<FoodImageCreateInput, FoodImageUncheckedCreateInput>
    /**
     * In case the FoodImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FoodImageUpdateInput, FoodImageUncheckedUpdateInput>
  }

  /**
   * FoodImage delete
   */
  export type FoodImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
    /**
     * Filter which FoodImage to delete.
     */
    where: FoodImageWhereUniqueInput
  }

  /**
   * FoodImage deleteMany
   */
  export type FoodImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FoodImages to delete
     */
    where?: FoodImageWhereInput
  }

  /**
   * FoodImage without action
   */
  export type FoodImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FoodImage
     */
    select?: FoodImageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FoodImageInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    deliveryAddressId: number | null
    totalPrice: Decimal | null
    salesmanId: number | null
    driverId: number | null
  }

  export type OrderSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    deliveryAddressId: number | null
    totalPrice: Decimal | null
    salesmanId: number | null
    driverId: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    customerId: number | null
    deliveryAddressId: number | null
    status: $Enums.OrderStatus | null
    notes: string | null
    imageUrl: string | null
    totalPrice: Decimal | null
    salesmanId: number | null
    driverId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: number | null
    orderNumber: string | null
    customerId: number | null
    deliveryAddressId: number | null
    status: $Enums.OrderStatus | null
    notes: string | null
    imageUrl: string | null
    totalPrice: Decimal | null
    salesmanId: number | null
    driverId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    orderNumber: number
    customerId: number
    deliveryAddressId: number
    status: number
    notes: number
    imageUrl: number
    totalPrice: number
    salesmanId: number
    driverId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    id?: true
    customerId?: true
    deliveryAddressId?: true
    totalPrice?: true
    salesmanId?: true
    driverId?: true
  }

  export type OrderSumAggregateInputType = {
    id?: true
    customerId?: true
    deliveryAddressId?: true
    totalPrice?: true
    salesmanId?: true
    driverId?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    deliveryAddressId?: true
    status?: true
    notes?: true
    imageUrl?: true
    totalPrice?: true
    salesmanId?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    deliveryAddressId?: true
    status?: true
    notes?: true
    imageUrl?: true
    totalPrice?: true
    salesmanId?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    orderNumber?: true
    customerId?: true
    deliveryAddressId?: true
    status?: true
    notes?: true
    imageUrl?: true
    totalPrice?: true
    salesmanId?: true
    driverId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: number
    orderNumber: string
    customerId: number
    deliveryAddressId: number | null
    status: $Enums.OrderStatus
    notes: string | null
    imageUrl: string | null
    totalPrice: Decimal
    salesmanId: number | null
    driverId: number | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    deliveryAddressId?: boolean
    status?: boolean
    notes?: boolean
    imageUrl?: boolean
    totalPrice?: boolean
    salesmanId?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    statusHistory?: boolean | Order$statusHistoryArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    salesman?: boolean | Order$salesmanArgs<ExtArgs>
    driver?: boolean | Order$driverArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    deliveryProof?: boolean | Order$deliveryProofArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    deliveryAddressId?: boolean
    status?: boolean
    notes?: boolean
    imageUrl?: boolean
    totalPrice?: boolean
    salesmanId?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    salesman?: boolean | Order$salesmanArgs<ExtArgs>
    driver?: boolean | Order$driverArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    orderNumber?: boolean
    customerId?: boolean
    deliveryAddressId?: boolean
    status?: boolean
    notes?: boolean
    imageUrl?: boolean
    totalPrice?: boolean
    salesmanId?: boolean
    driverId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    statusHistory?: boolean | Order$statusHistoryArgs<ExtArgs>
    items?: boolean | Order$itemsArgs<ExtArgs>
    salesman?: boolean | Order$salesmanArgs<ExtArgs>
    driver?: boolean | Order$driverArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    deliveryProof?: boolean | Order$deliveryProofArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    deliveryAddress?: boolean | Order$deliveryAddressArgs<ExtArgs>
    salesman?: boolean | Order$salesmanArgs<ExtArgs>
    driver?: boolean | Order$driverArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      deliveryAddress: Prisma.$AddressPayload<ExtArgs> | null
      statusHistory: Prisma.$OrderStatusHistoryPayload<ExtArgs>[]
      items: Prisma.$OrderItemPayload<ExtArgs>[]
      salesman: Prisma.$UserPayload<ExtArgs> | null
      driver: Prisma.$UserPayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      deliveryProof: Prisma.$DeliveryProofPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderNumber: string
      customerId: number
      deliveryAddressId: number | null
      status: $Enums.OrderStatus
      notes: string | null
      imageUrl: string | null
      totalPrice: Prisma.Decimal
      salesmanId: number | null
      driverId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    deliveryAddress<T extends Order$deliveryAddressArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveryAddressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    statusHistory<T extends Order$statusHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Order$statusHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    items<T extends Order$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    salesman<T extends Order$salesmanArgs<ExtArgs> = {}>(args?: Subset<T, Order$salesmanArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    driver<T extends Order$driverArgs<ExtArgs> = {}>(args?: Subset<T, Order$driverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    deliveryProof<T extends Order$deliveryProofArgs<ExtArgs> = {}>(args?: Subset<T, Order$deliveryProofArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */ 
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'Int'>
    readonly orderNumber: FieldRef<"Order", 'String'>
    readonly customerId: FieldRef<"Order", 'Int'>
    readonly deliveryAddressId: FieldRef<"Order", 'Int'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly notes: FieldRef<"Order", 'String'>
    readonly imageUrl: FieldRef<"Order", 'String'>
    readonly totalPrice: FieldRef<"Order", 'Decimal'>
    readonly salesmanId: FieldRef<"Order", 'Int'>
    readonly driverId: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
  }

  /**
   * Order.deliveryAddress
   */
  export type Order$deliveryAddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * Order.statusHistory
   */
  export type Order$statusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    where?: OrderStatusHistoryWhereInput
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    cursor?: OrderStatusHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderStatusHistoryScalarFieldEnum | OrderStatusHistoryScalarFieldEnum[]
  }

  /**
   * Order.items
   */
  export type Order$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.salesman
   */
  export type Order$salesmanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.driver
   */
  export type Order$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.payment
   */
  export type Order$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Order.deliveryProof
   */
  export type Order$deliveryProofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    where?: DeliveryProofWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    foodItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    foodItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    foodItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    foodItemId: number | null
    quantity: number | null
    unitPrice: Decimal | null
    createdAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    foodItemId: number
    quantity: number
    unitPrice: number
    createdAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    foodItemId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    foodItemId?: true
    quantity?: true
    unitPrice?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    foodItemId?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    foodItemId?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    foodItemId?: true
    quantity?: true
    unitPrice?: true
    createdAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    foodItemId: number
    quantity: number
    unitPrice: Decimal
    createdAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    foodItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    foodItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    foodItemId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    createdAt?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    foodItem?: boolean | FoodItemDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      foodItem: Prisma.$FoodItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      foodItemId: number
      quantity: number
      unitPrice: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    foodItem<T extends FoodItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FoodItemDefaultArgs<ExtArgs>>): Prisma__FoodItemClient<$Result.GetResult<Prisma.$FoodItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly foodItemId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Decimal'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderStatusHistory
   */

  export type AggregateOrderStatusHistory = {
    _count: OrderStatusHistoryCountAggregateOutputType | null
    _avg: OrderStatusHistoryAvgAggregateOutputType | null
    _sum: OrderStatusHistorySumAggregateOutputType | null
    _min: OrderStatusHistoryMinAggregateOutputType | null
    _max: OrderStatusHistoryMaxAggregateOutputType | null
  }

  export type OrderStatusHistoryAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedById: number | null
  }

  export type OrderStatusHistorySumAggregateOutputType = {
    id: number | null
    orderId: number | null
    changedById: number | null
  }

  export type OrderStatusHistoryMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    from: $Enums.OrderStatus | null
    to: $Enums.OrderStatus | null
    changedAt: Date | null
    changedById: number | null
    note: string | null
  }

  export type OrderStatusHistoryMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    from: $Enums.OrderStatus | null
    to: $Enums.OrderStatus | null
    changedAt: Date | null
    changedById: number | null
    note: string | null
  }

  export type OrderStatusHistoryCountAggregateOutputType = {
    id: number
    orderId: number
    from: number
    to: number
    changedAt: number
    changedById: number
    note: number
    _all: number
  }


  export type OrderStatusHistoryAvgAggregateInputType = {
    id?: true
    orderId?: true
    changedById?: true
  }

  export type OrderStatusHistorySumAggregateInputType = {
    id?: true
    orderId?: true
    changedById?: true
  }

  export type OrderStatusHistoryMinAggregateInputType = {
    id?: true
    orderId?: true
    from?: true
    to?: true
    changedAt?: true
    changedById?: true
    note?: true
  }

  export type OrderStatusHistoryMaxAggregateInputType = {
    id?: true
    orderId?: true
    from?: true
    to?: true
    changedAt?: true
    changedById?: true
    note?: true
  }

  export type OrderStatusHistoryCountAggregateInputType = {
    id?: true
    orderId?: true
    from?: true
    to?: true
    changedAt?: true
    changedById?: true
    note?: true
    _all?: true
  }

  export type OrderStatusHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatusHistory to aggregate.
     */
    where?: OrderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusHistories to fetch.
     */
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderStatusHistories
    **/
    _count?: true | OrderStatusHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderStatusHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderStatusHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderStatusHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderStatusHistoryMaxAggregateInputType
  }

  export type GetOrderStatusHistoryAggregateType<T extends OrderStatusHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderStatusHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderStatusHistory[P]>
      : GetScalarType<T[P], AggregateOrderStatusHistory[P]>
  }




  export type OrderStatusHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderStatusHistoryWhereInput
    orderBy?: OrderStatusHistoryOrderByWithAggregationInput | OrderStatusHistoryOrderByWithAggregationInput[]
    by: OrderStatusHistoryScalarFieldEnum[] | OrderStatusHistoryScalarFieldEnum
    having?: OrderStatusHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderStatusHistoryCountAggregateInputType | true
    _avg?: OrderStatusHistoryAvgAggregateInputType
    _sum?: OrderStatusHistorySumAggregateInputType
    _min?: OrderStatusHistoryMinAggregateInputType
    _max?: OrderStatusHistoryMaxAggregateInputType
  }

  export type OrderStatusHistoryGroupByOutputType = {
    id: number
    orderId: number
    from: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt: Date
    changedById: number | null
    note: string | null
    _count: OrderStatusHistoryCountAggregateOutputType | null
    _avg: OrderStatusHistoryAvgAggregateOutputType | null
    _sum: OrderStatusHistorySumAggregateOutputType | null
    _min: OrderStatusHistoryMinAggregateOutputType | null
    _max: OrderStatusHistoryMaxAggregateOutputType | null
  }

  type GetOrderStatusHistoryGroupByPayload<T extends OrderStatusHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderStatusHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderStatusHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderStatusHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], OrderStatusHistoryGroupByOutputType[P]>
        }
      >
    >


  export type OrderStatusHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    from?: boolean
    to?: boolean
    changedAt?: boolean
    changedById?: boolean
    note?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    changedBy?: boolean | OrderStatusHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatusHistory"]>

  export type OrderStatusHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    from?: boolean
    to?: boolean
    changedAt?: boolean
    changedById?: boolean
    note?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    changedBy?: boolean | OrderStatusHistory$changedByArgs<ExtArgs>
  }, ExtArgs["result"]["orderStatusHistory"]>

  export type OrderStatusHistorySelectScalar = {
    id?: boolean
    orderId?: boolean
    from?: boolean
    to?: boolean
    changedAt?: boolean
    changedById?: boolean
    note?: boolean
  }

  export type OrderStatusHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    changedBy?: boolean | OrderStatusHistory$changedByArgs<ExtArgs>
  }
  export type OrderStatusHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    changedBy?: boolean | OrderStatusHistory$changedByArgs<ExtArgs>
  }

  export type $OrderStatusHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderStatusHistory"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      changedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      from: $Enums.OrderStatus | null
      to: $Enums.OrderStatus
      changedAt: Date
      changedById: number | null
      note: string | null
    }, ExtArgs["result"]["orderStatusHistory"]>
    composites: {}
  }

  type OrderStatusHistoryGetPayload<S extends boolean | null | undefined | OrderStatusHistoryDefaultArgs> = $Result.GetResult<Prisma.$OrderStatusHistoryPayload, S>

  type OrderStatusHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderStatusHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderStatusHistoryCountAggregateInputType | true
    }

  export interface OrderStatusHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderStatusHistory'], meta: { name: 'OrderStatusHistory' } }
    /**
     * Find zero or one OrderStatusHistory that matches the filter.
     * @param {OrderStatusHistoryFindUniqueArgs} args - Arguments to find a OrderStatusHistory
     * @example
     * // Get one OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderStatusHistoryFindUniqueArgs>(args: SelectSubset<T, OrderStatusHistoryFindUniqueArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderStatusHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderStatusHistoryFindUniqueOrThrowArgs} args - Arguments to find a OrderStatusHistory
     * @example
     * // Get one OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderStatusHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderStatusHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderStatusHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryFindFirstArgs} args - Arguments to find a OrderStatusHistory
     * @example
     * // Get one OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderStatusHistoryFindFirstArgs>(args?: SelectSubset<T, OrderStatusHistoryFindFirstArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderStatusHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryFindFirstOrThrowArgs} args - Arguments to find a OrderStatusHistory
     * @example
     * // Get one OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderStatusHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderStatusHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderStatusHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderStatusHistories
     * const orderStatusHistories = await prisma.orderStatusHistory.findMany()
     * 
     * // Get first 10 OrderStatusHistories
     * const orderStatusHistories = await prisma.orderStatusHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderStatusHistoryWithIdOnly = await prisma.orderStatusHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderStatusHistoryFindManyArgs>(args?: SelectSubset<T, OrderStatusHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderStatusHistory.
     * @param {OrderStatusHistoryCreateArgs} args - Arguments to create a OrderStatusHistory.
     * @example
     * // Create one OrderStatusHistory
     * const OrderStatusHistory = await prisma.orderStatusHistory.create({
     *   data: {
     *     // ... data to create a OrderStatusHistory
     *   }
     * })
     * 
     */
    create<T extends OrderStatusHistoryCreateArgs>(args: SelectSubset<T, OrderStatusHistoryCreateArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderStatusHistories.
     * @param {OrderStatusHistoryCreateManyArgs} args - Arguments to create many OrderStatusHistories.
     * @example
     * // Create many OrderStatusHistories
     * const orderStatusHistory = await prisma.orderStatusHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderStatusHistoryCreateManyArgs>(args?: SelectSubset<T, OrderStatusHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderStatusHistories and returns the data saved in the database.
     * @param {OrderStatusHistoryCreateManyAndReturnArgs} args - Arguments to create many OrderStatusHistories.
     * @example
     * // Create many OrderStatusHistories
     * const orderStatusHistory = await prisma.orderStatusHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderStatusHistories and only return the `id`
     * const orderStatusHistoryWithIdOnly = await prisma.orderStatusHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderStatusHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderStatusHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderStatusHistory.
     * @param {OrderStatusHistoryDeleteArgs} args - Arguments to delete one OrderStatusHistory.
     * @example
     * // Delete one OrderStatusHistory
     * const OrderStatusHistory = await prisma.orderStatusHistory.delete({
     *   where: {
     *     // ... filter to delete one OrderStatusHistory
     *   }
     * })
     * 
     */
    delete<T extends OrderStatusHistoryDeleteArgs>(args: SelectSubset<T, OrderStatusHistoryDeleteArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderStatusHistory.
     * @param {OrderStatusHistoryUpdateArgs} args - Arguments to update one OrderStatusHistory.
     * @example
     * // Update one OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderStatusHistoryUpdateArgs>(args: SelectSubset<T, OrderStatusHistoryUpdateArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderStatusHistories.
     * @param {OrderStatusHistoryDeleteManyArgs} args - Arguments to filter OrderStatusHistories to delete.
     * @example
     * // Delete a few OrderStatusHistories
     * const { count } = await prisma.orderStatusHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderStatusHistoryDeleteManyArgs>(args?: SelectSubset<T, OrderStatusHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderStatusHistories
     * const orderStatusHistory = await prisma.orderStatusHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderStatusHistoryUpdateManyArgs>(args: SelectSubset<T, OrderStatusHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderStatusHistory.
     * @param {OrderStatusHistoryUpsertArgs} args - Arguments to update or create a OrderStatusHistory.
     * @example
     * // Update or create a OrderStatusHistory
     * const orderStatusHistory = await prisma.orderStatusHistory.upsert({
     *   create: {
     *     // ... data to create a OrderStatusHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderStatusHistory we want to update
     *   }
     * })
     */
    upsert<T extends OrderStatusHistoryUpsertArgs>(args: SelectSubset<T, OrderStatusHistoryUpsertArgs<ExtArgs>>): Prisma__OrderStatusHistoryClient<$Result.GetResult<Prisma.$OrderStatusHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderStatusHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryCountArgs} args - Arguments to filter OrderStatusHistories to count.
     * @example
     * // Count the number of OrderStatusHistories
     * const count = await prisma.orderStatusHistory.count({
     *   where: {
     *     // ... the filter for the OrderStatusHistories we want to count
     *   }
     * })
    **/
    count<T extends OrderStatusHistoryCountArgs>(
      args?: Subset<T, OrderStatusHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderStatusHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderStatusHistoryAggregateArgs>(args: Subset<T, OrderStatusHistoryAggregateArgs>): Prisma.PrismaPromise<GetOrderStatusHistoryAggregateType<T>>

    /**
     * Group by OrderStatusHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderStatusHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderStatusHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderStatusHistoryGroupByArgs['orderBy'] }
        : { orderBy?: OrderStatusHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderStatusHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderStatusHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderStatusHistory model
   */
  readonly fields: OrderStatusHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderStatusHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderStatusHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    changedBy<T extends OrderStatusHistory$changedByArgs<ExtArgs> = {}>(args?: Subset<T, OrderStatusHistory$changedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderStatusHistory model
   */ 
  interface OrderStatusHistoryFieldRefs {
    readonly id: FieldRef<"OrderStatusHistory", 'Int'>
    readonly orderId: FieldRef<"OrderStatusHistory", 'Int'>
    readonly from: FieldRef<"OrderStatusHistory", 'OrderStatus'>
    readonly to: FieldRef<"OrderStatusHistory", 'OrderStatus'>
    readonly changedAt: FieldRef<"OrderStatusHistory", 'DateTime'>
    readonly changedById: FieldRef<"OrderStatusHistory", 'Int'>
    readonly note: FieldRef<"OrderStatusHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrderStatusHistory findUnique
   */
  export type OrderStatusHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusHistory to fetch.
     */
    where: OrderStatusHistoryWhereUniqueInput
  }

  /**
   * OrderStatusHistory findUniqueOrThrow
   */
  export type OrderStatusHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusHistory to fetch.
     */
    where: OrderStatusHistoryWhereUniqueInput
  }

  /**
   * OrderStatusHistory findFirst
   */
  export type OrderStatusHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusHistory to fetch.
     */
    where?: OrderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusHistories to fetch.
     */
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatusHistories.
     */
    cursor?: OrderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatusHistories.
     */
    distinct?: OrderStatusHistoryScalarFieldEnum | OrderStatusHistoryScalarFieldEnum[]
  }

  /**
   * OrderStatusHistory findFirstOrThrow
   */
  export type OrderStatusHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusHistory to fetch.
     */
    where?: OrderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusHistories to fetch.
     */
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderStatusHistories.
     */
    cursor?: OrderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderStatusHistories.
     */
    distinct?: OrderStatusHistoryScalarFieldEnum | OrderStatusHistoryScalarFieldEnum[]
  }

  /**
   * OrderStatusHistory findMany
   */
  export type OrderStatusHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter, which OrderStatusHistories to fetch.
     */
    where?: OrderStatusHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderStatusHistories to fetch.
     */
    orderBy?: OrderStatusHistoryOrderByWithRelationInput | OrderStatusHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderStatusHistories.
     */
    cursor?: OrderStatusHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderStatusHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderStatusHistories.
     */
    skip?: number
    distinct?: OrderStatusHistoryScalarFieldEnum | OrderStatusHistoryScalarFieldEnum[]
  }

  /**
   * OrderStatusHistory create
   */
  export type OrderStatusHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderStatusHistory.
     */
    data: XOR<OrderStatusHistoryCreateInput, OrderStatusHistoryUncheckedCreateInput>
  }

  /**
   * OrderStatusHistory createMany
   */
  export type OrderStatusHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderStatusHistories.
     */
    data: OrderStatusHistoryCreateManyInput | OrderStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderStatusHistory createManyAndReturn
   */
  export type OrderStatusHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderStatusHistories.
     */
    data: OrderStatusHistoryCreateManyInput | OrderStatusHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderStatusHistory update
   */
  export type OrderStatusHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderStatusHistory.
     */
    data: XOR<OrderStatusHistoryUpdateInput, OrderStatusHistoryUncheckedUpdateInput>
    /**
     * Choose, which OrderStatusHistory to update.
     */
    where: OrderStatusHistoryWhereUniqueInput
  }

  /**
   * OrderStatusHistory updateMany
   */
  export type OrderStatusHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderStatusHistories.
     */
    data: XOR<OrderStatusHistoryUpdateManyMutationInput, OrderStatusHistoryUncheckedUpdateManyInput>
    /**
     * Filter which OrderStatusHistories to update
     */
    where?: OrderStatusHistoryWhereInput
  }

  /**
   * OrderStatusHistory upsert
   */
  export type OrderStatusHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderStatusHistory to update in case it exists.
     */
    where: OrderStatusHistoryWhereUniqueInput
    /**
     * In case the OrderStatusHistory found by the `where` argument doesn't exist, create a new OrderStatusHistory with this data.
     */
    create: XOR<OrderStatusHistoryCreateInput, OrderStatusHistoryUncheckedCreateInput>
    /**
     * In case the OrderStatusHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderStatusHistoryUpdateInput, OrderStatusHistoryUncheckedUpdateInput>
  }

  /**
   * OrderStatusHistory delete
   */
  export type OrderStatusHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
    /**
     * Filter which OrderStatusHistory to delete.
     */
    where: OrderStatusHistoryWhereUniqueInput
  }

  /**
   * OrderStatusHistory deleteMany
   */
  export type OrderStatusHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderStatusHistories to delete
     */
    where?: OrderStatusHistoryWhereInput
  }

  /**
   * OrderStatusHistory.changedBy
   */
  export type OrderStatusHistory$changedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * OrderStatusHistory without action
   */
  export type OrderStatusHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderStatusHistory
     */
    select?: OrderStatusHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderStatusHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    amount: Decimal | null
    transactionId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    amount: Decimal | null
    transactionId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    amount: Decimal | null
    currency: string | null
    provider: string | null
    status: string | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    amount: Decimal | null
    currency: string | null
    provider: string | null
    status: string | null
    transactionId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    orderId: number
    amount: number
    currency: number
    provider: number
    status: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    transactionId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    transactionId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    provider?: true
    status?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    provider?: true
    status?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    orderId?: true
    amount?: true
    currency?: true
    provider?: true
    status?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    orderId: number
    amount: Decimal
    currency: string
    provider: string | null
    status: string
    transactionId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    status?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    status?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    orderId?: boolean
    amount?: boolean
    currency?: boolean
    provider?: boolean
    status?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      amount: Prisma.Decimal
      currency: string
      provider: string | null
      status: string
      transactionId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly orderId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly transactionId: FieldRef<"Payment", 'Int'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryProof
   */

  export type AggregateDeliveryProof = {
    _count: DeliveryProofCountAggregateOutputType | null
    _avg: DeliveryProofAvgAggregateOutputType | null
    _sum: DeliveryProofSumAggregateOutputType | null
    _min: DeliveryProofMinAggregateOutputType | null
    _max: DeliveryProofMaxAggregateOutputType | null
  }

  export type DeliveryProofAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    driverId: number | null
  }

  export type DeliveryProofSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    driverId: number | null
  }

  export type DeliveryProofMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    photoUrl: string | null
    note: string | null
    deliveredAt: Date | null
    driverId: number | null
  }

  export type DeliveryProofMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    photoUrl: string | null
    note: string | null
    deliveredAt: Date | null
    driverId: number | null
  }

  export type DeliveryProofCountAggregateOutputType = {
    id: number
    orderId: number
    photoUrl: number
    note: number
    deliveredAt: number
    driverId: number
    _all: number
  }


  export type DeliveryProofAvgAggregateInputType = {
    id?: true
    orderId?: true
    driverId?: true
  }

  export type DeliveryProofSumAggregateInputType = {
    id?: true
    orderId?: true
    driverId?: true
  }

  export type DeliveryProofMinAggregateInputType = {
    id?: true
    orderId?: true
    photoUrl?: true
    note?: true
    deliveredAt?: true
    driverId?: true
  }

  export type DeliveryProofMaxAggregateInputType = {
    id?: true
    orderId?: true
    photoUrl?: true
    note?: true
    deliveredAt?: true
    driverId?: true
  }

  export type DeliveryProofCountAggregateInputType = {
    id?: true
    orderId?: true
    photoUrl?: true
    note?: true
    deliveredAt?: true
    driverId?: true
    _all?: true
  }

  export type DeliveryProofAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryProof to aggregate.
     */
    where?: DeliveryProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryProofs to fetch.
     */
    orderBy?: DeliveryProofOrderByWithRelationInput | DeliveryProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryProofs
    **/
    _count?: true | DeliveryProofCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryProofAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryProofSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryProofMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryProofMaxAggregateInputType
  }

  export type GetDeliveryProofAggregateType<T extends DeliveryProofAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryProof]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryProof[P]>
      : GetScalarType<T[P], AggregateDeliveryProof[P]>
  }




  export type DeliveryProofGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryProofWhereInput
    orderBy?: DeliveryProofOrderByWithAggregationInput | DeliveryProofOrderByWithAggregationInput[]
    by: DeliveryProofScalarFieldEnum[] | DeliveryProofScalarFieldEnum
    having?: DeliveryProofScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryProofCountAggregateInputType | true
    _avg?: DeliveryProofAvgAggregateInputType
    _sum?: DeliveryProofSumAggregateInputType
    _min?: DeliveryProofMinAggregateInputType
    _max?: DeliveryProofMaxAggregateInputType
  }

  export type DeliveryProofGroupByOutputType = {
    id: number
    orderId: number
    photoUrl: string
    note: string | null
    deliveredAt: Date
    driverId: number | null
    _count: DeliveryProofCountAggregateOutputType | null
    _avg: DeliveryProofAvgAggregateOutputType | null
    _sum: DeliveryProofSumAggregateOutputType | null
    _min: DeliveryProofMinAggregateOutputType | null
    _max: DeliveryProofMaxAggregateOutputType | null
  }

  type GetDeliveryProofGroupByPayload<T extends DeliveryProofGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryProofGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryProofGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryProofGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryProofGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryProofSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    photoUrl?: boolean
    note?: boolean
    deliveredAt?: boolean
    driverId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    driver?: boolean | DeliveryProof$driverArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryProof"]>

  export type DeliveryProofSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    photoUrl?: boolean
    note?: boolean
    deliveredAt?: boolean
    driverId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    driver?: boolean | DeliveryProof$driverArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryProof"]>

  export type DeliveryProofSelectScalar = {
    id?: boolean
    orderId?: boolean
    photoUrl?: boolean
    note?: boolean
    deliveredAt?: boolean
    driverId?: boolean
  }

  export type DeliveryProofInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    driver?: boolean | DeliveryProof$driverArgs<ExtArgs>
  }
  export type DeliveryProofIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    driver?: boolean | DeliveryProof$driverArgs<ExtArgs>
  }

  export type $DeliveryProofPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryProof"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      driver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      photoUrl: string
      note: string | null
      deliveredAt: Date
      driverId: number | null
    }, ExtArgs["result"]["deliveryProof"]>
    composites: {}
  }

  type DeliveryProofGetPayload<S extends boolean | null | undefined | DeliveryProofDefaultArgs> = $Result.GetResult<Prisma.$DeliveryProofPayload, S>

  type DeliveryProofCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DeliveryProofFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DeliveryProofCountAggregateInputType | true
    }

  export interface DeliveryProofDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryProof'], meta: { name: 'DeliveryProof' } }
    /**
     * Find zero or one DeliveryProof that matches the filter.
     * @param {DeliveryProofFindUniqueArgs} args - Arguments to find a DeliveryProof
     * @example
     * // Get one DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryProofFindUniqueArgs>(args: SelectSubset<T, DeliveryProofFindUniqueArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DeliveryProof that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DeliveryProofFindUniqueOrThrowArgs} args - Arguments to find a DeliveryProof
     * @example
     * // Get one DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryProofFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryProofFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DeliveryProof that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofFindFirstArgs} args - Arguments to find a DeliveryProof
     * @example
     * // Get one DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryProofFindFirstArgs>(args?: SelectSubset<T, DeliveryProofFindFirstArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DeliveryProof that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofFindFirstOrThrowArgs} args - Arguments to find a DeliveryProof
     * @example
     * // Get one DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryProofFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryProofFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DeliveryProofs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryProofs
     * const deliveryProofs = await prisma.deliveryProof.findMany()
     * 
     * // Get first 10 DeliveryProofs
     * const deliveryProofs = await prisma.deliveryProof.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryProofWithIdOnly = await prisma.deliveryProof.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryProofFindManyArgs>(args?: SelectSubset<T, DeliveryProofFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DeliveryProof.
     * @param {DeliveryProofCreateArgs} args - Arguments to create a DeliveryProof.
     * @example
     * // Create one DeliveryProof
     * const DeliveryProof = await prisma.deliveryProof.create({
     *   data: {
     *     // ... data to create a DeliveryProof
     *   }
     * })
     * 
     */
    create<T extends DeliveryProofCreateArgs>(args: SelectSubset<T, DeliveryProofCreateArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DeliveryProofs.
     * @param {DeliveryProofCreateManyArgs} args - Arguments to create many DeliveryProofs.
     * @example
     * // Create many DeliveryProofs
     * const deliveryProof = await prisma.deliveryProof.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryProofCreateManyArgs>(args?: SelectSubset<T, DeliveryProofCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryProofs and returns the data saved in the database.
     * @param {DeliveryProofCreateManyAndReturnArgs} args - Arguments to create many DeliveryProofs.
     * @example
     * // Create many DeliveryProofs
     * const deliveryProof = await prisma.deliveryProof.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryProofs and only return the `id`
     * const deliveryProofWithIdOnly = await prisma.deliveryProof.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryProofCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryProofCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DeliveryProof.
     * @param {DeliveryProofDeleteArgs} args - Arguments to delete one DeliveryProof.
     * @example
     * // Delete one DeliveryProof
     * const DeliveryProof = await prisma.deliveryProof.delete({
     *   where: {
     *     // ... filter to delete one DeliveryProof
     *   }
     * })
     * 
     */
    delete<T extends DeliveryProofDeleteArgs>(args: SelectSubset<T, DeliveryProofDeleteArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DeliveryProof.
     * @param {DeliveryProofUpdateArgs} args - Arguments to update one DeliveryProof.
     * @example
     * // Update one DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryProofUpdateArgs>(args: SelectSubset<T, DeliveryProofUpdateArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DeliveryProofs.
     * @param {DeliveryProofDeleteManyArgs} args - Arguments to filter DeliveryProofs to delete.
     * @example
     * // Delete a few DeliveryProofs
     * const { count } = await prisma.deliveryProof.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryProofDeleteManyArgs>(args?: SelectSubset<T, DeliveryProofDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryProofs
     * const deliveryProof = await prisma.deliveryProof.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryProofUpdateManyArgs>(args: SelectSubset<T, DeliveryProofUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeliveryProof.
     * @param {DeliveryProofUpsertArgs} args - Arguments to update or create a DeliveryProof.
     * @example
     * // Update or create a DeliveryProof
     * const deliveryProof = await prisma.deliveryProof.upsert({
     *   create: {
     *     // ... data to create a DeliveryProof
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryProof we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryProofUpsertArgs>(args: SelectSubset<T, DeliveryProofUpsertArgs<ExtArgs>>): Prisma__DeliveryProofClient<$Result.GetResult<Prisma.$DeliveryProofPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DeliveryProofs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofCountArgs} args - Arguments to filter DeliveryProofs to count.
     * @example
     * // Count the number of DeliveryProofs
     * const count = await prisma.deliveryProof.count({
     *   where: {
     *     // ... the filter for the DeliveryProofs we want to count
     *   }
     * })
    **/
    count<T extends DeliveryProofCountArgs>(
      args?: Subset<T, DeliveryProofCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryProofCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryProofAggregateArgs>(args: Subset<T, DeliveryProofAggregateArgs>): Prisma.PrismaPromise<GetDeliveryProofAggregateType<T>>

    /**
     * Group by DeliveryProof.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryProofGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryProofGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryProofGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryProofGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryProofGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryProofGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryProof model
   */
  readonly fields: DeliveryProofFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryProof.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryProofClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    driver<T extends DeliveryProof$driverArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryProof$driverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryProof model
   */ 
  interface DeliveryProofFieldRefs {
    readonly id: FieldRef<"DeliveryProof", 'Int'>
    readonly orderId: FieldRef<"DeliveryProof", 'Int'>
    readonly photoUrl: FieldRef<"DeliveryProof", 'String'>
    readonly note: FieldRef<"DeliveryProof", 'String'>
    readonly deliveredAt: FieldRef<"DeliveryProof", 'DateTime'>
    readonly driverId: FieldRef<"DeliveryProof", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryProof findUnique
   */
  export type DeliveryProofFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryProof to fetch.
     */
    where: DeliveryProofWhereUniqueInput
  }

  /**
   * DeliveryProof findUniqueOrThrow
   */
  export type DeliveryProofFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryProof to fetch.
     */
    where: DeliveryProofWhereUniqueInput
  }

  /**
   * DeliveryProof findFirst
   */
  export type DeliveryProofFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryProof to fetch.
     */
    where?: DeliveryProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryProofs to fetch.
     */
    orderBy?: DeliveryProofOrderByWithRelationInput | DeliveryProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryProofs.
     */
    cursor?: DeliveryProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryProofs.
     */
    distinct?: DeliveryProofScalarFieldEnum | DeliveryProofScalarFieldEnum[]
  }

  /**
   * DeliveryProof findFirstOrThrow
   */
  export type DeliveryProofFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryProof to fetch.
     */
    where?: DeliveryProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryProofs to fetch.
     */
    orderBy?: DeliveryProofOrderByWithRelationInput | DeliveryProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryProofs.
     */
    cursor?: DeliveryProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryProofs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryProofs.
     */
    distinct?: DeliveryProofScalarFieldEnum | DeliveryProofScalarFieldEnum[]
  }

  /**
   * DeliveryProof findMany
   */
  export type DeliveryProofFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryProofs to fetch.
     */
    where?: DeliveryProofWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryProofs to fetch.
     */
    orderBy?: DeliveryProofOrderByWithRelationInput | DeliveryProofOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryProofs.
     */
    cursor?: DeliveryProofWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryProofs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryProofs.
     */
    skip?: number
    distinct?: DeliveryProofScalarFieldEnum | DeliveryProofScalarFieldEnum[]
  }

  /**
   * DeliveryProof create
   */
  export type DeliveryProofCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryProof.
     */
    data: XOR<DeliveryProofCreateInput, DeliveryProofUncheckedCreateInput>
  }

  /**
   * DeliveryProof createMany
   */
  export type DeliveryProofCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryProofs.
     */
    data: DeliveryProofCreateManyInput | DeliveryProofCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeliveryProof createManyAndReturn
   */
  export type DeliveryProofCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DeliveryProofs.
     */
    data: DeliveryProofCreateManyInput | DeliveryProofCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeliveryProof update
   */
  export type DeliveryProofUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryProof.
     */
    data: XOR<DeliveryProofUpdateInput, DeliveryProofUncheckedUpdateInput>
    /**
     * Choose, which DeliveryProof to update.
     */
    where: DeliveryProofWhereUniqueInput
  }

  /**
   * DeliveryProof updateMany
   */
  export type DeliveryProofUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryProofs.
     */
    data: XOR<DeliveryProofUpdateManyMutationInput, DeliveryProofUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryProofs to update
     */
    where?: DeliveryProofWhereInput
  }

  /**
   * DeliveryProof upsert
   */
  export type DeliveryProofUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryProof to update in case it exists.
     */
    where: DeliveryProofWhereUniqueInput
    /**
     * In case the DeliveryProof found by the `where` argument doesn't exist, create a new DeliveryProof with this data.
     */
    create: XOR<DeliveryProofCreateInput, DeliveryProofUncheckedCreateInput>
    /**
     * In case the DeliveryProof was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryProofUpdateInput, DeliveryProofUncheckedUpdateInput>
  }

  /**
   * DeliveryProof delete
   */
  export type DeliveryProofDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
    /**
     * Filter which DeliveryProof to delete.
     */
    where: DeliveryProofWhereUniqueInput
  }

  /**
   * DeliveryProof deleteMany
   */
  export type DeliveryProofDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryProofs to delete
     */
    where?: DeliveryProofWhereInput
  }

  /**
   * DeliveryProof.driver
   */
  export type DeliveryProof$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DeliveryProof without action
   */
  export type DeliveryProofDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryProof
     */
    select?: DeliveryProofSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryProofInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRequest
   */

  export type AggregateServiceRequest = {
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  export type ServiceRequestAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    addressId: number | null
  }

  export type ServiceRequestSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    addressId: number | null
  }

  export type ServiceRequestMinAggregateOutputType = {
    id: number | null
    requestNumber: string | null
    customerId: number | null
    type: $Enums.ServiceType | null
    status: $Enums.ServiceStatus | null
    priority: $Enums.ServicePriority | null
    title: string | null
    description: string | null
    addressId: number | null
    requestedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestMaxAggregateOutputType = {
    id: number | null
    requestNumber: string | null
    customerId: number | null
    type: $Enums.ServiceType | null
    status: $Enums.ServiceStatus | null
    priority: $Enums.ServicePriority | null
    title: string | null
    description: string | null
    addressId: number | null
    requestedDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceRequestCountAggregateOutputType = {
    id: number
    requestNumber: number
    customerId: number
    type: number
    status: number
    priority: number
    title: number
    description: number
    addressId: number
    requestedDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceRequestAvgAggregateInputType = {
    id?: true
    customerId?: true
    addressId?: true
  }

  export type ServiceRequestSumAggregateInputType = {
    id?: true
    customerId?: true
    addressId?: true
  }

  export type ServiceRequestMinAggregateInputType = {
    id?: true
    requestNumber?: true
    customerId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    description?: true
    addressId?: true
    requestedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestMaxAggregateInputType = {
    id?: true
    requestNumber?: true
    customerId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    description?: true
    addressId?: true
    requestedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceRequestCountAggregateInputType = {
    id?: true
    requestNumber?: true
    customerId?: true
    type?: true
    status?: true
    priority?: true
    title?: true
    description?: true
    addressId?: true
    requestedDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequest to aggregate.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRequests
    **/
    _count?: true | ServiceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type GetServiceRequestAggregateType<T extends ServiceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRequest[P]>
      : GetScalarType<T[P], AggregateServiceRequest[P]>
  }




  export type ServiceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRequestWhereInput
    orderBy?: ServiceRequestOrderByWithAggregationInput | ServiceRequestOrderByWithAggregationInput[]
    by: ServiceRequestScalarFieldEnum[] | ServiceRequestScalarFieldEnum
    having?: ServiceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRequestCountAggregateInputType | true
    _avg?: ServiceRequestAvgAggregateInputType
    _sum?: ServiceRequestSumAggregateInputType
    _min?: ServiceRequestMinAggregateInputType
    _max?: ServiceRequestMaxAggregateInputType
  }

  export type ServiceRequestGroupByOutputType = {
    id: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status: $Enums.ServiceStatus
    priority: $Enums.ServicePriority
    title: string
    description: string
    addressId: number | null
    requestedDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceRequestCountAggregateOutputType | null
    _avg: ServiceRequestAvgAggregateOutputType | null
    _sum: ServiceRequestSumAggregateOutputType | null
    _min: ServiceRequestMinAggregateOutputType | null
    _max: ServiceRequestMaxAggregateOutputType | null
  }

  type GetServiceRequestGroupByPayload<T extends ServiceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRequestGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestNumber?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    addressId?: boolean
    requestedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | ServiceRequest$addressArgs<ExtArgs>
    photos?: boolean | ServiceRequest$photosArgs<ExtArgs>
    assignments?: boolean | ServiceRequest$assignmentsArgs<ExtArgs>
    ratings?: boolean | ServiceRequest$ratingsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requestNumber?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    addressId?: boolean
    requestedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customer?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | ServiceRequest$addressArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRequest"]>

  export type ServiceRequestSelectScalar = {
    id?: boolean
    requestNumber?: boolean
    customerId?: boolean
    type?: boolean
    status?: boolean
    priority?: boolean
    title?: boolean
    description?: boolean
    addressId?: boolean
    requestedDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | ServiceRequest$addressArgs<ExtArgs>
    photos?: boolean | ServiceRequest$photosArgs<ExtArgs>
    assignments?: boolean | ServiceRequest$assignmentsArgs<ExtArgs>
    ratings?: boolean | ServiceRequest$ratingsArgs<ExtArgs>
    _count?: boolean | ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | UserDefaultArgs<ExtArgs>
    address?: boolean | ServiceRequest$addressArgs<ExtArgs>
  }

  export type $ServiceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRequest"
    objects: {
      customer: Prisma.$UserPayload<ExtArgs>
      address: Prisma.$AddressPayload<ExtArgs> | null
      photos: Prisma.$ServicePhotoPayload<ExtArgs>[]
      assignments: Prisma.$ServiceAssignmentPayload<ExtArgs>[]
      ratings: Prisma.$ServiceRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      requestNumber: string
      customerId: number
      type: $Enums.ServiceType
      status: $Enums.ServiceStatus
      priority: $Enums.ServicePriority
      title: string
      description: string
      addressId: number | null
      requestedDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceRequest"]>
    composites: {}
  }

  type ServiceRequestGetPayload<S extends boolean | null | undefined | ServiceRequestDefaultArgs> = $Result.GetResult<Prisma.$ServiceRequestPayload, S>

  type ServiceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceRequestCountAggregateInputType | true
    }

  export interface ServiceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRequest'], meta: { name: 'ServiceRequest' } }
    /**
     * Find zero or one ServiceRequest that matches the filter.
     * @param {ServiceRequestFindUniqueArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRequestFindUniqueArgs>(args: SelectSubset<T, ServiceRequestFindUniqueArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceRequestFindUniqueOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRequestFindFirstArgs>(args?: SelectSubset<T, ServiceRequestFindFirstArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindFirstOrThrowArgs} args - Arguments to find a ServiceRequest
     * @example
     * // Get one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany()
     * 
     * // Get first 10 ServiceRequests
     * const serviceRequests = await prisma.serviceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRequestFindManyArgs>(args?: SelectSubset<T, ServiceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceRequest.
     * @param {ServiceRequestCreateArgs} args - Arguments to create a ServiceRequest.
     * @example
     * // Create one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.create({
     *   data: {
     *     // ... data to create a ServiceRequest
     *   }
     * })
     * 
     */
    create<T extends ServiceRequestCreateArgs>(args: SelectSubset<T, ServiceRequestCreateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceRequests.
     * @param {ServiceRequestCreateManyArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRequestCreateManyArgs>(args?: SelectSubset<T, ServiceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRequests and returns the data saved in the database.
     * @param {ServiceRequestCreateManyAndReturnArgs} args - Arguments to create many ServiceRequests.
     * @example
     * // Create many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRequests and only return the `id`
     * const serviceRequestWithIdOnly = await prisma.serviceRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceRequest.
     * @param {ServiceRequestDeleteArgs} args - Arguments to delete one ServiceRequest.
     * @example
     * // Delete one ServiceRequest
     * const ServiceRequest = await prisma.serviceRequest.delete({
     *   where: {
     *     // ... filter to delete one ServiceRequest
     *   }
     * })
     * 
     */
    delete<T extends ServiceRequestDeleteArgs>(args: SelectSubset<T, ServiceRequestDeleteArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceRequest.
     * @param {ServiceRequestUpdateArgs} args - Arguments to update one ServiceRequest.
     * @example
     * // Update one ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRequestUpdateArgs>(args: SelectSubset<T, ServiceRequestUpdateArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceRequests.
     * @param {ServiceRequestDeleteManyArgs} args - Arguments to filter ServiceRequests to delete.
     * @example
     * // Delete a few ServiceRequests
     * const { count } = await prisma.serviceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRequestDeleteManyArgs>(args?: SelectSubset<T, ServiceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRequests
     * const serviceRequest = await prisma.serviceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRequestUpdateManyArgs>(args: SelectSubset<T, ServiceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceRequest.
     * @param {ServiceRequestUpsertArgs} args - Arguments to update or create a ServiceRequest.
     * @example
     * // Update or create a ServiceRequest
     * const serviceRequest = await prisma.serviceRequest.upsert({
     *   create: {
     *     // ... data to create a ServiceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRequest we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRequestUpsertArgs>(args: SelectSubset<T, ServiceRequestUpsertArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestCountArgs} args - Arguments to filter ServiceRequests to count.
     * @example
     * // Count the number of ServiceRequests
     * const count = await prisma.serviceRequest.count({
     *   where: {
     *     // ... the filter for the ServiceRequests we want to count
     *   }
     * })
    **/
    count<T extends ServiceRequestCountArgs>(
      args?: Subset<T, ServiceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRequestAggregateArgs>(args: Subset<T, ServiceRequestAggregateArgs>): Prisma.PrismaPromise<GetServiceRequestAggregateType<T>>

    /**
     * Group by ServiceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRequestGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRequest model
   */
  readonly fields: ServiceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    address<T extends ServiceRequest$addressArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$addressArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    photos<T extends ServiceRequest$photosArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findMany"> | Null>
    assignments<T extends ServiceRequest$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    ratings<T extends ServiceRequest$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequest$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRequest model
   */ 
  interface ServiceRequestFieldRefs {
    readonly id: FieldRef<"ServiceRequest", 'Int'>
    readonly requestNumber: FieldRef<"ServiceRequest", 'String'>
    readonly customerId: FieldRef<"ServiceRequest", 'Int'>
    readonly type: FieldRef<"ServiceRequest", 'ServiceType'>
    readonly status: FieldRef<"ServiceRequest", 'ServiceStatus'>
    readonly priority: FieldRef<"ServiceRequest", 'ServicePriority'>
    readonly title: FieldRef<"ServiceRequest", 'String'>
    readonly description: FieldRef<"ServiceRequest", 'String'>
    readonly addressId: FieldRef<"ServiceRequest", 'Int'>
    readonly requestedDate: FieldRef<"ServiceRequest", 'DateTime'>
    readonly notes: FieldRef<"ServiceRequest", 'String'>
    readonly createdAt: FieldRef<"ServiceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRequest findUnique
   */
  export type ServiceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findUniqueOrThrow
   */
  export type ServiceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest findFirst
   */
  export type ServiceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findFirstOrThrow
   */
  export type ServiceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequest to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRequests.
     */
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest findMany
   */
  export type ServiceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRequests to fetch.
     */
    where?: ServiceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRequests to fetch.
     */
    orderBy?: ServiceRequestOrderByWithRelationInput | ServiceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRequests.
     */
    cursor?: ServiceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRequests.
     */
    skip?: number
    distinct?: ServiceRequestScalarFieldEnum | ServiceRequestScalarFieldEnum[]
  }

  /**
   * ServiceRequest create
   */
  export type ServiceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRequest.
     */
    data: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
  }

  /**
   * ServiceRequest createMany
   */
  export type ServiceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceRequest createManyAndReturn
   */
  export type ServiceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceRequests.
     */
    data: ServiceRequestCreateManyInput | ServiceRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRequest update
   */
  export type ServiceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRequest.
     */
    data: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
    /**
     * Choose, which ServiceRequest to update.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest updateMany
   */
  export type ServiceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRequests.
     */
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRequests to update
     */
    where?: ServiceRequestWhereInput
  }

  /**
   * ServiceRequest upsert
   */
  export type ServiceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRequest to update in case it exists.
     */
    where: ServiceRequestWhereUniqueInput
    /**
     * In case the ServiceRequest found by the `where` argument doesn't exist, create a new ServiceRequest with this data.
     */
    create: XOR<ServiceRequestCreateInput, ServiceRequestUncheckedCreateInput>
    /**
     * In case the ServiceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRequestUpdateInput, ServiceRequestUncheckedUpdateInput>
  }

  /**
   * ServiceRequest delete
   */
  export type ServiceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
    /**
     * Filter which ServiceRequest to delete.
     */
    where: ServiceRequestWhereUniqueInput
  }

  /**
   * ServiceRequest deleteMany
   */
  export type ServiceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRequests to delete
     */
    where?: ServiceRequestWhereInput
  }

  /**
   * ServiceRequest.address
   */
  export type ServiceRequest$addressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
  }

  /**
   * ServiceRequest.photos
   */
  export type ServiceRequest$photosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    where?: ServicePhotoWhereInput
    orderBy?: ServicePhotoOrderByWithRelationInput | ServicePhotoOrderByWithRelationInput[]
    cursor?: ServicePhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePhotoScalarFieldEnum | ServicePhotoScalarFieldEnum[]
  }

  /**
   * ServiceRequest.assignments
   */
  export type ServiceRequest$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    cursor?: ServiceAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceRequest.ratings
   */
  export type ServiceRequest$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    cursor?: ServiceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRequest without action
   */
  export type ServiceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRequest
     */
    select?: ServiceRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRequestInclude<ExtArgs> | null
  }


  /**
   * Model ServiceAssignment
   */

  export type AggregateServiceAssignment = {
    _count: ServiceAssignmentCountAggregateOutputType | null
    _avg: ServiceAssignmentAvgAggregateOutputType | null
    _sum: ServiceAssignmentSumAggregateOutputType | null
    _min: ServiceAssignmentMinAggregateOutputType | null
    _max: ServiceAssignmentMaxAggregateOutputType | null
  }

  export type ServiceAssignmentAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    staffId: number | null
    assignedById: number | null
  }

  export type ServiceAssignmentSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    staffId: number | null
    assignedById: number | null
  }

  export type ServiceAssignmentMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    staffId: number | null
    assignedById: number | null
    assignedAt: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.ServiceStatus | null
    notes: string | null
  }

  export type ServiceAssignmentMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    staffId: number | null
    assignedById: number | null
    assignedAt: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.ServiceStatus | null
    notes: string | null
  }

  export type ServiceAssignmentCountAggregateOutputType = {
    id: number
    serviceId: number
    staffId: number
    assignedById: number
    assignedAt: number
    acceptedAt: number
    startedAt: number
    completedAt: number
    status: number
    notes: number
    _all: number
  }


  export type ServiceAssignmentAvgAggregateInputType = {
    id?: true
    serviceId?: true
    staffId?: true
    assignedById?: true
  }

  export type ServiceAssignmentSumAggregateInputType = {
    id?: true
    serviceId?: true
    staffId?: true
    assignedById?: true
  }

  export type ServiceAssignmentMinAggregateInputType = {
    id?: true
    serviceId?: true
    staffId?: true
    assignedById?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type ServiceAssignmentMaxAggregateInputType = {
    id?: true
    serviceId?: true
    staffId?: true
    assignedById?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    notes?: true
  }

  export type ServiceAssignmentCountAggregateInputType = {
    id?: true
    serviceId?: true
    staffId?: true
    assignedById?: true
    assignedAt?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type ServiceAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignment to aggregate.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceAssignments
    **/
    _count?: true | ServiceAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAssignmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceAssignmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceAssignmentMaxAggregateInputType
  }

  export type GetServiceAssignmentAggregateType<T extends ServiceAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceAssignment[P]>
      : GetScalarType<T[P], AggregateServiceAssignment[P]>
  }




  export type ServiceAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceAssignmentWhereInput
    orderBy?: ServiceAssignmentOrderByWithAggregationInput | ServiceAssignmentOrderByWithAggregationInput[]
    by: ServiceAssignmentScalarFieldEnum[] | ServiceAssignmentScalarFieldEnum
    having?: ServiceAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceAssignmentCountAggregateInputType | true
    _avg?: ServiceAssignmentAvgAggregateInputType
    _sum?: ServiceAssignmentSumAggregateInputType
    _min?: ServiceAssignmentMinAggregateInputType
    _max?: ServiceAssignmentMaxAggregateInputType
  }

  export type ServiceAssignmentGroupByOutputType = {
    id: number
    serviceId: number
    staffId: number
    assignedById: number | null
    assignedAt: Date
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.ServiceStatus
    notes: string | null
    _count: ServiceAssignmentCountAggregateOutputType | null
    _avg: ServiceAssignmentAvgAggregateOutputType | null
    _sum: ServiceAssignmentSumAggregateOutputType | null
    _min: ServiceAssignmentMinAggregateOutputType | null
    _max: ServiceAssignmentMaxAggregateOutputType | null
  }

  type GetServiceAssignmentGroupByPayload<T extends ServiceAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ServiceAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    staffId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | ServiceAssignment$assignedByArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignment"]>

  export type ServiceAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    staffId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | ServiceAssignment$assignedByArgs<ExtArgs>
  }, ExtArgs["result"]["serviceAssignment"]>

  export type ServiceAssignmentSelectScalar = {
    id?: boolean
    serviceId?: boolean
    staffId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    notes?: boolean
  }

  export type ServiceAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | ServiceAssignment$assignedByArgs<ExtArgs>
  }
  export type ServiceAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    staff?: boolean | UserDefaultArgs<ExtArgs>
    assignedBy?: boolean | ServiceAssignment$assignedByArgs<ExtArgs>
  }

  export type $ServiceAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceAssignment"
    objects: {
      service: Prisma.$ServiceRequestPayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs>
      assignedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceId: number
      staffId: number
      assignedById: number | null
      assignedAt: Date
      acceptedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      status: $Enums.ServiceStatus
      notes: string | null
    }, ExtArgs["result"]["serviceAssignment"]>
    composites: {}
  }

  type ServiceAssignmentGetPayload<S extends boolean | null | undefined | ServiceAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ServiceAssignmentPayload, S>

  type ServiceAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceAssignmentCountAggregateInputType | true
    }

  export interface ServiceAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceAssignment'], meta: { name: 'ServiceAssignment' } }
    /**
     * Find zero or one ServiceAssignment that matches the filter.
     * @param {ServiceAssignmentFindUniqueArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceAssignmentFindUniqueArgs>(args: SelectSubset<T, ServiceAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindFirstArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceAssignmentFindFirstArgs>(args?: SelectSubset<T, ServiceAssignmentFindFirstArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindFirstOrThrowArgs} args - Arguments to find a ServiceAssignment
     * @example
     * // Get one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceAssignments
     * const serviceAssignments = await prisma.serviceAssignment.findMany()
     * 
     * // Get first 10 ServiceAssignments
     * const serviceAssignments = await prisma.serviceAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceAssignmentWithIdOnly = await prisma.serviceAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceAssignmentFindManyArgs>(args?: SelectSubset<T, ServiceAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceAssignment.
     * @param {ServiceAssignmentCreateArgs} args - Arguments to create a ServiceAssignment.
     * @example
     * // Create one ServiceAssignment
     * const ServiceAssignment = await prisma.serviceAssignment.create({
     *   data: {
     *     // ... data to create a ServiceAssignment
     *   }
     * })
     * 
     */
    create<T extends ServiceAssignmentCreateArgs>(args: SelectSubset<T, ServiceAssignmentCreateArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceAssignments.
     * @param {ServiceAssignmentCreateManyArgs} args - Arguments to create many ServiceAssignments.
     * @example
     * // Create many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceAssignmentCreateManyArgs>(args?: SelectSubset<T, ServiceAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceAssignments and returns the data saved in the database.
     * @param {ServiceAssignmentCreateManyAndReturnArgs} args - Arguments to create many ServiceAssignments.
     * @example
     * // Create many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceAssignments and only return the `id`
     * const serviceAssignmentWithIdOnly = await prisma.serviceAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceAssignment.
     * @param {ServiceAssignmentDeleteArgs} args - Arguments to delete one ServiceAssignment.
     * @example
     * // Delete one ServiceAssignment
     * const ServiceAssignment = await prisma.serviceAssignment.delete({
     *   where: {
     *     // ... filter to delete one ServiceAssignment
     *   }
     * })
     * 
     */
    delete<T extends ServiceAssignmentDeleteArgs>(args: SelectSubset<T, ServiceAssignmentDeleteArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceAssignment.
     * @param {ServiceAssignmentUpdateArgs} args - Arguments to update one ServiceAssignment.
     * @example
     * // Update one ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceAssignmentUpdateArgs>(args: SelectSubset<T, ServiceAssignmentUpdateArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceAssignments.
     * @param {ServiceAssignmentDeleteManyArgs} args - Arguments to filter ServiceAssignments to delete.
     * @example
     * // Delete a few ServiceAssignments
     * const { count } = await prisma.serviceAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceAssignmentDeleteManyArgs>(args?: SelectSubset<T, ServiceAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceAssignments
     * const serviceAssignment = await prisma.serviceAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceAssignmentUpdateManyArgs>(args: SelectSubset<T, ServiceAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceAssignment.
     * @param {ServiceAssignmentUpsertArgs} args - Arguments to update or create a ServiceAssignment.
     * @example
     * // Update or create a ServiceAssignment
     * const serviceAssignment = await prisma.serviceAssignment.upsert({
     *   create: {
     *     // ... data to create a ServiceAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ServiceAssignmentUpsertArgs>(args: SelectSubset<T, ServiceAssignmentUpsertArgs<ExtArgs>>): Prisma__ServiceAssignmentClient<$Result.GetResult<Prisma.$ServiceAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentCountArgs} args - Arguments to filter ServiceAssignments to count.
     * @example
     * // Count the number of ServiceAssignments
     * const count = await prisma.serviceAssignment.count({
     *   where: {
     *     // ... the filter for the ServiceAssignments we want to count
     *   }
     * })
    **/
    count<T extends ServiceAssignmentCountArgs>(
      args?: Subset<T, ServiceAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAssignmentAggregateArgs>(args: Subset<T, ServiceAssignmentAggregateArgs>): Prisma.PrismaPromise<GetServiceAssignmentAggregateType<T>>

    /**
     * Group by ServiceAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ServiceAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceAssignment model
   */
  readonly fields: ServiceAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedBy<T extends ServiceAssignment$assignedByArgs<ExtArgs> = {}>(args?: Subset<T, ServiceAssignment$assignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceAssignment model
   */ 
  interface ServiceAssignmentFieldRefs {
    readonly id: FieldRef<"ServiceAssignment", 'Int'>
    readonly serviceId: FieldRef<"ServiceAssignment", 'Int'>
    readonly staffId: FieldRef<"ServiceAssignment", 'Int'>
    readonly assignedById: FieldRef<"ServiceAssignment", 'Int'>
    readonly assignedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly acceptedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly startedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly completedAt: FieldRef<"ServiceAssignment", 'DateTime'>
    readonly status: FieldRef<"ServiceAssignment", 'ServiceStatus'>
    readonly notes: FieldRef<"ServiceAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceAssignment findUnique
   */
  export type ServiceAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment findUniqueOrThrow
   */
  export type ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment findFirst
   */
  export type ServiceAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignments.
     */
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment findFirstOrThrow
   */
  export type ServiceAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignment to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceAssignments.
     */
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment findMany
   */
  export type ServiceAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ServiceAssignments to fetch.
     */
    where?: ServiceAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceAssignments to fetch.
     */
    orderBy?: ServiceAssignmentOrderByWithRelationInput | ServiceAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceAssignments.
     */
    cursor?: ServiceAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceAssignments.
     */
    skip?: number
    distinct?: ServiceAssignmentScalarFieldEnum | ServiceAssignmentScalarFieldEnum[]
  }

  /**
   * ServiceAssignment create
   */
  export type ServiceAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceAssignment.
     */
    data: XOR<ServiceAssignmentCreateInput, ServiceAssignmentUncheckedCreateInput>
  }

  /**
   * ServiceAssignment createMany
   */
  export type ServiceAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceAssignments.
     */
    data: ServiceAssignmentCreateManyInput | ServiceAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceAssignment createManyAndReturn
   */
  export type ServiceAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceAssignments.
     */
    data: ServiceAssignmentCreateManyInput | ServiceAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceAssignment update
   */
  export type ServiceAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceAssignment.
     */
    data: XOR<ServiceAssignmentUpdateInput, ServiceAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ServiceAssignment to update.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment updateMany
   */
  export type ServiceAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceAssignments.
     */
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ServiceAssignments to update
     */
    where?: ServiceAssignmentWhereInput
  }

  /**
   * ServiceAssignment upsert
   */
  export type ServiceAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceAssignment to update in case it exists.
     */
    where: ServiceAssignmentWhereUniqueInput
    /**
     * In case the ServiceAssignment found by the `where` argument doesn't exist, create a new ServiceAssignment with this data.
     */
    create: XOR<ServiceAssignmentCreateInput, ServiceAssignmentUncheckedCreateInput>
    /**
     * In case the ServiceAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceAssignmentUpdateInput, ServiceAssignmentUncheckedUpdateInput>
  }

  /**
   * ServiceAssignment delete
   */
  export type ServiceAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ServiceAssignment to delete.
     */
    where: ServiceAssignmentWhereUniqueInput
  }

  /**
   * ServiceAssignment deleteMany
   */
  export type ServiceAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceAssignments to delete
     */
    where?: ServiceAssignmentWhereInput
  }

  /**
   * ServiceAssignment.assignedBy
   */
  export type ServiceAssignment$assignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceAssignment without action
   */
  export type ServiceAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceAssignment
     */
    select?: ServiceAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model ServicePhoto
   */

  export type AggregateServicePhoto = {
    _count: ServicePhotoCountAggregateOutputType | null
    _avg: ServicePhotoAvgAggregateOutputType | null
    _sum: ServicePhotoSumAggregateOutputType | null
    _min: ServicePhotoMinAggregateOutputType | null
    _max: ServicePhotoMaxAggregateOutputType | null
  }

  export type ServicePhotoAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
  }

  export type ServicePhotoSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
  }

  export type ServicePhotoMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    url: string | null
    isBefore: boolean | null
    createdAt: Date | null
  }

  export type ServicePhotoMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    url: string | null
    isBefore: boolean | null
    createdAt: Date | null
  }

  export type ServicePhotoCountAggregateOutputType = {
    id: number
    serviceId: number
    url: number
    isBefore: number
    createdAt: number
    _all: number
  }


  export type ServicePhotoAvgAggregateInputType = {
    id?: true
    serviceId?: true
  }

  export type ServicePhotoSumAggregateInputType = {
    id?: true
    serviceId?: true
  }

  export type ServicePhotoMinAggregateInputType = {
    id?: true
    serviceId?: true
    url?: true
    isBefore?: true
    createdAt?: true
  }

  export type ServicePhotoMaxAggregateInputType = {
    id?: true
    serviceId?: true
    url?: true
    isBefore?: true
    createdAt?: true
  }

  export type ServicePhotoCountAggregateInputType = {
    id?: true
    serviceId?: true
    url?: true
    isBefore?: true
    createdAt?: true
    _all?: true
  }

  export type ServicePhotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePhoto to aggregate.
     */
    where?: ServicePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePhotos to fetch.
     */
    orderBy?: ServicePhotoOrderByWithRelationInput | ServicePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePhotos
    **/
    _count?: true | ServicePhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePhotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePhotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePhotoMaxAggregateInputType
  }

  export type GetServicePhotoAggregateType<T extends ServicePhotoAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePhoto[P]>
      : GetScalarType<T[P], AggregateServicePhoto[P]>
  }




  export type ServicePhotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePhotoWhereInput
    orderBy?: ServicePhotoOrderByWithAggregationInput | ServicePhotoOrderByWithAggregationInput[]
    by: ServicePhotoScalarFieldEnum[] | ServicePhotoScalarFieldEnum
    having?: ServicePhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePhotoCountAggregateInputType | true
    _avg?: ServicePhotoAvgAggregateInputType
    _sum?: ServicePhotoSumAggregateInputType
    _min?: ServicePhotoMinAggregateInputType
    _max?: ServicePhotoMaxAggregateInputType
  }

  export type ServicePhotoGroupByOutputType = {
    id: number
    serviceId: number
    url: string
    isBefore: boolean
    createdAt: Date
    _count: ServicePhotoCountAggregateOutputType | null
    _avg: ServicePhotoAvgAggregateOutputType | null
    _sum: ServicePhotoSumAggregateOutputType | null
    _min: ServicePhotoMinAggregateOutputType | null
    _max: ServicePhotoMaxAggregateOutputType | null
  }

  type GetServicePhotoGroupByPayload<T extends ServicePhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePhotoGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePhotoGroupByOutputType[P]>
        }
      >
    >


  export type ServicePhotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    url?: boolean
    isBefore?: boolean
    createdAt?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePhoto"]>

  export type ServicePhotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    url?: boolean
    isBefore?: boolean
    createdAt?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePhoto"]>

  export type ServicePhotoSelectScalar = {
    id?: boolean
    serviceId?: boolean
    url?: boolean
    isBefore?: boolean
    createdAt?: boolean
  }

  export type ServicePhotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }
  export type ServicePhotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
  }

  export type $ServicePhotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePhoto"
    objects: {
      service: Prisma.$ServiceRequestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceId: number
      url: string
      isBefore: boolean
      createdAt: Date
    }, ExtArgs["result"]["servicePhoto"]>
    composites: {}
  }

  type ServicePhotoGetPayload<S extends boolean | null | undefined | ServicePhotoDefaultArgs> = $Result.GetResult<Prisma.$ServicePhotoPayload, S>

  type ServicePhotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServicePhotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServicePhotoCountAggregateInputType | true
    }

  export interface ServicePhotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePhoto'], meta: { name: 'ServicePhoto' } }
    /**
     * Find zero or one ServicePhoto that matches the filter.
     * @param {ServicePhotoFindUniqueArgs} args - Arguments to find a ServicePhoto
     * @example
     * // Get one ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePhotoFindUniqueArgs>(args: SelectSubset<T, ServicePhotoFindUniqueArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServicePhoto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServicePhotoFindUniqueOrThrowArgs} args - Arguments to find a ServicePhoto
     * @example
     * // Get one ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePhotoFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePhotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServicePhoto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoFindFirstArgs} args - Arguments to find a ServicePhoto
     * @example
     * // Get one ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePhotoFindFirstArgs>(args?: SelectSubset<T, ServicePhotoFindFirstArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServicePhoto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoFindFirstOrThrowArgs} args - Arguments to find a ServicePhoto
     * @example
     * // Get one ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePhotoFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePhotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServicePhotos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePhotos
     * const servicePhotos = await prisma.servicePhoto.findMany()
     * 
     * // Get first 10 ServicePhotos
     * const servicePhotos = await prisma.servicePhoto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePhotoWithIdOnly = await prisma.servicePhoto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePhotoFindManyArgs>(args?: SelectSubset<T, ServicePhotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServicePhoto.
     * @param {ServicePhotoCreateArgs} args - Arguments to create a ServicePhoto.
     * @example
     * // Create one ServicePhoto
     * const ServicePhoto = await prisma.servicePhoto.create({
     *   data: {
     *     // ... data to create a ServicePhoto
     *   }
     * })
     * 
     */
    create<T extends ServicePhotoCreateArgs>(args: SelectSubset<T, ServicePhotoCreateArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServicePhotos.
     * @param {ServicePhotoCreateManyArgs} args - Arguments to create many ServicePhotos.
     * @example
     * // Create many ServicePhotos
     * const servicePhoto = await prisma.servicePhoto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePhotoCreateManyArgs>(args?: SelectSubset<T, ServicePhotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePhotos and returns the data saved in the database.
     * @param {ServicePhotoCreateManyAndReturnArgs} args - Arguments to create many ServicePhotos.
     * @example
     * // Create many ServicePhotos
     * const servicePhoto = await prisma.servicePhoto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePhotos and only return the `id`
     * const servicePhotoWithIdOnly = await prisma.servicePhoto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePhotoCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePhotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServicePhoto.
     * @param {ServicePhotoDeleteArgs} args - Arguments to delete one ServicePhoto.
     * @example
     * // Delete one ServicePhoto
     * const ServicePhoto = await prisma.servicePhoto.delete({
     *   where: {
     *     // ... filter to delete one ServicePhoto
     *   }
     * })
     * 
     */
    delete<T extends ServicePhotoDeleteArgs>(args: SelectSubset<T, ServicePhotoDeleteArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServicePhoto.
     * @param {ServicePhotoUpdateArgs} args - Arguments to update one ServicePhoto.
     * @example
     * // Update one ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePhotoUpdateArgs>(args: SelectSubset<T, ServicePhotoUpdateArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServicePhotos.
     * @param {ServicePhotoDeleteManyArgs} args - Arguments to filter ServicePhotos to delete.
     * @example
     * // Delete a few ServicePhotos
     * const { count } = await prisma.servicePhoto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePhotoDeleteManyArgs>(args?: SelectSubset<T, ServicePhotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePhotos
     * const servicePhoto = await prisma.servicePhoto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePhotoUpdateManyArgs>(args: SelectSubset<T, ServicePhotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePhoto.
     * @param {ServicePhotoUpsertArgs} args - Arguments to update or create a ServicePhoto.
     * @example
     * // Update or create a ServicePhoto
     * const servicePhoto = await prisma.servicePhoto.upsert({
     *   create: {
     *     // ... data to create a ServicePhoto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePhoto we want to update
     *   }
     * })
     */
    upsert<T extends ServicePhotoUpsertArgs>(args: SelectSubset<T, ServicePhotoUpsertArgs<ExtArgs>>): Prisma__ServicePhotoClient<$Result.GetResult<Prisma.$ServicePhotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServicePhotos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoCountArgs} args - Arguments to filter ServicePhotos to count.
     * @example
     * // Count the number of ServicePhotos
     * const count = await prisma.servicePhoto.count({
     *   where: {
     *     // ... the filter for the ServicePhotos we want to count
     *   }
     * })
    **/
    count<T extends ServicePhotoCountArgs>(
      args?: Subset<T, ServicePhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePhotoAggregateArgs>(args: Subset<T, ServicePhotoAggregateArgs>): Prisma.PrismaPromise<GetServicePhotoAggregateType<T>>

    /**
     * Group by ServicePhoto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePhotoGroupByArgs['orderBy'] }
        : { orderBy?: ServicePhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePhoto model
   */
  readonly fields: ServicePhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePhoto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePhotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePhoto model
   */ 
  interface ServicePhotoFieldRefs {
    readonly id: FieldRef<"ServicePhoto", 'Int'>
    readonly serviceId: FieldRef<"ServicePhoto", 'Int'>
    readonly url: FieldRef<"ServicePhoto", 'String'>
    readonly isBefore: FieldRef<"ServicePhoto", 'Boolean'>
    readonly createdAt: FieldRef<"ServicePhoto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePhoto findUnique
   */
  export type ServicePhotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter, which ServicePhoto to fetch.
     */
    where: ServicePhotoWhereUniqueInput
  }

  /**
   * ServicePhoto findUniqueOrThrow
   */
  export type ServicePhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter, which ServicePhoto to fetch.
     */
    where: ServicePhotoWhereUniqueInput
  }

  /**
   * ServicePhoto findFirst
   */
  export type ServicePhotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter, which ServicePhoto to fetch.
     */
    where?: ServicePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePhotos to fetch.
     */
    orderBy?: ServicePhotoOrderByWithRelationInput | ServicePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePhotos.
     */
    cursor?: ServicePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePhotos.
     */
    distinct?: ServicePhotoScalarFieldEnum | ServicePhotoScalarFieldEnum[]
  }

  /**
   * ServicePhoto findFirstOrThrow
   */
  export type ServicePhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter, which ServicePhoto to fetch.
     */
    where?: ServicePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePhotos to fetch.
     */
    orderBy?: ServicePhotoOrderByWithRelationInput | ServicePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePhotos.
     */
    cursor?: ServicePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePhotos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePhotos.
     */
    distinct?: ServicePhotoScalarFieldEnum | ServicePhotoScalarFieldEnum[]
  }

  /**
   * ServicePhoto findMany
   */
  export type ServicePhotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter, which ServicePhotos to fetch.
     */
    where?: ServicePhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePhotos to fetch.
     */
    orderBy?: ServicePhotoOrderByWithRelationInput | ServicePhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePhotos.
     */
    cursor?: ServicePhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePhotos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePhotos.
     */
    skip?: number
    distinct?: ServicePhotoScalarFieldEnum | ServicePhotoScalarFieldEnum[]
  }

  /**
   * ServicePhoto create
   */
  export type ServicePhotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePhoto.
     */
    data: XOR<ServicePhotoCreateInput, ServicePhotoUncheckedCreateInput>
  }

  /**
   * ServicePhoto createMany
   */
  export type ServicePhotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePhotos.
     */
    data: ServicePhotoCreateManyInput | ServicePhotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePhoto createManyAndReturn
   */
  export type ServicePhotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServicePhotos.
     */
    data: ServicePhotoCreateManyInput | ServicePhotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePhoto update
   */
  export type ServicePhotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePhoto.
     */
    data: XOR<ServicePhotoUpdateInput, ServicePhotoUncheckedUpdateInput>
    /**
     * Choose, which ServicePhoto to update.
     */
    where: ServicePhotoWhereUniqueInput
  }

  /**
   * ServicePhoto updateMany
   */
  export type ServicePhotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePhotos.
     */
    data: XOR<ServicePhotoUpdateManyMutationInput, ServicePhotoUncheckedUpdateManyInput>
    /**
     * Filter which ServicePhotos to update
     */
    where?: ServicePhotoWhereInput
  }

  /**
   * ServicePhoto upsert
   */
  export type ServicePhotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePhoto to update in case it exists.
     */
    where: ServicePhotoWhereUniqueInput
    /**
     * In case the ServicePhoto found by the `where` argument doesn't exist, create a new ServicePhoto with this data.
     */
    create: XOR<ServicePhotoCreateInput, ServicePhotoUncheckedCreateInput>
    /**
     * In case the ServicePhoto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePhotoUpdateInput, ServicePhotoUncheckedUpdateInput>
  }

  /**
   * ServicePhoto delete
   */
  export type ServicePhotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
    /**
     * Filter which ServicePhoto to delete.
     */
    where: ServicePhotoWhereUniqueInput
  }

  /**
   * ServicePhoto deleteMany
   */
  export type ServicePhotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePhotos to delete
     */
    where?: ServicePhotoWhereInput
  }

  /**
   * ServicePhoto without action
   */
  export type ServicePhotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePhoto
     */
    select?: ServicePhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePhotoInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRating
   */

  export type AggregateServiceRating = {
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  export type ServiceRatingAvgAggregateOutputType = {
    id: number | null
    serviceId: number | null
    customerId: number | null
    staffId: number | null
    score: number | null
  }

  export type ServiceRatingSumAggregateOutputType = {
    id: number | null
    serviceId: number | null
    customerId: number | null
    staffId: number | null
    score: number | null
  }

  export type ServiceRatingMinAggregateOutputType = {
    id: number | null
    serviceId: number | null
    customerId: number | null
    staffId: number | null
    score: number | null
    review: string | null
    wouldRecommend: boolean | null
    createdAt: Date | null
  }

  export type ServiceRatingMaxAggregateOutputType = {
    id: number | null
    serviceId: number | null
    customerId: number | null
    staffId: number | null
    score: number | null
    review: string | null
    wouldRecommend: boolean | null
    createdAt: Date | null
  }

  export type ServiceRatingCountAggregateOutputType = {
    id: number
    serviceId: number
    customerId: number
    staffId: number
    score: number
    review: number
    wouldRecommend: number
    createdAt: number
    _all: number
  }


  export type ServiceRatingAvgAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    staffId?: true
    score?: true
  }

  export type ServiceRatingSumAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    staffId?: true
    score?: true
  }

  export type ServiceRatingMinAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    staffId?: true
    score?: true
    review?: true
    wouldRecommend?: true
    createdAt?: true
  }

  export type ServiceRatingMaxAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    staffId?: true
    score?: true
    review?: true
    wouldRecommend?: true
    createdAt?: true
  }

  export type ServiceRatingCountAggregateInputType = {
    id?: true
    serviceId?: true
    customerId?: true
    staffId?: true
    score?: true
    review?: true
    wouldRecommend?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRating to aggregate.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRatings
    **/
    _count?: true | ServiceRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type GetServiceRatingAggregateType<T extends ServiceRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRating[P]>
      : GetScalarType<T[P], AggregateServiceRating[P]>
  }




  export type ServiceRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithAggregationInput | ServiceRatingOrderByWithAggregationInput[]
    by: ServiceRatingScalarFieldEnum[] | ServiceRatingScalarFieldEnum
    having?: ServiceRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRatingCountAggregateInputType | true
    _avg?: ServiceRatingAvgAggregateInputType
    _sum?: ServiceRatingSumAggregateInputType
    _min?: ServiceRatingMinAggregateInputType
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type ServiceRatingGroupByOutputType = {
    id: number
    serviceId: number
    customerId: number
    staffId: number | null
    score: number
    review: string | null
    wouldRecommend: boolean
    createdAt: Date
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  type GetServiceRatingGroupByPayload<T extends ServiceRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    staffId?: boolean
    score?: boolean
    review?: boolean
    wouldRecommend?: boolean
    createdAt?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    staff?: boolean | ServiceRating$staffArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>

  export type ServiceRatingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    staffId?: boolean
    score?: boolean
    review?: boolean
    wouldRecommend?: boolean
    createdAt?: boolean
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    staff?: boolean | ServiceRating$staffArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>

  export type ServiceRatingSelectScalar = {
    id?: boolean
    serviceId?: boolean
    customerId?: boolean
    staffId?: boolean
    score?: boolean
    review?: boolean
    wouldRecommend?: boolean
    createdAt?: boolean
  }

  export type ServiceRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    staff?: boolean | ServiceRating$staffArgs<ExtArgs>
  }
  export type ServiceRatingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRequestDefaultArgs<ExtArgs>
    customer?: boolean | UserDefaultArgs<ExtArgs>
    staff?: boolean | ServiceRating$staffArgs<ExtArgs>
  }

  export type $ServiceRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRating"
    objects: {
      service: Prisma.$ServiceRequestPayload<ExtArgs>
      customer: Prisma.$UserPayload<ExtArgs>
      staff: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceId: number
      customerId: number
      staffId: number | null
      score: number
      review: string | null
      wouldRecommend: boolean
      createdAt: Date
    }, ExtArgs["result"]["serviceRating"]>
    composites: {}
  }

  type ServiceRatingGetPayload<S extends boolean | null | undefined | ServiceRatingDefaultArgs> = $Result.GetResult<Prisma.$ServiceRatingPayload, S>

  type ServiceRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceRatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ServiceRatingCountAggregateInputType | true
    }

  export interface ServiceRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRating'], meta: { name: 'ServiceRating' } }
    /**
     * Find zero or one ServiceRating that matches the filter.
     * @param {ServiceRatingFindUniqueArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRatingFindUniqueArgs>(args: SelectSubset<T, ServiceRatingFindUniqueArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ServiceRating that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ServiceRatingFindUniqueOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ServiceRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindFirstArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRatingFindFirstArgs>(args?: SelectSubset<T, ServiceRatingFindFirstArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ServiceRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindFirstOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ServiceRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany()
     * 
     * // Get first 10 ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRatingWithIdOnly = await prisma.serviceRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRatingFindManyArgs>(args?: SelectSubset<T, ServiceRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ServiceRating.
     * @param {ServiceRatingCreateArgs} args - Arguments to create a ServiceRating.
     * @example
     * // Create one ServiceRating
     * const ServiceRating = await prisma.serviceRating.create({
     *   data: {
     *     // ... data to create a ServiceRating
     *   }
     * })
     * 
     */
    create<T extends ServiceRatingCreateArgs>(args: SelectSubset<T, ServiceRatingCreateArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ServiceRatings.
     * @param {ServiceRatingCreateManyArgs} args - Arguments to create many ServiceRatings.
     * @example
     * // Create many ServiceRatings
     * const serviceRating = await prisma.serviceRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRatingCreateManyArgs>(args?: SelectSubset<T, ServiceRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceRatings and returns the data saved in the database.
     * @param {ServiceRatingCreateManyAndReturnArgs} args - Arguments to create many ServiceRatings.
     * @example
     * // Create many ServiceRatings
     * const serviceRating = await prisma.serviceRating.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceRatings and only return the `id`
     * const serviceRatingWithIdOnly = await prisma.serviceRating.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceRatingCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceRatingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ServiceRating.
     * @param {ServiceRatingDeleteArgs} args - Arguments to delete one ServiceRating.
     * @example
     * // Delete one ServiceRating
     * const ServiceRating = await prisma.serviceRating.delete({
     *   where: {
     *     // ... filter to delete one ServiceRating
     *   }
     * })
     * 
     */
    delete<T extends ServiceRatingDeleteArgs>(args: SelectSubset<T, ServiceRatingDeleteArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ServiceRating.
     * @param {ServiceRatingUpdateArgs} args - Arguments to update one ServiceRating.
     * @example
     * // Update one ServiceRating
     * const serviceRating = await prisma.serviceRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRatingUpdateArgs>(args: SelectSubset<T, ServiceRatingUpdateArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ServiceRatings.
     * @param {ServiceRatingDeleteManyArgs} args - Arguments to filter ServiceRatings to delete.
     * @example
     * // Delete a few ServiceRatings
     * const { count } = await prisma.serviceRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRatingDeleteManyArgs>(args?: SelectSubset<T, ServiceRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRatings
     * const serviceRating = await prisma.serviceRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRatingUpdateManyArgs>(args: SelectSubset<T, ServiceRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceRating.
     * @param {ServiceRatingUpsertArgs} args - Arguments to update or create a ServiceRating.
     * @example
     * // Update or create a ServiceRating
     * const serviceRating = await prisma.serviceRating.upsert({
     *   create: {
     *     // ... data to create a ServiceRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRating we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRatingUpsertArgs>(args: SelectSubset<T, ServiceRatingUpsertArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingCountArgs} args - Arguments to filter ServiceRatings to count.
     * @example
     * // Count the number of ServiceRatings
     * const count = await prisma.serviceRating.count({
     *   where: {
     *     // ... the filter for the ServiceRatings we want to count
     *   }
     * })
    **/
    count<T extends ServiceRatingCountArgs>(
      args?: Subset<T, ServiceRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRatingAggregateArgs>(args: Subset<T, ServiceRatingAggregateArgs>): Prisma.PrismaPromise<GetServiceRatingAggregateType<T>>

    /**
     * Group by ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRatingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRating model
   */
  readonly fields: ServiceRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRequestDefaultArgs<ExtArgs>>): Prisma__ServiceRequestClient<$Result.GetResult<Prisma.$ServiceRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    staff<T extends ServiceRating$staffArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRating$staffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRating model
   */ 
  interface ServiceRatingFieldRefs {
    readonly id: FieldRef<"ServiceRating", 'Int'>
    readonly serviceId: FieldRef<"ServiceRating", 'Int'>
    readonly customerId: FieldRef<"ServiceRating", 'Int'>
    readonly staffId: FieldRef<"ServiceRating", 'Int'>
    readonly score: FieldRef<"ServiceRating", 'Int'>
    readonly review: FieldRef<"ServiceRating", 'String'>
    readonly wouldRecommend: FieldRef<"ServiceRating", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceRating", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRating findUnique
   */
  export type ServiceRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating findUniqueOrThrow
   */
  export type ServiceRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating findFirst
   */
  export type ServiceRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating findFirstOrThrow
   */
  export type ServiceRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating findMany
   */
  export type ServiceRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRatings to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating create
   */
  export type ServiceRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRating.
     */
    data: XOR<ServiceRatingCreateInput, ServiceRatingUncheckedCreateInput>
  }

  /**
   * ServiceRating createMany
   */
  export type ServiceRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRatings.
     */
    data: ServiceRatingCreateManyInput | ServiceRatingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceRating createManyAndReturn
   */
  export type ServiceRatingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ServiceRatings.
     */
    data: ServiceRatingCreateManyInput | ServiceRatingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceRating update
   */
  export type ServiceRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRating.
     */
    data: XOR<ServiceRatingUpdateInput, ServiceRatingUncheckedUpdateInput>
    /**
     * Choose, which ServiceRating to update.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating updateMany
   */
  export type ServiceRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRatings.
     */
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRatings to update
     */
    where?: ServiceRatingWhereInput
  }

  /**
   * ServiceRating upsert
   */
  export type ServiceRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRating to update in case it exists.
     */
    where: ServiceRatingWhereUniqueInput
    /**
     * In case the ServiceRating found by the `where` argument doesn't exist, create a new ServiceRating with this data.
     */
    create: XOR<ServiceRatingCreateInput, ServiceRatingUncheckedCreateInput>
    /**
     * In case the ServiceRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRatingUpdateInput, ServiceRatingUncheckedUpdateInput>
  }

  /**
   * ServiceRating delete
   */
  export type ServiceRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter which ServiceRating to delete.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating deleteMany
   */
  export type ServiceRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRatings to delete
     */
    where?: ServiceRatingWhereInput
  }

  /**
   * ServiceRating.staff
   */
  export type ServiceRating$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ServiceRating without action
   */
  export type ServiceRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    entityId: number | null
    actorId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    entityId: number | null
    actorId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    entityType: $Enums.AuditEntityType | null
    entityId: number | null
    action: $Enums.AuditAction | null
    actorId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    entityType: $Enums.AuditEntityType | null
    entityId: number | null
    action: $Enums.AuditAction | null
    actorId: number | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    entityType: number
    entityId: number
    action: number
    actorId: number
    ipAddress: number
    userAgent: number
    details: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    entityId?: true
    actorId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    entityId?: true
    actorId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    entityType?: true
    entityId?: true
    action?: true
    actorId?: true
    ipAddress?: true
    userAgent?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    actorId: number | null
    ipAddress: string | null
    userAgent: string | null
    details: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    entityType?: boolean
    entityId?: boolean
    action?: boolean
    actorId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditLog$actorArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entityType: $Enums.AuditEntityType
      entityId: number
      action: $Enums.AuditAction
      actorId: number | null
      ipAddress: string | null
      userAgent: string | null
      details: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditLog$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly entityType: FieldRef<"AuditLog", 'AuditEntityType'>
    readonly entityId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'AuditAction'>
    readonly actorId: FieldRef<"AuditLog", 'Int'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.actor
   */
  export type AuditLog$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    phone: 'phone',
    role: 'role',
    status: 'status',
    emailVerified: 'emailVerified',
    profileImage: 'profileImage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    label: 'label',
    line1: 'line1',
    line2: 'line2',
    city: 'city',
    postalCode: 'postalCode',
    country: 'country',
    isDefault: 'isDefault',
    createdAt: 'createdAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const ContactMessageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    subject: 'subject',
    message: 'message',
    userId: 'userId',
    handledById: 'handledById',
    handledAt: 'handledAt',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type ContactMessageScalarFieldEnum = (typeof ContactMessageScalarFieldEnum)[keyof typeof ContactMessageScalarFieldEnum]


  export const FoodCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodCategoryScalarFieldEnum = (typeof FoodCategoryScalarFieldEnum)[keyof typeof FoodCategoryScalarFieldEnum]


  export const FoodItemScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    price: 'price',
    sku: 'sku',
    stock: 'stock',
    isActive: 'isActive',
    categoryId: 'categoryId',
    mainImageUrl: 'mainImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FoodItemScalarFieldEnum = (typeof FoodItemScalarFieldEnum)[keyof typeof FoodItemScalarFieldEnum]


  export const FoodImageScalarFieldEnum: {
    id: 'id',
    foodItemId: 'foodItemId',
    url: 'url',
    position: 'position',
    createdAt: 'createdAt'
  };

  export type FoodImageScalarFieldEnum = (typeof FoodImageScalarFieldEnum)[keyof typeof FoodImageScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    orderNumber: 'orderNumber',
    customerId: 'customerId',
    deliveryAddressId: 'deliveryAddressId',
    status: 'status',
    notes: 'notes',
    imageUrl: 'imageUrl',
    totalPrice: 'totalPrice',
    salesmanId: 'salesmanId',
    driverId: 'driverId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    foodItemId: 'foodItemId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    createdAt: 'createdAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderStatusHistoryScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    from: 'from',
    to: 'to',
    changedAt: 'changedAt',
    changedById: 'changedById',
    note: 'note'
  };

  export type OrderStatusHistoryScalarFieldEnum = (typeof OrderStatusHistoryScalarFieldEnum)[keyof typeof OrderStatusHistoryScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    amount: 'amount',
    currency: 'currency',
    provider: 'provider',
    status: 'status',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DeliveryProofScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    photoUrl: 'photoUrl',
    note: 'note',
    deliveredAt: 'deliveredAt',
    driverId: 'driverId'
  };

  export type DeliveryProofScalarFieldEnum = (typeof DeliveryProofScalarFieldEnum)[keyof typeof DeliveryProofScalarFieldEnum]


  export const ServiceRequestScalarFieldEnum: {
    id: 'id',
    requestNumber: 'requestNumber',
    customerId: 'customerId',
    type: 'type',
    status: 'status',
    priority: 'priority',
    title: 'title',
    description: 'description',
    addressId: 'addressId',
    requestedDate: 'requestedDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceRequestScalarFieldEnum = (typeof ServiceRequestScalarFieldEnum)[keyof typeof ServiceRequestScalarFieldEnum]


  export const ServiceAssignmentScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    staffId: 'staffId',
    assignedById: 'assignedById',
    assignedAt: 'assignedAt',
    acceptedAt: 'acceptedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    notes: 'notes'
  };

  export type ServiceAssignmentScalarFieldEnum = (typeof ServiceAssignmentScalarFieldEnum)[keyof typeof ServiceAssignmentScalarFieldEnum]


  export const ServicePhotoScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    url: 'url',
    isBefore: 'isBefore',
    createdAt: 'createdAt'
  };

  export type ServicePhotoScalarFieldEnum = (typeof ServicePhotoScalarFieldEnum)[keyof typeof ServicePhotoScalarFieldEnum]


  export const ServiceRatingScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    customerId: 'customerId',
    staffId: 'staffId',
    score: 'score',
    review: 'review',
    wouldRecommend: 'wouldRecommend',
    createdAt: 'createdAt'
  };

  export type ServiceRatingScalarFieldEnum = (typeof ServiceRatingScalarFieldEnum)[keyof typeof ServiceRatingScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    entityId: 'entityId',
    action: 'action',
    actorId: 'actorId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'ServiceStatus'
   */
  export type EnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus'>
    


  /**
   * Reference to a field of type 'ServiceStatus[]'
   */
  export type ListEnumServiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceStatus[]'>
    


  /**
   * Reference to a field of type 'ServicePriority'
   */
  export type EnumServicePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServicePriority'>
    


  /**
   * Reference to a field of type 'ServicePriority[]'
   */
  export type ListEnumServicePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServicePriority[]'>
    


  /**
   * Reference to a field of type 'AuditEntityType'
   */
  export type EnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType'>
    


  /**
   * Reference to a field of type 'AuditEntityType[]'
   */
  export type ListEnumAuditEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditEntityType[]'>
    


  /**
   * Reference to a field of type 'AuditAction'
   */
  export type EnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction'>
    


  /**
   * Reference to a field of type 'AuditAction[]'
   */
  export type ListEnumAuditActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    addresses?: AddressListRelationFilter
    orders?: OrderListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    salesmanOrders?: OrderListRelationFilter
    driverOrders?: OrderListRelationFilter
    staffServices?: ServiceAssignmentListRelationFilter
    contactMessages?: ContactMessageListRelationFilter
    handledMessages?: ContactMessageListRelationFilter
    ratings?: ServiceRatingListRelationFilter
    ratedServices?: ServiceRatingListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    orderStatusChanges?: OrderStatusHistoryListRelationFilter
    deliveryProofs?: DeliveryProofListRelationFilter
    serviceAssignments?: ServiceAssignmentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    addresses?: AddressOrderByRelationAggregateInput
    orders?: OrderOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
    salesmanOrders?: OrderOrderByRelationAggregateInput
    driverOrders?: OrderOrderByRelationAggregateInput
    staffServices?: ServiceAssignmentOrderByRelationAggregateInput
    contactMessages?: ContactMessageOrderByRelationAggregateInput
    handledMessages?: ContactMessageOrderByRelationAggregateInput
    ratings?: ServiceRatingOrderByRelationAggregateInput
    ratedServices?: ServiceRatingOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    orderStatusChanges?: OrderStatusHistoryOrderByRelationAggregateInput
    deliveryProofs?: DeliveryProofOrderByRelationAggregateInput
    serviceAssignments?: ServiceAssignmentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    profileImage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    addresses?: AddressListRelationFilter
    orders?: OrderListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
    salesmanOrders?: OrderListRelationFilter
    driverOrders?: OrderListRelationFilter
    staffServices?: ServiceAssignmentListRelationFilter
    contactMessages?: ContactMessageListRelationFilter
    handledMessages?: ContactMessageListRelationFilter
    ratings?: ServiceRatingListRelationFilter
    ratedServices?: ServiceRatingListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    orderStatusChanges?: OrderStatusHistoryListRelationFilter
    deliveryProofs?: DeliveryProofListRelationFilter
    serviceAssignments?: ServiceAssignmentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: IntFilter<"Session"> | number
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    userId?: IntWithAggregatesFilter<"Session"> | number
    token?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntFilter<"Address"> | number
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrderInput | SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    serviceRequests?: ServiceRequestOrderByRelationAggregateInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    userId?: IntFilter<"Address"> | number
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    orders?: OrderListRelationFilter
    serviceRequests?: ServiceRequestListRelationFilter
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrderInput | SortOrder
    line1?: SortOrder
    line2?: SortOrderInput | SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _avg?: AddressAvgOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
    _sum?: AddressSumOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Address"> | number
    userId?: IntWithAggregatesFilter<"Address"> | number
    label?: StringNullableWithAggregatesFilter<"Address"> | string | null
    line1?: StringWithAggregatesFilter<"Address"> | string
    line2?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringWithAggregatesFilter<"Address"> | string
    postalCode?: StringWithAggregatesFilter<"Address"> | string
    country?: StringWithAggregatesFilter<"Address"> | string
    isDefault?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type ContactMessageWhereInput = {
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    id?: IntFilter<"ContactMessage"> | number
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    phone?: StringNullableFilter<"ContactMessage"> | string | null
    subject?: StringFilter<"ContactMessage"> | string
    message?: StringFilter<"ContactMessage"> | string
    userId?: IntNullableFilter<"ContactMessage"> | number | null
    handledById?: IntNullableFilter<"ContactMessage"> | number | null
    handledAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    status?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    handledBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ContactMessageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    userId?: SortOrderInput | SortOrder
    handledById?: SortOrderInput | SortOrder
    handledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    handledBy?: UserOrderByWithRelationInput
  }

  export type ContactMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactMessageWhereInput | ContactMessageWhereInput[]
    OR?: ContactMessageWhereInput[]
    NOT?: ContactMessageWhereInput | ContactMessageWhereInput[]
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    phone?: StringNullableFilter<"ContactMessage"> | string | null
    subject?: StringFilter<"ContactMessage"> | string
    message?: StringFilter<"ContactMessage"> | string
    userId?: IntNullableFilter<"ContactMessage"> | number | null
    handledById?: IntNullableFilter<"ContactMessage"> | number | null
    handledAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    status?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    handledBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ContactMessageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    subject?: SortOrder
    message?: SortOrder
    userId?: SortOrderInput | SortOrder
    handledById?: SortOrderInput | SortOrder
    handledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: ContactMessageCountOrderByAggregateInput
    _avg?: ContactMessageAvgOrderByAggregateInput
    _max?: ContactMessageMaxOrderByAggregateInput
    _min?: ContactMessageMinOrderByAggregateInput
    _sum?: ContactMessageSumOrderByAggregateInput
  }

  export type ContactMessageScalarWhereWithAggregatesInput = {
    AND?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    OR?: ContactMessageScalarWhereWithAggregatesInput[]
    NOT?: ContactMessageScalarWhereWithAggregatesInput | ContactMessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactMessage"> | number
    name?: StringWithAggregatesFilter<"ContactMessage"> | string
    email?: StringWithAggregatesFilter<"ContactMessage"> | string
    phone?: StringNullableWithAggregatesFilter<"ContactMessage"> | string | null
    subject?: StringWithAggregatesFilter<"ContactMessage"> | string
    message?: StringWithAggregatesFilter<"ContactMessage"> | string
    userId?: IntNullableWithAggregatesFilter<"ContactMessage"> | number | null
    handledById?: IntNullableWithAggregatesFilter<"ContactMessage"> | number | null
    handledAt?: DateTimeNullableWithAggregatesFilter<"ContactMessage"> | Date | string | null
    status?: StringWithAggregatesFilter<"ContactMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContactMessage"> | Date | string
  }

  export type FoodCategoryWhereInput = {
    AND?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    OR?: FoodCategoryWhereInput[]
    NOT?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    id?: IntFilter<"FoodCategory"> | number
    name?: StringFilter<"FoodCategory"> | string
    slug?: StringFilter<"FoodCategory"> | string
    description?: StringNullableFilter<"FoodCategory"> | string | null
    imageUrl?: StringNullableFilter<"FoodCategory"> | string | null
    createdAt?: DateTimeFilter<"FoodCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FoodCategory"> | Date | string
    items?: FoodItemListRelationFilter
  }

  export type FoodCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    items?: FoodItemOrderByRelationAggregateInput
  }

  export type FoodCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    OR?: FoodCategoryWhereInput[]
    NOT?: FoodCategoryWhereInput | FoodCategoryWhereInput[]
    name?: StringFilter<"FoodCategory"> | string
    description?: StringNullableFilter<"FoodCategory"> | string | null
    imageUrl?: StringNullableFilter<"FoodCategory"> | string | null
    createdAt?: DateTimeFilter<"FoodCategory"> | Date | string
    updatedAt?: DateTimeFilter<"FoodCategory"> | Date | string
    items?: FoodItemListRelationFilter
  }, "id" | "slug">

  export type FoodCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodCategoryCountOrderByAggregateInput
    _avg?: FoodCategoryAvgOrderByAggregateInput
    _max?: FoodCategoryMaxOrderByAggregateInput
    _min?: FoodCategoryMinOrderByAggregateInput
    _sum?: FoodCategorySumOrderByAggregateInput
  }

  export type FoodCategoryScalarWhereWithAggregatesInput = {
    AND?: FoodCategoryScalarWhereWithAggregatesInput | FoodCategoryScalarWhereWithAggregatesInput[]
    OR?: FoodCategoryScalarWhereWithAggregatesInput[]
    NOT?: FoodCategoryScalarWhereWithAggregatesInput | FoodCategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodCategory"> | number
    name?: StringWithAggregatesFilter<"FoodCategory"> | string
    slug?: StringWithAggregatesFilter<"FoodCategory"> | string
    description?: StringNullableWithAggregatesFilter<"FoodCategory"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"FoodCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodCategory"> | Date | string
  }

  export type FoodItemWhereInput = {
    AND?: FoodItemWhereInput | FoodItemWhereInput[]
    OR?: FoodItemWhereInput[]
    NOT?: FoodItemWhereInput | FoodItemWhereInput[]
    id?: IntFilter<"FoodItem"> | number
    name?: StringFilter<"FoodItem"> | string
    slug?: StringFilter<"FoodItem"> | string
    description?: StringNullableFilter<"FoodItem"> | string | null
    price?: DecimalFilter<"FoodItem"> | Decimal | DecimalJsLike | number | string
    sku?: StringNullableFilter<"FoodItem"> | string | null
    stock?: IntFilter<"FoodItem"> | number
    isActive?: BoolFilter<"FoodItem"> | boolean
    categoryId?: IntFilter<"FoodItem"> | number
    mainImageUrl?: StringNullableFilter<"FoodItem"> | string | null
    createdAt?: DateTimeFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeFilter<"FoodItem"> | Date | string
    category?: XOR<FoodCategoryRelationFilter, FoodCategoryWhereInput>
    images?: FoodImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type FoodItemOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: FoodCategoryOrderByWithRelationInput
    images?: FoodImageOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type FoodItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    sku?: string
    AND?: FoodItemWhereInput | FoodItemWhereInput[]
    OR?: FoodItemWhereInput[]
    NOT?: FoodItemWhereInput | FoodItemWhereInput[]
    name?: StringFilter<"FoodItem"> | string
    description?: StringNullableFilter<"FoodItem"> | string | null
    price?: DecimalFilter<"FoodItem"> | Decimal | DecimalJsLike | number | string
    stock?: IntFilter<"FoodItem"> | number
    isActive?: BoolFilter<"FoodItem"> | boolean
    categoryId?: IntFilter<"FoodItem"> | number
    mainImageUrl?: StringNullableFilter<"FoodItem"> | string | null
    createdAt?: DateTimeFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeFilter<"FoodItem"> | Date | string
    category?: XOR<FoodCategoryRelationFilter, FoodCategoryWhereInput>
    images?: FoodImageListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id" | "slug" | "sku">

  export type FoodItemOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    sku?: SortOrderInput | SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    mainImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FoodItemCountOrderByAggregateInput
    _avg?: FoodItemAvgOrderByAggregateInput
    _max?: FoodItemMaxOrderByAggregateInput
    _min?: FoodItemMinOrderByAggregateInput
    _sum?: FoodItemSumOrderByAggregateInput
  }

  export type FoodItemScalarWhereWithAggregatesInput = {
    AND?: FoodItemScalarWhereWithAggregatesInput | FoodItemScalarWhereWithAggregatesInput[]
    OR?: FoodItemScalarWhereWithAggregatesInput[]
    NOT?: FoodItemScalarWhereWithAggregatesInput | FoodItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodItem"> | number
    name?: StringWithAggregatesFilter<"FoodItem"> | string
    slug?: StringWithAggregatesFilter<"FoodItem"> | string
    description?: StringNullableWithAggregatesFilter<"FoodItem"> | string | null
    price?: DecimalWithAggregatesFilter<"FoodItem"> | Decimal | DecimalJsLike | number | string
    sku?: StringNullableWithAggregatesFilter<"FoodItem"> | string | null
    stock?: IntWithAggregatesFilter<"FoodItem"> | number
    isActive?: BoolWithAggregatesFilter<"FoodItem"> | boolean
    categoryId?: IntWithAggregatesFilter<"FoodItem"> | number
    mainImageUrl?: StringNullableWithAggregatesFilter<"FoodItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FoodItem"> | Date | string
  }

  export type FoodImageWhereInput = {
    AND?: FoodImageWhereInput | FoodImageWhereInput[]
    OR?: FoodImageWhereInput[]
    NOT?: FoodImageWhereInput | FoodImageWhereInput[]
    id?: IntFilter<"FoodImage"> | number
    foodItemId?: IntFilter<"FoodImage"> | number
    url?: StringFilter<"FoodImage"> | string
    position?: IntFilter<"FoodImage"> | number
    createdAt?: DateTimeFilter<"FoodImage"> | Date | string
    foodItem?: XOR<FoodItemRelationFilter, FoodItemWhereInput>
  }

  export type FoodImageOrderByWithRelationInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    foodItem?: FoodItemOrderByWithRelationInput
  }

  export type FoodImageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FoodImageWhereInput | FoodImageWhereInput[]
    OR?: FoodImageWhereInput[]
    NOT?: FoodImageWhereInput | FoodImageWhereInput[]
    foodItemId?: IntFilter<"FoodImage"> | number
    url?: StringFilter<"FoodImage"> | string
    position?: IntFilter<"FoodImage"> | number
    createdAt?: DateTimeFilter<"FoodImage"> | Date | string
    foodItem?: XOR<FoodItemRelationFilter, FoodItemWhereInput>
  }, "id">

  export type FoodImageOrderByWithAggregationInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    _count?: FoodImageCountOrderByAggregateInput
    _avg?: FoodImageAvgOrderByAggregateInput
    _max?: FoodImageMaxOrderByAggregateInput
    _min?: FoodImageMinOrderByAggregateInput
    _sum?: FoodImageSumOrderByAggregateInput
  }

  export type FoodImageScalarWhereWithAggregatesInput = {
    AND?: FoodImageScalarWhereWithAggregatesInput | FoodImageScalarWhereWithAggregatesInput[]
    OR?: FoodImageScalarWhereWithAggregatesInput[]
    NOT?: FoodImageScalarWhereWithAggregatesInput | FoodImageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FoodImage"> | number
    foodItemId?: IntWithAggregatesFilter<"FoodImage"> | number
    url?: StringWithAggregatesFilter<"FoodImage"> | string
    position?: IntWithAggregatesFilter<"FoodImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FoodImage"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    customerId?: IntFilter<"Order"> | number
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: StringNullableFilter<"Order"> | string | null
    imageUrl?: StringNullableFilter<"Order"> | string | null
    totalPrice?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    salesmanId?: IntNullableFilter<"Order"> | number | null
    driverId?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    deliveryAddress?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    statusHistory?: OrderStatusHistoryListRelationFilter
    items?: OrderItemListRelationFilter
    salesman?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    driver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    deliveryProof?: XOR<DeliveryProofNullableRelationFilter, DeliveryProofWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    deliveryAddress?: AddressOrderByWithRelationInput
    statusHistory?: OrderStatusHistoryOrderByRelationAggregateInput
    items?: OrderItemOrderByRelationAggregateInput
    salesman?: UserOrderByWithRelationInput
    driver?: UserOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    deliveryProof?: DeliveryProofOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderNumber?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    customerId?: IntFilter<"Order"> | number
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: StringNullableFilter<"Order"> | string | null
    imageUrl?: StringNullableFilter<"Order"> | string | null
    totalPrice?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    salesmanId?: IntNullableFilter<"Order"> | number | null
    driverId?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    deliveryAddress?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    statusHistory?: OrderStatusHistoryListRelationFilter
    items?: OrderItemListRelationFilter
    salesman?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    driver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    deliveryProof?: XOR<DeliveryProofNullableRelationFilter, DeliveryProofWhereInput> | null
  }, "id" | "orderNumber">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Order"> | number
    orderNumber?: StringWithAggregatesFilter<"Order"> | string
    customerId?: IntWithAggregatesFilter<"Order"> | number
    deliveryAddressId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    notes?: StringNullableWithAggregatesFilter<"Order"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"Order"> | string | null
    totalPrice?: DecimalWithAggregatesFilter<"Order"> | Decimal | DecimalJsLike | number | string
    salesmanId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    driverId?: IntNullableWithAggregatesFilter<"Order"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    foodItemId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    foodItem?: XOR<FoodItemRelationFilter, FoodItemWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    foodItem?: FoodItemOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    foodItemId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    foodItem?: XOR<FoodItemRelationFilter, FoodItemWhereInput>
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    foodItemId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type OrderStatusHistoryWhereInput = {
    AND?: OrderStatusHistoryWhereInput | OrderStatusHistoryWhereInput[]
    OR?: OrderStatusHistoryWhereInput[]
    NOT?: OrderStatusHistoryWhereInput | OrderStatusHistoryWhereInput[]
    id?: IntFilter<"OrderStatusHistory"> | number
    orderId?: IntFilter<"OrderStatusHistory"> | number
    from?: EnumOrderStatusNullableFilter<"OrderStatusHistory"> | $Enums.OrderStatus | null
    to?: EnumOrderStatusFilter<"OrderStatusHistory"> | $Enums.OrderStatus
    changedAt?: DateTimeFilter<"OrderStatusHistory"> | Date | string
    changedById?: IntNullableFilter<"OrderStatusHistory"> | number | null
    note?: StringNullableFilter<"OrderStatusHistory"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    changedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type OrderStatusHistoryOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    from?: SortOrderInput | SortOrder
    to?: SortOrder
    changedAt?: SortOrder
    changedById?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    changedBy?: UserOrderByWithRelationInput
  }

  export type OrderStatusHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OrderStatusHistoryWhereInput | OrderStatusHistoryWhereInput[]
    OR?: OrderStatusHistoryWhereInput[]
    NOT?: OrderStatusHistoryWhereInput | OrderStatusHistoryWhereInput[]
    orderId?: IntFilter<"OrderStatusHistory"> | number
    from?: EnumOrderStatusNullableFilter<"OrderStatusHistory"> | $Enums.OrderStatus | null
    to?: EnumOrderStatusFilter<"OrderStatusHistory"> | $Enums.OrderStatus
    changedAt?: DateTimeFilter<"OrderStatusHistory"> | Date | string
    changedById?: IntNullableFilter<"OrderStatusHistory"> | number | null
    note?: StringNullableFilter<"OrderStatusHistory"> | string | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    changedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type OrderStatusHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    from?: SortOrderInput | SortOrder
    to?: SortOrder
    changedAt?: SortOrder
    changedById?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    _count?: OrderStatusHistoryCountOrderByAggregateInput
    _avg?: OrderStatusHistoryAvgOrderByAggregateInput
    _max?: OrderStatusHistoryMaxOrderByAggregateInput
    _min?: OrderStatusHistoryMinOrderByAggregateInput
    _sum?: OrderStatusHistorySumOrderByAggregateInput
  }

  export type OrderStatusHistoryScalarWhereWithAggregatesInput = {
    AND?: OrderStatusHistoryScalarWhereWithAggregatesInput | OrderStatusHistoryScalarWhereWithAggregatesInput[]
    OR?: OrderStatusHistoryScalarWhereWithAggregatesInput[]
    NOT?: OrderStatusHistoryScalarWhereWithAggregatesInput | OrderStatusHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderStatusHistory"> | number
    orderId?: IntWithAggregatesFilter<"OrderStatusHistory"> | number
    from?: EnumOrderStatusNullableWithAggregatesFilter<"OrderStatusHistory"> | $Enums.OrderStatus | null
    to?: EnumOrderStatusWithAggregatesFilter<"OrderStatusHistory"> | $Enums.OrderStatus
    changedAt?: DateTimeWithAggregatesFilter<"OrderStatusHistory"> | Date | string
    changedById?: IntNullableWithAggregatesFilter<"OrderStatusHistory"> | number | null
    note?: StringNullableWithAggregatesFilter<"OrderStatusHistory"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    orderId?: IntFilter<"Payment"> | number
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    provider?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    transactionId?: IntNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrderInput | SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    provider?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    transactionId?: IntNullableFilter<"Payment"> | number | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    order?: XOR<OrderRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrderInput | SortOrder
    status?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    orderId?: IntWithAggregatesFilter<"Payment"> | number
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    provider?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    transactionId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type DeliveryProofWhereInput = {
    AND?: DeliveryProofWhereInput | DeliveryProofWhereInput[]
    OR?: DeliveryProofWhereInput[]
    NOT?: DeliveryProofWhereInput | DeliveryProofWhereInput[]
    id?: IntFilter<"DeliveryProof"> | number
    orderId?: IntFilter<"DeliveryProof"> | number
    photoUrl?: StringFilter<"DeliveryProof"> | string
    note?: StringNullableFilter<"DeliveryProof"> | string | null
    deliveredAt?: DateTimeFilter<"DeliveryProof"> | Date | string
    driverId?: IntNullableFilter<"DeliveryProof"> | number | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    driver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type DeliveryProofOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    photoUrl?: SortOrder
    note?: SortOrderInput | SortOrder
    deliveredAt?: SortOrder
    driverId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    driver?: UserOrderByWithRelationInput
  }

  export type DeliveryProofWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId?: number
    AND?: DeliveryProofWhereInput | DeliveryProofWhereInput[]
    OR?: DeliveryProofWhereInput[]
    NOT?: DeliveryProofWhereInput | DeliveryProofWhereInput[]
    photoUrl?: StringFilter<"DeliveryProof"> | string
    note?: StringNullableFilter<"DeliveryProof"> | string | null
    deliveredAt?: DateTimeFilter<"DeliveryProof"> | Date | string
    driverId?: IntNullableFilter<"DeliveryProof"> | number | null
    order?: XOR<OrderRelationFilter, OrderWhereInput>
    driver?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "orderId">

  export type DeliveryProofOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    photoUrl?: SortOrder
    note?: SortOrderInput | SortOrder
    deliveredAt?: SortOrder
    driverId?: SortOrderInput | SortOrder
    _count?: DeliveryProofCountOrderByAggregateInput
    _avg?: DeliveryProofAvgOrderByAggregateInput
    _max?: DeliveryProofMaxOrderByAggregateInput
    _min?: DeliveryProofMinOrderByAggregateInput
    _sum?: DeliveryProofSumOrderByAggregateInput
  }

  export type DeliveryProofScalarWhereWithAggregatesInput = {
    AND?: DeliveryProofScalarWhereWithAggregatesInput | DeliveryProofScalarWhereWithAggregatesInput[]
    OR?: DeliveryProofScalarWhereWithAggregatesInput[]
    NOT?: DeliveryProofScalarWhereWithAggregatesInput | DeliveryProofScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryProof"> | number
    orderId?: IntWithAggregatesFilter<"DeliveryProof"> | number
    photoUrl?: StringWithAggregatesFilter<"DeliveryProof"> | string
    note?: StringNullableWithAggregatesFilter<"DeliveryProof"> | string | null
    deliveredAt?: DateTimeWithAggregatesFilter<"DeliveryProof"> | Date | string
    driverId?: IntNullableWithAggregatesFilter<"DeliveryProof"> | number | null
  }

  export type ServiceRequestWhereInput = {
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    id?: IntFilter<"ServiceRequest"> | number
    requestNumber?: StringFilter<"ServiceRequest"> | string
    customerId?: IntFilter<"ServiceRequest"> | number
    type?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    priority?: EnumServicePriorityFilter<"ServiceRequest"> | $Enums.ServicePriority
    title?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    addressId?: IntNullableFilter<"ServiceRequest"> | number | null
    requestedDate?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    notes?: StringNullableFilter<"ServiceRequest"> | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    photos?: ServicePhotoListRelationFilter
    assignments?: ServiceAssignmentListRelationFilter
    ratings?: ServiceRatingListRelationFilter
  }

  export type ServiceRequestOrderByWithRelationInput = {
    id?: SortOrder
    requestNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    addressId?: SortOrderInput | SortOrder
    requestedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customer?: UserOrderByWithRelationInput
    address?: AddressOrderByWithRelationInput
    photos?: ServicePhotoOrderByRelationAggregateInput
    assignments?: ServiceAssignmentOrderByRelationAggregateInput
    ratings?: ServiceRatingOrderByRelationAggregateInput
  }

  export type ServiceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    requestNumber?: string
    AND?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    OR?: ServiceRequestWhereInput[]
    NOT?: ServiceRequestWhereInput | ServiceRequestWhereInput[]
    customerId?: IntFilter<"ServiceRequest"> | number
    type?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    priority?: EnumServicePriorityFilter<"ServiceRequest"> | $Enums.ServicePriority
    title?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    addressId?: IntNullableFilter<"ServiceRequest"> | number | null
    requestedDate?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    notes?: StringNullableFilter<"ServiceRequest"> | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    customer?: XOR<UserRelationFilter, UserWhereInput>
    address?: XOR<AddressNullableRelationFilter, AddressWhereInput> | null
    photos?: ServicePhotoListRelationFilter
    assignments?: ServiceAssignmentListRelationFilter
    ratings?: ServiceRatingListRelationFilter
  }, "id" | "requestNumber">

  export type ServiceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requestNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    addressId?: SortOrderInput | SortOrder
    requestedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceRequestCountOrderByAggregateInput
    _avg?: ServiceRequestAvgOrderByAggregateInput
    _max?: ServiceRequestMaxOrderByAggregateInput
    _min?: ServiceRequestMinOrderByAggregateInput
    _sum?: ServiceRequestSumOrderByAggregateInput
  }

  export type ServiceRequestScalarWhereWithAggregatesInput = {
    AND?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    OR?: ServiceRequestScalarWhereWithAggregatesInput[]
    NOT?: ServiceRequestScalarWhereWithAggregatesInput | ServiceRequestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceRequest"> | number
    requestNumber?: StringWithAggregatesFilter<"ServiceRequest"> | string
    customerId?: IntWithAggregatesFilter<"ServiceRequest"> | number
    type?: EnumServiceTypeWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceType
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceRequest"> | $Enums.ServiceStatus
    priority?: EnumServicePriorityWithAggregatesFilter<"ServiceRequest"> | $Enums.ServicePriority
    title?: StringWithAggregatesFilter<"ServiceRequest"> | string
    description?: StringWithAggregatesFilter<"ServiceRequest"> | string
    addressId?: IntNullableWithAggregatesFilter<"ServiceRequest"> | number | null
    requestedDate?: DateTimeNullableWithAggregatesFilter<"ServiceRequest"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ServiceRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceRequest"> | Date | string
  }

  export type ServiceAssignmentWhereInput = {
    AND?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    OR?: ServiceAssignmentWhereInput[]
    NOT?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    id?: IntFilter<"ServiceAssignment"> | number
    serviceId?: IntFilter<"ServiceAssignment"> | number
    staffId?: IntFilter<"ServiceAssignment"> | number
    assignedById?: IntNullableFilter<"ServiceAssignment"> | number | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    status?: EnumServiceStatusFilter<"ServiceAssignment"> | $Enums.ServiceStatus
    notes?: StringNullableFilter<"ServiceAssignment"> | string | null
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
    staff?: XOR<UserRelationFilter, UserWhereInput>
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ServiceAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    service?: ServiceRequestOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
  }

  export type ServiceAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    OR?: ServiceAssignmentWhereInput[]
    NOT?: ServiceAssignmentWhereInput | ServiceAssignmentWhereInput[]
    serviceId?: IntFilter<"ServiceAssignment"> | number
    staffId?: IntFilter<"ServiceAssignment"> | number
    assignedById?: IntNullableFilter<"ServiceAssignment"> | number | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    status?: EnumServiceStatusFilter<"ServiceAssignment"> | $Enums.ServiceStatus
    notes?: StringNullableFilter<"ServiceAssignment"> | string | null
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
    staff?: XOR<UserRelationFilter, UserWhereInput>
    assignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ServiceAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ServiceAssignmentCountOrderByAggregateInput
    _avg?: ServiceAssignmentAvgOrderByAggregateInput
    _max?: ServiceAssignmentMaxOrderByAggregateInput
    _min?: ServiceAssignmentMinOrderByAggregateInput
    _sum?: ServiceAssignmentSumOrderByAggregateInput
  }

  export type ServiceAssignmentScalarWhereWithAggregatesInput = {
    AND?: ServiceAssignmentScalarWhereWithAggregatesInput | ServiceAssignmentScalarWhereWithAggregatesInput[]
    OR?: ServiceAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ServiceAssignmentScalarWhereWithAggregatesInput | ServiceAssignmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceAssignment"> | number
    serviceId?: IntWithAggregatesFilter<"ServiceAssignment"> | number
    staffId?: IntWithAggregatesFilter<"ServiceAssignment"> | number
    assignedById?: IntNullableWithAggregatesFilter<"ServiceAssignment"> | number | null
    assignedAt?: DateTimeWithAggregatesFilter<"ServiceAssignment"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"ServiceAssignment"> | Date | string | null
    status?: EnumServiceStatusWithAggregatesFilter<"ServiceAssignment"> | $Enums.ServiceStatus
    notes?: StringNullableWithAggregatesFilter<"ServiceAssignment"> | string | null
  }

  export type ServicePhotoWhereInput = {
    AND?: ServicePhotoWhereInput | ServicePhotoWhereInput[]
    OR?: ServicePhotoWhereInput[]
    NOT?: ServicePhotoWhereInput | ServicePhotoWhereInput[]
    id?: IntFilter<"ServicePhoto"> | number
    serviceId?: IntFilter<"ServicePhoto"> | number
    url?: StringFilter<"ServicePhoto"> | string
    isBefore?: BoolFilter<"ServicePhoto"> | boolean
    createdAt?: DateTimeFilter<"ServicePhoto"> | Date | string
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
  }

  export type ServicePhotoOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    isBefore?: SortOrder
    createdAt?: SortOrder
    service?: ServiceRequestOrderByWithRelationInput
  }

  export type ServicePhotoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServicePhotoWhereInput | ServicePhotoWhereInput[]
    OR?: ServicePhotoWhereInput[]
    NOT?: ServicePhotoWhereInput | ServicePhotoWhereInput[]
    serviceId?: IntFilter<"ServicePhoto"> | number
    url?: StringFilter<"ServicePhoto"> | string
    isBefore?: BoolFilter<"ServicePhoto"> | boolean
    createdAt?: DateTimeFilter<"ServicePhoto"> | Date | string
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
  }, "id">

  export type ServicePhotoOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    isBefore?: SortOrder
    createdAt?: SortOrder
    _count?: ServicePhotoCountOrderByAggregateInput
    _avg?: ServicePhotoAvgOrderByAggregateInput
    _max?: ServicePhotoMaxOrderByAggregateInput
    _min?: ServicePhotoMinOrderByAggregateInput
    _sum?: ServicePhotoSumOrderByAggregateInput
  }

  export type ServicePhotoScalarWhereWithAggregatesInput = {
    AND?: ServicePhotoScalarWhereWithAggregatesInput | ServicePhotoScalarWhereWithAggregatesInput[]
    OR?: ServicePhotoScalarWhereWithAggregatesInput[]
    NOT?: ServicePhotoScalarWhereWithAggregatesInput | ServicePhotoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServicePhoto"> | number
    serviceId?: IntWithAggregatesFilter<"ServicePhoto"> | number
    url?: StringWithAggregatesFilter<"ServicePhoto"> | string
    isBefore?: BoolWithAggregatesFilter<"ServicePhoto"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServicePhoto"> | Date | string
  }

  export type ServiceRatingWhereInput = {
    AND?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    OR?: ServiceRatingWhereInput[]
    NOT?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    id?: IntFilter<"ServiceRating"> | number
    serviceId?: IntFilter<"ServiceRating"> | number
    customerId?: IntFilter<"ServiceRating"> | number
    staffId?: IntNullableFilter<"ServiceRating"> | number | null
    score?: IntFilter<"ServiceRating"> | number
    review?: StringNullableFilter<"ServiceRating"> | string | null
    wouldRecommend?: BoolFilter<"ServiceRating"> | boolean
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
    customer?: XOR<UserRelationFilter, UserWhereInput>
    staff?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ServiceRatingOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrderInput | SortOrder
    score?: SortOrder
    review?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrder
    createdAt?: SortOrder
    service?: ServiceRequestOrderByWithRelationInput
    customer?: UserOrderByWithRelationInput
    staff?: UserOrderByWithRelationInput
  }

  export type ServiceRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceId_customerId?: ServiceRatingServiceIdCustomerIdCompoundUniqueInput
    AND?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    OR?: ServiceRatingWhereInput[]
    NOT?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    serviceId?: IntFilter<"ServiceRating"> | number
    customerId?: IntFilter<"ServiceRating"> | number
    staffId?: IntNullableFilter<"ServiceRating"> | number | null
    score?: IntFilter<"ServiceRating"> | number
    review?: StringNullableFilter<"ServiceRating"> | string | null
    wouldRecommend?: BoolFilter<"ServiceRating"> | boolean
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
    service?: XOR<ServiceRequestRelationFilter, ServiceRequestWhereInput>
    customer?: XOR<UserRelationFilter, UserWhereInput>
    staff?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "serviceId_customerId">

  export type ServiceRatingOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrderInput | SortOrder
    score?: SortOrder
    review?: SortOrderInput | SortOrder
    wouldRecommend?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceRatingCountOrderByAggregateInput
    _avg?: ServiceRatingAvgOrderByAggregateInput
    _max?: ServiceRatingMaxOrderByAggregateInput
    _min?: ServiceRatingMinOrderByAggregateInput
    _sum?: ServiceRatingSumOrderByAggregateInput
  }

  export type ServiceRatingScalarWhereWithAggregatesInput = {
    AND?: ServiceRatingScalarWhereWithAggregatesInput | ServiceRatingScalarWhereWithAggregatesInput[]
    OR?: ServiceRatingScalarWhereWithAggregatesInput[]
    NOT?: ServiceRatingScalarWhereWithAggregatesInput | ServiceRatingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceRating"> | number
    serviceId?: IntWithAggregatesFilter<"ServiceRating"> | number
    customerId?: IntWithAggregatesFilter<"ServiceRating"> | number
    staffId?: IntNullableWithAggregatesFilter<"ServiceRating"> | number | null
    score?: IntWithAggregatesFilter<"ServiceRating"> | number
    review?: StringNullableWithAggregatesFilter<"ServiceRating"> | string | null
    wouldRecommend?: BoolWithAggregatesFilter<"ServiceRating"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceRating"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    actorId?: IntNullableFilter<"AuditLog"> | number | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    actorId?: IntNullableFilter<"AuditLog"> | number | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    entityType?: EnumAuditEntityTypeWithAggregatesFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: EnumAuditActionWithAggregatesFilter<"AuditLog"> | $Enums.AuditAction
    actorId?: IntNullableWithAggregatesFilter<"AuditLog"> | number | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    orders?: OrderCreateNestedManyWithoutDeliveryAddressInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateInput = {
    id?: number
    userId: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressUpdateInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    orders?: OrderUpdateManyWithoutDeliveryAddressNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressCreateManyInput = {
    id?: number
    userId: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateInput = {
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutContactMessagesInput
    handledBy?: UserCreateNestedOneWithoutHandledMessagesInput
  }

  export type ContactMessageUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    userId?: number | null
    handledById?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactMessagesNestedInput
    handledBy?: UserUpdateOneWithoutHandledMessagesNestedInput
  }

  export type ContactMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    handledById?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageCreateManyInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    userId?: number | null
    handledById?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ContactMessageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    handledById?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCategoryCreateInput = {
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FoodItemCreateNestedManyWithoutCategoryInput
  }

  export type FoodCategoryUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: FoodItemUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type FoodCategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FoodItemUpdateManyWithoutCategoryNestedInput
  }

  export type FoodCategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: FoodItemUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type FoodCategoryCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemCreateInput = {
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: FoodCategoryCreateNestedOneWithoutItemsInput
    images?: FoodImageCreateNestedManyWithoutFoodItemInput
    orderItems?: OrderItemCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    categoryId: number
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: FoodImageUncheckedCreateNestedManyWithoutFoodItemInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: FoodCategoryUpdateOneRequiredWithoutItemsNestedInput
    images?: FoodImageUpdateManyWithoutFoodItemNestedInput
    orderItems?: OrderItemUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: FoodImageUncheckedUpdateManyWithoutFoodItemNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    categoryId: number
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodItemUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageCreateInput = {
    url: string
    position?: number
    createdAt?: Date | string
    foodItem: FoodItemCreateNestedOneWithoutImagesInput
  }

  export type FoodImageUncheckedCreateInput = {
    id?: number
    foodItemId: number
    url: string
    position?: number
    createdAt?: Date | string
  }

  export type FoodImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foodItem?: FoodItemUpdateOneRequiredWithoutImagesNestedInput
  }

  export type FoodImageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageCreateManyInput = {
    id?: number
    foodItemId: number
    url: string
    position?: number
    createdAt?: Date | string
  }

  export type FoodImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
    foodItem: FoodItemCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    foodItemId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
    foodItem?: FoodItemUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    foodItemId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusHistoryCreateInput = {
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    note?: string | null
    order: OrderCreateNestedOneWithoutStatusHistoryInput
    changedBy?: UserCreateNestedOneWithoutOrderStatusChangesInput
  }

  export type OrderStatusHistoryUncheckedCreateInput = {
    id?: number
    orderId: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    changedById?: number | null
    note?: string | null
  }

  export type OrderStatusHistoryUpdateInput = {
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutStatusHistoryNestedInput
    changedBy?: UserUpdateOneWithoutOrderStatusChangesNestedInput
  }

  export type OrderStatusHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusHistoryCreateManyInput = {
    id?: number
    orderId: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    changedById?: number | null
    note?: string | null
  }

  export type OrderStatusHistoryUpdateManyMutationInput = {
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    provider?: string | null
    status?: string
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    orderId: number
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    provider?: string | null
    status?: string
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    orderId: number
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    provider?: string | null
    status?: string
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryProofCreateInput = {
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    order: OrderCreateNestedOneWithoutDeliveryProofInput
    driver?: UserCreateNestedOneWithoutDeliveryProofsInput
  }

  export type DeliveryProofUncheckedCreateInput = {
    id?: number
    orderId: number
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    driverId?: number | null
  }

  export type DeliveryProofUpdateInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryProofNestedInput
    driver?: UserUpdateOneWithoutDeliveryProofsNestedInput
  }

  export type DeliveryProofUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type DeliveryProofCreateManyInput = {
    id?: number
    orderId: number
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    driverId?: number | null
  }

  export type DeliveryProofUpdateManyMutationInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryProofUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceRequestCreateInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutServiceRequestsInput
    address?: AddressCreateNestedOneWithoutServiceRequestsInput
    photos?: ServicePhotoCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ServicePhotoUncheckedCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUpdateInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    address?: AddressUpdateOneWithoutServiceRequestsNestedInput
    photos?: ServicePhotoUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestCreateManyInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestUpdateManyMutationInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentCreateInput = {
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
    service: ServiceRequestCreateNestedOneWithoutAssignmentsInput
    staff: UserCreateNestedOneWithoutStaffServicesInput
    assignedBy?: UserCreateNestedOneWithoutServiceAssignmentsInput
  }

  export type ServiceAssignmentUncheckedCreateInput = {
    id?: number
    serviceId: number
    staffId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceAssignmentUpdateInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceRequestUpdateOneRequiredWithoutAssignmentsNestedInput
    staff?: UserUpdateOneRequiredWithoutStaffServicesNestedInput
    assignedBy?: UserUpdateOneWithoutServiceAssignmentsNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentCreateManyInput = {
    id?: number
    serviceId: number
    staffId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceAssignmentUpdateManyMutationInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServicePhotoCreateInput = {
    url: string
    isBefore?: boolean
    createdAt?: Date | string
    service: ServiceRequestCreateNestedOneWithoutPhotosInput
  }

  export type ServicePhotoUncheckedCreateInput = {
    id?: number
    serviceId: number
    url: string
    isBefore?: boolean
    createdAt?: Date | string
  }

  export type ServicePhotoUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceRequestUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type ServicePhotoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePhotoCreateManyInput = {
    id?: number
    serviceId: number
    url: string
    isBefore?: boolean
    createdAt?: Date | string
  }

  export type ServicePhotoUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePhotoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingCreateInput = {
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
    service: ServiceRequestCreateNestedOneWithoutRatingsInput
    customer: UserCreateNestedOneWithoutRatingsInput
    staff?: UserCreateNestedOneWithoutRatedServicesInput
  }

  export type ServiceRatingUncheckedCreateInput = {
    id?: number
    serviceId: number
    customerId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingUpdateInput = {
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceRequestUpdateOneRequiredWithoutRatingsNestedInput
    customer?: UserUpdateOneRequiredWithoutRatingsNestedInput
    staff?: UserUpdateOneWithoutRatedServicesNestedInput
  }

  export type ServiceRatingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingCreateManyInput = {
    id?: number
    serviceId: number
    customerId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingUpdateManyMutationInput = {
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    actorId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    actorId?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    actorId?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ServiceRequestListRelationFilter = {
    every?: ServiceRequestWhereInput
    some?: ServiceRequestWhereInput
    none?: ServiceRequestWhereInput
  }

  export type ServiceAssignmentListRelationFilter = {
    every?: ServiceAssignmentWhereInput
    some?: ServiceAssignmentWhereInput
    none?: ServiceAssignmentWhereInput
  }

  export type ContactMessageListRelationFilter = {
    every?: ContactMessageWhereInput
    some?: ContactMessageWhereInput
    none?: ContactMessageWhereInput
  }

  export type ServiceRatingListRelationFilter = {
    every?: ServiceRatingWhereInput
    some?: ServiceRatingWhereInput
    none?: ServiceRatingWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type OrderStatusHistoryListRelationFilter = {
    every?: OrderStatusHistoryWhereInput
    some?: OrderStatusHistoryWhereInput
    none?: OrderStatusHistoryWhereInput
  }

  export type DeliveryProofListRelationFilter = {
    every?: DeliveryProofWhereInput
    some?: DeliveryProofWhereInput
    none?: DeliveryProofWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderStatusHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeliveryProofOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    status?: SortOrder
    emailVerified?: SortOrder
    profileImage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    label?: SortOrder
    line1?: SortOrder
    line2?: SortOrder
    city?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    isDefault?: SortOrder
    createdAt?: SortOrder
  }

  export type AddressSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ContactMessageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    handledById?: SortOrder
    handledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    handledById?: SortOrder
  }

  export type ContactMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    handledById?: SortOrder
    handledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    userId?: SortOrder
    handledById?: SortOrder
    handledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactMessageSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    handledById?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FoodItemListRelationFilter = {
    every?: FoodItemWhereInput
    some?: FoodItemWhereInput
    none?: FoodItemWhereInput
  }

  export type FoodItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FoodCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodCategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FoodCategoryRelationFilter = {
    is?: FoodCategoryWhereInput
    isNot?: FoodCategoryWhereInput
  }

  export type FoodImageListRelationFilter = {
    every?: FoodImageWhereInput
    some?: FoodImageWhereInput
    none?: FoodImageWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type FoodImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FoodItemCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    mainImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    categoryId?: SortOrder
  }

  export type FoodItemMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    mainImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    price?: SortOrder
    sku?: SortOrder
    stock?: SortOrder
    isActive?: SortOrder
    categoryId?: SortOrder
    mainImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FoodItemSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    categoryId?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FoodItemRelationFilter = {
    is?: FoodItemWhereInput
    isNot?: FoodItemWhereInput
  }

  export type FoodImageCountOrderByAggregateInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodImageAvgOrderByAggregateInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    position?: SortOrder
  }

  export type FoodImageMaxOrderByAggregateInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodImageMinOrderByAggregateInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    url?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
  }

  export type FoodImageSumOrderByAggregateInput = {
    id?: SortOrder
    foodItemId?: SortOrder
    position?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type AddressNullableRelationFilter = {
    is?: AddressWhereInput | null
    isNot?: AddressWhereInput | null
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type DeliveryProofNullableRelationFilter = {
    is?: DeliveryProofWhereInput | null
    isNot?: DeliveryProofWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrder
    driverId?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    imageUrl?: SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrder
    driverId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    deliveryAddressId?: SortOrder
    totalPrice?: SortOrder
    salesmanId?: SortOrder
    driverId?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type OrderRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    createdAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    foodItemId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
  }

  export type EnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type OrderStatusHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    changedAt?: SortOrder
    changedById?: SortOrder
    note?: SortOrder
  }

  export type OrderStatusHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedById?: SortOrder
  }

  export type OrderStatusHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    changedAt?: SortOrder
    changedById?: SortOrder
    note?: SortOrder
  }

  export type OrderStatusHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    from?: SortOrder
    to?: SortOrder
    changedAt?: SortOrder
    changedById?: SortOrder
    note?: SortOrder
  }

  export type OrderStatusHistorySumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    changedById?: SortOrder
  }

  export type EnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
  }

  export type DeliveryProofCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    photoUrl?: SortOrder
    note?: SortOrder
    deliveredAt?: SortOrder
    driverId?: SortOrder
  }

  export type DeliveryProofAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    driverId?: SortOrder
  }

  export type DeliveryProofMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    photoUrl?: SortOrder
    note?: SortOrder
    deliveredAt?: SortOrder
    driverId?: SortOrder
  }

  export type DeliveryProofMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    photoUrl?: SortOrder
    note?: SortOrder
    deliveredAt?: SortOrder
    driverId?: SortOrder
  }

  export type DeliveryProofSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    driverId?: SortOrder
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type EnumServicePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ServicePriority | EnumServicePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumServicePriorityFilter<$PrismaModel> | $Enums.ServicePriority
  }

  export type ServicePhotoListRelationFilter = {
    every?: ServicePhotoWhereInput
    some?: ServicePhotoWhereInput
    none?: ServicePhotoWhereInput
  }

  export type ServicePhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requestNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    requestedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressId?: SortOrder
  }

  export type ServiceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requestNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    requestedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requestNumber?: SortOrder
    customerId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    title?: SortOrder
    description?: SortOrder
    addressId?: SortOrder
    requestedDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceRequestSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    addressId?: SortOrder
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type EnumServicePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServicePriority | EnumServicePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumServicePriorityWithAggregatesFilter<$PrismaModel> | $Enums.ServicePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServicePriorityFilter<$PrismaModel>
    _max?: NestedEnumServicePriorityFilter<$PrismaModel>
  }

  export type ServiceRequestRelationFilter = {
    is?: ServiceRequestWhereInput
    isNot?: ServiceRequestWhereInput
  }

  export type ServiceAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ServiceAssignmentAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrder
  }

  export type ServiceAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ServiceAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type ServiceAssignmentSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    staffId?: SortOrder
    assignedById?: SortOrder
  }

  export type ServicePhotoCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    isBefore?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePhotoAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
  }

  export type ServicePhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    isBefore?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePhotoMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    isBefore?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePhotoSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
  }

  export type ServiceRatingServiceIdCustomerIdCompoundUniqueInput = {
    serviceId: number
    customerId: number
  }

  export type ServiceRatingCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrder
    score?: SortOrder
    review?: SortOrder
    wouldRecommend?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceRatingAvgOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrder
    score?: SortOrder
  }

  export type ServiceRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrder
    score?: SortOrder
    review?: SortOrder
    wouldRecommend?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceRatingMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrder
    score?: SortOrder
    review?: SortOrder
    wouldRecommend?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceRatingSumOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    customerId?: SortOrder
    staffId?: SortOrder
    score?: SortOrder
  }

  export type EnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type EnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    actorId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    action?: SortOrder
    actorId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    entityId?: SortOrder
    actorId?: SortOrder
  }

  export type EnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type EnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput> | ServiceRequestCreateWithoutCustomerInput[] | ServiceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCustomerInput | ServiceRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceRequestCreateManyCustomerInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutSalesmanInput = {
    create?: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput> | OrderCreateWithoutSalesmanInput[] | OrderUncheckedCreateWithoutSalesmanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalesmanInput | OrderCreateOrConnectWithoutSalesmanInput[]
    createMany?: OrderCreateManySalesmanInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutDriverInput = {
    create?: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput> | OrderCreateWithoutDriverInput[] | OrderUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDriverInput | OrderCreateOrConnectWithoutDriverInput[]
    createMany?: OrderCreateManyDriverInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceAssignmentCreateNestedManyWithoutStaffInput = {
    create?: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput> | ServiceAssignmentCreateWithoutStaffInput[] | ServiceAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutStaffInput | ServiceAssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: ServiceAssignmentCreateManyStaffInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type ContactMessageCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type ContactMessageCreateNestedManyWithoutHandledByInput = {
    create?: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput> | ContactMessageCreateWithoutHandledByInput[] | ContactMessageUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutHandledByInput | ContactMessageCreateOrConnectWithoutHandledByInput[]
    createMany?: ContactMessageCreateManyHandledByInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type ServiceRatingCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput> | ServiceRatingCreateWithoutCustomerInput[] | ServiceRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutCustomerInput | ServiceRatingCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceRatingCreateManyCustomerInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type ServiceRatingCreateNestedManyWithoutStaffInput = {
    create?: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput> | ServiceRatingCreateWithoutStaffInput[] | ServiceRatingUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutStaffInput | ServiceRatingCreateOrConnectWithoutStaffInput[]
    createMany?: ServiceRatingCreateManyStaffInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type OrderStatusHistoryCreateNestedManyWithoutChangedByInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput> | OrderStatusHistoryCreateWithoutChangedByInput[] | OrderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutChangedByInput | OrderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: OrderStatusHistoryCreateManyChangedByInputEnvelope
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
  }

  export type DeliveryProofCreateNestedManyWithoutDriverInput = {
    create?: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput> | DeliveryProofCreateWithoutDriverInput[] | DeliveryProofUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutDriverInput | DeliveryProofCreateOrConnectWithoutDriverInput[]
    createMany?: DeliveryProofCreateManyDriverInputEnvelope
    connect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
  }

  export type ServiceAssignmentCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput> | ServiceAssignmentCreateWithoutAssignedByInput[] | ServiceAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutAssignedByInput | ServiceAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ServiceAssignmentCreateManyAssignedByInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput> | ServiceRequestCreateWithoutCustomerInput[] | ServiceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCustomerInput | ServiceRequestCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceRequestCreateManyCustomerInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutSalesmanInput = {
    create?: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput> | OrderCreateWithoutSalesmanInput[] | OrderUncheckedCreateWithoutSalesmanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalesmanInput | OrderCreateOrConnectWithoutSalesmanInput[]
    createMany?: OrderCreateManySalesmanInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput> | OrderCreateWithoutDriverInput[] | OrderUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDriverInput | OrderCreateOrConnectWithoutDriverInput[]
    createMany?: OrderCreateManyDriverInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput> | ServiceAssignmentCreateWithoutStaffInput[] | ServiceAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutStaffInput | ServiceAssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: ServiceAssignmentCreateManyStaffInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type ContactMessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type ContactMessageUncheckedCreateNestedManyWithoutHandledByInput = {
    create?: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput> | ContactMessageCreateWithoutHandledByInput[] | ContactMessageUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutHandledByInput | ContactMessageCreateOrConnectWithoutHandledByInput[]
    createMany?: ContactMessageCreateManyHandledByInputEnvelope
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
  }

  export type ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput> | ServiceRatingCreateWithoutCustomerInput[] | ServiceRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutCustomerInput | ServiceRatingCreateOrConnectWithoutCustomerInput[]
    createMany?: ServiceRatingCreateManyCustomerInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type ServiceRatingUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput> | ServiceRatingCreateWithoutStaffInput[] | ServiceRatingUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutStaffInput | ServiceRatingCreateOrConnectWithoutStaffInput[]
    createMany?: ServiceRatingCreateManyStaffInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput> | OrderStatusHistoryCreateWithoutChangedByInput[] | OrderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutChangedByInput | OrderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    createMany?: OrderStatusHistoryCreateManyChangedByInputEnvelope
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
  }

  export type DeliveryProofUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput> | DeliveryProofCreateWithoutDriverInput[] | DeliveryProofUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutDriverInput | DeliveryProofCreateOrConnectWithoutDriverInput[]
    createMany?: DeliveryProofCreateManyDriverInputEnvelope
    connect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
  }

  export type ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput> | ServiceAssignmentCreateWithoutAssignedByInput[] | ServiceAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutAssignedByInput | ServiceAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ServiceAssignmentCreateManyAssignedByInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput> | ServiceRequestCreateWithoutCustomerInput[] | ServiceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCustomerInput | ServiceRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutCustomerInput | ServiceRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceRequestCreateManyCustomerInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutCustomerInput | ServiceRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutCustomerInput | ServiceRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutSalesmanNestedInput = {
    create?: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput> | OrderCreateWithoutSalesmanInput[] | OrderUncheckedCreateWithoutSalesmanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalesmanInput | OrderCreateOrConnectWithoutSalesmanInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSalesmanInput | OrderUpsertWithWhereUniqueWithoutSalesmanInput[]
    createMany?: OrderCreateManySalesmanInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSalesmanInput | OrderUpdateWithWhereUniqueWithoutSalesmanInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSalesmanInput | OrderUpdateManyWithWhereWithoutSalesmanInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutDriverNestedInput = {
    create?: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput> | OrderCreateWithoutDriverInput[] | OrderUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDriverInput | OrderCreateOrConnectWithoutDriverInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDriverInput | OrderUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: OrderCreateManyDriverInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDriverInput | OrderUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDriverInput | OrderUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceAssignmentUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput> | ServiceAssignmentCreateWithoutStaffInput[] | ServiceAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutStaffInput | ServiceAssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutStaffInput | ServiceAssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ServiceAssignmentCreateManyStaffInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutStaffInput | ServiceAssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutStaffInput | ServiceAssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type ContactMessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutUserInput | ContactMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutUserInput | ContactMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutUserInput | ContactMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type ContactMessageUpdateManyWithoutHandledByNestedInput = {
    create?: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput> | ContactMessageCreateWithoutHandledByInput[] | ContactMessageUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutHandledByInput | ContactMessageCreateOrConnectWithoutHandledByInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutHandledByInput | ContactMessageUpsertWithWhereUniqueWithoutHandledByInput[]
    createMany?: ContactMessageCreateManyHandledByInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutHandledByInput | ContactMessageUpdateWithWhereUniqueWithoutHandledByInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutHandledByInput | ContactMessageUpdateManyWithWhereWithoutHandledByInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type ServiceRatingUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput> | ServiceRatingCreateWithoutCustomerInput[] | ServiceRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutCustomerInput | ServiceRatingCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutCustomerInput | ServiceRatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceRatingCreateManyCustomerInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutCustomerInput | ServiceRatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutCustomerInput | ServiceRatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServiceRatingUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput> | ServiceRatingCreateWithoutStaffInput[] | ServiceRatingUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutStaffInput | ServiceRatingCreateOrConnectWithoutStaffInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutStaffInput | ServiceRatingUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ServiceRatingCreateManyStaffInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutStaffInput | ServiceRatingUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutStaffInput | ServiceRatingUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type OrderStatusHistoryUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput> | OrderStatusHistoryCreateWithoutChangedByInput[] | OrderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutChangedByInput | OrderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: OrderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | OrderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: OrderStatusHistoryCreateManyChangedByInputEnvelope
    set?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    disconnect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    delete?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    update?: OrderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | OrderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: OrderStatusHistoryUpdateManyWithWhereWithoutChangedByInput | OrderStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
  }

  export type DeliveryProofUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput> | DeliveryProofCreateWithoutDriverInput[] | DeliveryProofUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutDriverInput | DeliveryProofCreateOrConnectWithoutDriverInput[]
    upsert?: DeliveryProofUpsertWithWhereUniqueWithoutDriverInput | DeliveryProofUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DeliveryProofCreateManyDriverInputEnvelope
    set?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    disconnect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    delete?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    connect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    update?: DeliveryProofUpdateWithWhereUniqueWithoutDriverInput | DeliveryProofUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DeliveryProofUpdateManyWithWhereWithoutDriverInput | DeliveryProofUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DeliveryProofScalarWhereInput | DeliveryProofScalarWhereInput[]
  }

  export type ServiceAssignmentUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput> | ServiceAssignmentCreateWithoutAssignedByInput[] | ServiceAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutAssignedByInput | ServiceAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ServiceAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ServiceAssignmentCreateManyAssignedByInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ServiceAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutAssignedByInput | ServiceAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput> | ServiceRequestCreateWithoutCustomerInput[] | ServiceRequestUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutCustomerInput | ServiceRequestCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutCustomerInput | ServiceRequestUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceRequestCreateManyCustomerInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutCustomerInput | ServiceRequestUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutCustomerInput | ServiceRequestUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutSalesmanNestedInput = {
    create?: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput> | OrderCreateWithoutSalesmanInput[] | OrderUncheckedCreateWithoutSalesmanInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutSalesmanInput | OrderCreateOrConnectWithoutSalesmanInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutSalesmanInput | OrderUpsertWithWhereUniqueWithoutSalesmanInput[]
    createMany?: OrderCreateManySalesmanInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutSalesmanInput | OrderUpdateWithWhereUniqueWithoutSalesmanInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutSalesmanInput | OrderUpdateManyWithWhereWithoutSalesmanInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput> | OrderCreateWithoutDriverInput[] | OrderUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDriverInput | OrderCreateOrConnectWithoutDriverInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDriverInput | OrderUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: OrderCreateManyDriverInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDriverInput | OrderUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDriverInput | OrderUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput> | ServiceAssignmentCreateWithoutStaffInput[] | ServiceAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutStaffInput | ServiceAssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutStaffInput | ServiceAssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ServiceAssignmentCreateManyStaffInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutStaffInput | ServiceAssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutStaffInput | ServiceAssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type ContactMessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput> | ContactMessageCreateWithoutUserInput[] | ContactMessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutUserInput | ContactMessageCreateOrConnectWithoutUserInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutUserInput | ContactMessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ContactMessageCreateManyUserInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutUserInput | ContactMessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutUserInput | ContactMessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput = {
    create?: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput> | ContactMessageCreateWithoutHandledByInput[] | ContactMessageUncheckedCreateWithoutHandledByInput[]
    connectOrCreate?: ContactMessageCreateOrConnectWithoutHandledByInput | ContactMessageCreateOrConnectWithoutHandledByInput[]
    upsert?: ContactMessageUpsertWithWhereUniqueWithoutHandledByInput | ContactMessageUpsertWithWhereUniqueWithoutHandledByInput[]
    createMany?: ContactMessageCreateManyHandledByInputEnvelope
    set?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    disconnect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    delete?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    connect?: ContactMessageWhereUniqueInput | ContactMessageWhereUniqueInput[]
    update?: ContactMessageUpdateWithWhereUniqueWithoutHandledByInput | ContactMessageUpdateWithWhereUniqueWithoutHandledByInput[]
    updateMany?: ContactMessageUpdateManyWithWhereWithoutHandledByInput | ContactMessageUpdateManyWithWhereWithoutHandledByInput[]
    deleteMany?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
  }

  export type ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput> | ServiceRatingCreateWithoutCustomerInput[] | ServiceRatingUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutCustomerInput | ServiceRatingCreateOrConnectWithoutCustomerInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutCustomerInput | ServiceRatingUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: ServiceRatingCreateManyCustomerInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutCustomerInput | ServiceRatingUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutCustomerInput | ServiceRatingUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput> | ServiceRatingCreateWithoutStaffInput[] | ServiceRatingUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutStaffInput | ServiceRatingCreateOrConnectWithoutStaffInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutStaffInput | ServiceRatingUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ServiceRatingCreateManyStaffInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutStaffInput | ServiceRatingUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutStaffInput | ServiceRatingUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput> | AuditLogCreateWithoutActorInput[] | AuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutActorInput | AuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutActorInput | AuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditLogCreateManyActorInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutActorInput | AuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutActorInput | AuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput> | OrderStatusHistoryCreateWithoutChangedByInput[] | OrderStatusHistoryUncheckedCreateWithoutChangedByInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutChangedByInput | OrderStatusHistoryCreateOrConnectWithoutChangedByInput[]
    upsert?: OrderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput | OrderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput[]
    createMany?: OrderStatusHistoryCreateManyChangedByInputEnvelope
    set?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    disconnect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    delete?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    update?: OrderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput | OrderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput[]
    updateMany?: OrderStatusHistoryUpdateManyWithWhereWithoutChangedByInput | OrderStatusHistoryUpdateManyWithWhereWithoutChangedByInput[]
    deleteMany?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
  }

  export type DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput> | DeliveryProofCreateWithoutDriverInput[] | DeliveryProofUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutDriverInput | DeliveryProofCreateOrConnectWithoutDriverInput[]
    upsert?: DeliveryProofUpsertWithWhereUniqueWithoutDriverInput | DeliveryProofUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: DeliveryProofCreateManyDriverInputEnvelope
    set?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    disconnect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    delete?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    connect?: DeliveryProofWhereUniqueInput | DeliveryProofWhereUniqueInput[]
    update?: DeliveryProofUpdateWithWhereUniqueWithoutDriverInput | DeliveryProofUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: DeliveryProofUpdateManyWithWhereWithoutDriverInput | DeliveryProofUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: DeliveryProofScalarWhereInput | DeliveryProofScalarWhereInput[]
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput> | ServiceAssignmentCreateWithoutAssignedByInput[] | ServiceAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutAssignedByInput | ServiceAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ServiceAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ServiceAssignmentCreateManyAssignedByInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ServiceAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutAssignedByInput | ServiceAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceRequestCreateNestedManyWithoutAddressInput = {
    create?: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput> | ServiceRequestCreateWithoutAddressInput[] | ServiceRequestUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAddressInput | ServiceRequestCreateOrConnectWithoutAddressInput[]
    createMany?: ServiceRequestCreateManyAddressInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ServiceRequestUncheckedCreateNestedManyWithoutAddressInput = {
    create?: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput> | ServiceRequestCreateWithoutAddressInput[] | ServiceRequestUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAddressInput | ServiceRequestCreateOrConnectWithoutAddressInput[]
    createMany?: ServiceRequestCreateManyAddressInputEnvelope
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type OrderUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryAddressInput | OrderUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceRequestUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput> | ServiceRequestCreateWithoutAddressInput[] | ServiceRequestUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAddressInput | ServiceRequestCreateOrConnectWithoutAddressInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutAddressInput | ServiceRequestUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ServiceRequestCreateManyAddressInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutAddressInput | ServiceRequestUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutAddressInput | ServiceRequestUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput> | OrderCreateWithoutDeliveryAddressInput[] | OrderUncheckedCreateWithoutDeliveryAddressInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryAddressInput | OrderCreateOrConnectWithoutDeliveryAddressInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput | OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput[]
    createMany?: OrderCreateManyDeliveryAddressInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput | OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutDeliveryAddressInput | OrderUpdateManyWithWhereWithoutDeliveryAddressInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ServiceRequestUncheckedUpdateManyWithoutAddressNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput> | ServiceRequestCreateWithoutAddressInput[] | ServiceRequestUncheckedCreateWithoutAddressInput[]
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAddressInput | ServiceRequestCreateOrConnectWithoutAddressInput[]
    upsert?: ServiceRequestUpsertWithWhereUniqueWithoutAddressInput | ServiceRequestUpsertWithWhereUniqueWithoutAddressInput[]
    createMany?: ServiceRequestCreateManyAddressInputEnvelope
    set?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    disconnect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    delete?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    connect?: ServiceRequestWhereUniqueInput | ServiceRequestWhereUniqueInput[]
    update?: ServiceRequestUpdateWithWhereUniqueWithoutAddressInput | ServiceRequestUpdateWithWhereUniqueWithoutAddressInput[]
    updateMany?: ServiceRequestUpdateManyWithWhereWithoutAddressInput | ServiceRequestUpdateManyWithWhereWithoutAddressInput[]
    deleteMany?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutContactMessagesInput = {
    create?: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutHandledMessagesInput = {
    create?: XOR<UserCreateWithoutHandledMessagesInput, UserUncheckedCreateWithoutHandledMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandledMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutContactMessagesNestedInput = {
    create?: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutContactMessagesInput
    upsert?: UserUpsertWithoutContactMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutContactMessagesInput, UserUpdateWithoutContactMessagesInput>, UserUncheckedUpdateWithoutContactMessagesInput>
  }

  export type UserUpdateOneWithoutHandledMessagesNestedInput = {
    create?: XOR<UserCreateWithoutHandledMessagesInput, UserUncheckedCreateWithoutHandledMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutHandledMessagesInput
    upsert?: UserUpsertWithoutHandledMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHandledMessagesInput, UserUpdateWithoutHandledMessagesInput>, UserUncheckedUpdateWithoutHandledMessagesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FoodItemCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput> | FoodItemCreateWithoutCategoryInput[] | FoodItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FoodItemCreateOrConnectWithoutCategoryInput | FoodItemCreateOrConnectWithoutCategoryInput[]
    createMany?: FoodItemCreateManyCategoryInputEnvelope
    connect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
  }

  export type FoodItemUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput> | FoodItemCreateWithoutCategoryInput[] | FoodItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FoodItemCreateOrConnectWithoutCategoryInput | FoodItemCreateOrConnectWithoutCategoryInput[]
    createMany?: FoodItemCreateManyCategoryInputEnvelope
    connect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
  }

  export type FoodItemUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput> | FoodItemCreateWithoutCategoryInput[] | FoodItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FoodItemCreateOrConnectWithoutCategoryInput | FoodItemCreateOrConnectWithoutCategoryInput[]
    upsert?: FoodItemUpsertWithWhereUniqueWithoutCategoryInput | FoodItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FoodItemCreateManyCategoryInputEnvelope
    set?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    disconnect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    delete?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    connect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    update?: FoodItemUpdateWithWhereUniqueWithoutCategoryInput | FoodItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FoodItemUpdateManyWithWhereWithoutCategoryInput | FoodItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FoodItemScalarWhereInput | FoodItemScalarWhereInput[]
  }

  export type FoodItemUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput> | FoodItemCreateWithoutCategoryInput[] | FoodItemUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: FoodItemCreateOrConnectWithoutCategoryInput | FoodItemCreateOrConnectWithoutCategoryInput[]
    upsert?: FoodItemUpsertWithWhereUniqueWithoutCategoryInput | FoodItemUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: FoodItemCreateManyCategoryInputEnvelope
    set?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    disconnect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    delete?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    connect?: FoodItemWhereUniqueInput | FoodItemWhereUniqueInput[]
    update?: FoodItemUpdateWithWhereUniqueWithoutCategoryInput | FoodItemUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: FoodItemUpdateManyWithWhereWithoutCategoryInput | FoodItemUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: FoodItemScalarWhereInput | FoodItemScalarWhereInput[]
  }

  export type FoodCategoryCreateNestedOneWithoutItemsInput = {
    create?: XOR<FoodCategoryCreateWithoutItemsInput, FoodCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutItemsInput
    connect?: FoodCategoryWhereUniqueInput
  }

  export type FoodImageCreateNestedManyWithoutFoodItemInput = {
    create?: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput> | FoodImageCreateWithoutFoodItemInput[] | FoodImageUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: FoodImageCreateOrConnectWithoutFoodItemInput | FoodImageCreateOrConnectWithoutFoodItemInput[]
    createMany?: FoodImageCreateManyFoodItemInputEnvelope
    connect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutFoodItemInput = {
    create?: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput> | OrderItemCreateWithoutFoodItemInput[] | OrderItemUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutFoodItemInput | OrderItemCreateOrConnectWithoutFoodItemInput[]
    createMany?: OrderItemCreateManyFoodItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type FoodImageUncheckedCreateNestedManyWithoutFoodItemInput = {
    create?: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput> | FoodImageCreateWithoutFoodItemInput[] | FoodImageUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: FoodImageCreateOrConnectWithoutFoodItemInput | FoodImageCreateOrConnectWithoutFoodItemInput[]
    createMany?: FoodImageCreateManyFoodItemInputEnvelope
    connect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutFoodItemInput = {
    create?: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput> | OrderItemCreateWithoutFoodItemInput[] | OrderItemUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutFoodItemInput | OrderItemCreateOrConnectWithoutFoodItemInput[]
    createMany?: OrderItemCreateManyFoodItemInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FoodCategoryUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<FoodCategoryCreateWithoutItemsInput, FoodCategoryUncheckedCreateWithoutItemsInput>
    connectOrCreate?: FoodCategoryCreateOrConnectWithoutItemsInput
    upsert?: FoodCategoryUpsertWithoutItemsInput
    connect?: FoodCategoryWhereUniqueInput
    update?: XOR<XOR<FoodCategoryUpdateToOneWithWhereWithoutItemsInput, FoodCategoryUpdateWithoutItemsInput>, FoodCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type FoodImageUpdateManyWithoutFoodItemNestedInput = {
    create?: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput> | FoodImageCreateWithoutFoodItemInput[] | FoodImageUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: FoodImageCreateOrConnectWithoutFoodItemInput | FoodImageCreateOrConnectWithoutFoodItemInput[]
    upsert?: FoodImageUpsertWithWhereUniqueWithoutFoodItemInput | FoodImageUpsertWithWhereUniqueWithoutFoodItemInput[]
    createMany?: FoodImageCreateManyFoodItemInputEnvelope
    set?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    disconnect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    delete?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    connect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    update?: FoodImageUpdateWithWhereUniqueWithoutFoodItemInput | FoodImageUpdateWithWhereUniqueWithoutFoodItemInput[]
    updateMany?: FoodImageUpdateManyWithWhereWithoutFoodItemInput | FoodImageUpdateManyWithWhereWithoutFoodItemInput[]
    deleteMany?: FoodImageScalarWhereInput | FoodImageScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutFoodItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput> | OrderItemCreateWithoutFoodItemInput[] | OrderItemUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutFoodItemInput | OrderItemCreateOrConnectWithoutFoodItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutFoodItemInput | OrderItemUpsertWithWhereUniqueWithoutFoodItemInput[]
    createMany?: OrderItemCreateManyFoodItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutFoodItemInput | OrderItemUpdateWithWhereUniqueWithoutFoodItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutFoodItemInput | OrderItemUpdateManyWithWhereWithoutFoodItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type FoodImageUncheckedUpdateManyWithoutFoodItemNestedInput = {
    create?: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput> | FoodImageCreateWithoutFoodItemInput[] | FoodImageUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: FoodImageCreateOrConnectWithoutFoodItemInput | FoodImageCreateOrConnectWithoutFoodItemInput[]
    upsert?: FoodImageUpsertWithWhereUniqueWithoutFoodItemInput | FoodImageUpsertWithWhereUniqueWithoutFoodItemInput[]
    createMany?: FoodImageCreateManyFoodItemInputEnvelope
    set?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    disconnect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    delete?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    connect?: FoodImageWhereUniqueInput | FoodImageWhereUniqueInput[]
    update?: FoodImageUpdateWithWhereUniqueWithoutFoodItemInput | FoodImageUpdateWithWhereUniqueWithoutFoodItemInput[]
    updateMany?: FoodImageUpdateManyWithWhereWithoutFoodItemInput | FoodImageUpdateManyWithWhereWithoutFoodItemInput[]
    deleteMany?: FoodImageScalarWhereInput | FoodImageScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutFoodItemNestedInput = {
    create?: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput> | OrderItemCreateWithoutFoodItemInput[] | OrderItemUncheckedCreateWithoutFoodItemInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutFoodItemInput | OrderItemCreateOrConnectWithoutFoodItemInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutFoodItemInput | OrderItemUpsertWithWhereUniqueWithoutFoodItemInput[]
    createMany?: OrderItemCreateManyFoodItemInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutFoodItemInput | OrderItemUpdateWithWhereUniqueWithoutFoodItemInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutFoodItemInput | OrderItemUpdateManyWithWhereWithoutFoodItemInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type FoodItemCreateNestedOneWithoutImagesInput = {
    create?: XOR<FoodItemCreateWithoutImagesInput, FoodItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: FoodItemCreateOrConnectWithoutImagesInput
    connect?: FoodItemWhereUniqueInput
  }

  export type FoodItemUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<FoodItemCreateWithoutImagesInput, FoodItemUncheckedCreateWithoutImagesInput>
    connectOrCreate?: FoodItemCreateOrConnectWithoutImagesInput
    upsert?: FoodItemUpsertWithoutImagesInput
    connect?: FoodItemWhereUniqueInput
    update?: XOR<XOR<FoodItemUpdateToOneWithWhereWithoutImagesInput, FoodItemUpdateWithoutImagesInput>, FoodItemUncheckedUpdateWithoutImagesInput>
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersInput
    connect?: AddressWhereUniqueInput
  }

  export type OrderStatusHistoryCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput> | OrderStatusHistoryCreateWithoutOrderInput[] | OrderStatusHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutOrderInput | OrderStatusHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusHistoryCreateManyOrderInputEnvelope
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutSalesmanOrdersInput = {
    create?: XOR<UserCreateWithoutSalesmanOrdersInput, UserUncheckedCreateWithoutSalesmanOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesmanOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDriverOrdersInput = {
    create?: XOR<UserCreateWithoutDriverOrdersInput, UserUncheckedCreateWithoutDriverOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type DeliveryProofCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutOrderInput
    connect?: DeliveryProofWhereUniqueInput
  }

  export type OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput> | OrderStatusHistoryCreateWithoutOrderInput[] | OrderStatusHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutOrderInput | OrderStatusHistoryCreateOrConnectWithoutOrderInput[]
    createMany?: OrderStatusHistoryCreateManyOrderInputEnvelope
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    connect?: PaymentWhereUniqueInput
  }

  export type DeliveryProofUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutOrderInput
    connect?: DeliveryProofWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type AddressUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AddressCreateOrConnectWithoutOrdersInput
    upsert?: AddressUpsertWithoutOrdersInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutOrdersInput, AddressUpdateWithoutOrdersInput>, AddressUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderStatusHistoryUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput> | OrderStatusHistoryCreateWithoutOrderInput[] | OrderStatusHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutOrderInput | OrderStatusHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderStatusHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusHistoryCreateManyOrderInputEnvelope
    set?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    disconnect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    delete?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    update?: OrderStatusHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderStatusHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusHistoryUpdateManyWithWhereWithoutOrderInput | OrderStatusHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type UserUpdateOneWithoutSalesmanOrdersNestedInput = {
    create?: XOR<UserCreateWithoutSalesmanOrdersInput, UserUncheckedCreateWithoutSalesmanOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesmanOrdersInput
    upsert?: UserUpsertWithoutSalesmanOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesmanOrdersInput, UserUpdateWithoutSalesmanOrdersInput>, UserUncheckedUpdateWithoutSalesmanOrdersInput>
  }

  export type UserUpdateOneWithoutDriverOrdersNestedInput = {
    create?: XOR<UserCreateWithoutDriverOrdersInput, UserUncheckedCreateWithoutDriverOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverOrdersInput
    upsert?: UserUpsertWithoutDriverOrdersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriverOrdersInput, UserUpdateWithoutDriverOrdersInput>, UserUncheckedUpdateWithoutDriverOrdersInput>
  }

  export type PaymentUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryProofUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutOrderInput
    upsert?: DeliveryProofUpsertWithoutOrderInput
    disconnect?: DeliveryProofWhereInput | boolean
    delete?: DeliveryProofWhereInput | boolean
    connect?: DeliveryProofWhereUniqueInput
    update?: XOR<XOR<DeliveryProofUpdateToOneWithWhereWithoutOrderInput, DeliveryProofUpdateWithoutOrderInput>, DeliveryProofUncheckedUpdateWithoutOrderInput>
  }

  export type OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput> | OrderStatusHistoryCreateWithoutOrderInput[] | OrderStatusHistoryUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderStatusHistoryCreateOrConnectWithoutOrderInput | OrderStatusHistoryCreateOrConnectWithoutOrderInput[]
    upsert?: OrderStatusHistoryUpsertWithWhereUniqueWithoutOrderInput | OrderStatusHistoryUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderStatusHistoryCreateManyOrderInputEnvelope
    set?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    disconnect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    delete?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    connect?: OrderStatusHistoryWhereUniqueInput | OrderStatusHistoryWhereUniqueInput[]
    update?: OrderStatusHistoryUpdateWithWhereUniqueWithoutOrderInput | OrderStatusHistoryUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderStatusHistoryUpdateManyWithWhereWithoutOrderInput | OrderStatusHistoryUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutOrderInput
    upsert?: PaymentUpsertWithoutOrderInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutOrderInput, PaymentUpdateWithoutOrderInput>, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
    connectOrCreate?: DeliveryProofCreateOrConnectWithoutOrderInput
    upsert?: DeliveryProofUpsertWithoutOrderInput
    disconnect?: DeliveryProofWhereInput | boolean
    delete?: DeliveryProofWhereInput | boolean
    connect?: DeliveryProofWhereUniqueInput
    update?: XOR<XOR<DeliveryProofUpdateToOneWithWhereWithoutOrderInput, DeliveryProofUpdateWithoutOrderInput>, DeliveryProofUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type FoodItemCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<FoodItemCreateWithoutOrderItemsInput, FoodItemUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: FoodItemCreateOrConnectWithoutOrderItemsInput
    connect?: FoodItemWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutItemsInput
    upsert?: OrderUpsertWithoutItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutItemsInput, OrderUpdateWithoutItemsInput>, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type FoodItemUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<FoodItemCreateWithoutOrderItemsInput, FoodItemUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: FoodItemCreateOrConnectWithoutOrderItemsInput
    upsert?: FoodItemUpsertWithoutOrderItemsInput
    connect?: FoodItemWhereUniqueInput
    update?: XOR<XOR<FoodItemUpdateToOneWithWhereWithoutOrderItemsInput, FoodItemUpdateWithoutOrderItemsInput>, FoodItemUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderCreateNestedOneWithoutStatusHistoryInput = {
    create?: XOR<OrderCreateWithoutStatusHistoryInput, OrderUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusHistoryInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrderStatusChangesInput = {
    create?: XOR<UserCreateWithoutOrderStatusChangesInput, UserUncheckedCreateWithoutOrderStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderStatusChangesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableEnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus | null
  }

  export type OrderUpdateOneRequiredWithoutStatusHistoryNestedInput = {
    create?: XOR<OrderCreateWithoutStatusHistoryInput, OrderUncheckedCreateWithoutStatusHistoryInput>
    connectOrCreate?: OrderCreateOrConnectWithoutStatusHistoryInput
    upsert?: OrderUpsertWithoutStatusHistoryInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutStatusHistoryInput, OrderUpdateWithoutStatusHistoryInput>, OrderUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type UserUpdateOneWithoutOrderStatusChangesNestedInput = {
    create?: XOR<UserCreateWithoutOrderStatusChangesInput, UserUncheckedCreateWithoutOrderStatusChangesInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrderStatusChangesInput
    upsert?: UserUpsertWithoutOrderStatusChangesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrderStatusChangesInput, UserUpdateWithoutOrderStatusChangesInput>, UserUncheckedUpdateWithoutOrderStatusChangesInput>
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderCreateNestedOneWithoutDeliveryProofInput = {
    create?: XOR<OrderCreateWithoutDeliveryProofInput, OrderUncheckedCreateWithoutDeliveryProofInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryProofInput
    connect?: OrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeliveryProofsInput = {
    create?: XOR<UserCreateWithoutDeliveryProofsInput, UserUncheckedCreateWithoutDeliveryProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryProofsInput
    connect?: UserWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutDeliveryProofNestedInput = {
    create?: XOR<OrderCreateWithoutDeliveryProofInput, OrderUncheckedCreateWithoutDeliveryProofInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDeliveryProofInput
    upsert?: OrderUpsertWithoutDeliveryProofInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDeliveryProofInput, OrderUpdateWithoutDeliveryProofInput>, OrderUncheckedUpdateWithoutDeliveryProofInput>
  }

  export type UserUpdateOneWithoutDeliveryProofsNestedInput = {
    create?: XOR<UserCreateWithoutDeliveryProofsInput, UserUncheckedCreateWithoutDeliveryProofsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeliveryProofsInput
    upsert?: UserUpsertWithoutDeliveryProofsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeliveryProofsInput, UserUpdateWithoutDeliveryProofsInput>, UserUncheckedUpdateWithoutDeliveryProofsInput>
  }

  export type UserCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type AddressCreateNestedOneWithoutServiceRequestsInput = {
    create?: XOR<AddressCreateWithoutServiceRequestsInput, AddressUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutServiceRequestsInput
    connect?: AddressWhereUniqueInput
  }

  export type ServicePhotoCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput> | ServicePhotoCreateWithoutServiceInput[] | ServicePhotoUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePhotoCreateOrConnectWithoutServiceInput | ServicePhotoCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePhotoCreateManyServiceInputEnvelope
    connect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
  }

  export type ServiceAssignmentCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput> | ServiceAssignmentCreateWithoutServiceInput[] | ServiceAssignmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutServiceInput | ServiceAssignmentCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAssignmentCreateManyServiceInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type ServiceRatingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type ServicePhotoUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput> | ServicePhotoCreateWithoutServiceInput[] | ServicePhotoUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePhotoCreateOrConnectWithoutServiceInput | ServicePhotoCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePhotoCreateManyServiceInputEnvelope
    connect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
  }

  export type ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput> | ServiceAssignmentCreateWithoutServiceInput[] | ServiceAssignmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutServiceInput | ServiceAssignmentCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceAssignmentCreateManyServiceInputEnvelope
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
  }

  export type ServiceRatingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumServiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ServiceStatus
  }

  export type EnumServicePriorityFieldUpdateOperationsInput = {
    set?: $Enums.ServicePriority
  }

  export type UserUpdateOneRequiredWithoutServiceRequestsNestedInput = {
    create?: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceRequestsInput
    upsert?: UserUpsertWithoutServiceRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceRequestsInput, UserUpdateWithoutServiceRequestsInput>, UserUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type AddressUpdateOneWithoutServiceRequestsNestedInput = {
    create?: XOR<AddressCreateWithoutServiceRequestsInput, AddressUncheckedCreateWithoutServiceRequestsInput>
    connectOrCreate?: AddressCreateOrConnectWithoutServiceRequestsInput
    upsert?: AddressUpsertWithoutServiceRequestsInput
    disconnect?: AddressWhereInput | boolean
    delete?: AddressWhereInput | boolean
    connect?: AddressWhereUniqueInput
    update?: XOR<XOR<AddressUpdateToOneWithWhereWithoutServiceRequestsInput, AddressUpdateWithoutServiceRequestsInput>, AddressUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type ServicePhotoUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput> | ServicePhotoCreateWithoutServiceInput[] | ServicePhotoUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePhotoCreateOrConnectWithoutServiceInput | ServicePhotoCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePhotoUpsertWithWhereUniqueWithoutServiceInput | ServicePhotoUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePhotoCreateManyServiceInputEnvelope
    set?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    disconnect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    delete?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    connect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    update?: ServicePhotoUpdateWithWhereUniqueWithoutServiceInput | ServicePhotoUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePhotoUpdateManyWithWhereWithoutServiceInput | ServicePhotoUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePhotoScalarWhereInput | ServicePhotoScalarWhereInput[]
  }

  export type ServiceAssignmentUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput> | ServiceAssignmentCreateWithoutServiceInput[] | ServiceAssignmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutServiceInput | ServiceAssignmentCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutServiceInput | ServiceAssignmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAssignmentCreateManyServiceInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutServiceInput | ServiceAssignmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutServiceInput | ServiceAssignmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type ServiceRatingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutServiceInput | ServiceRatingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutServiceInput | ServiceRatingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutServiceInput | ServiceRatingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput> | ServicePhotoCreateWithoutServiceInput[] | ServicePhotoUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePhotoCreateOrConnectWithoutServiceInput | ServicePhotoCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePhotoUpsertWithWhereUniqueWithoutServiceInput | ServicePhotoUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePhotoCreateManyServiceInputEnvelope
    set?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    disconnect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    delete?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    connect?: ServicePhotoWhereUniqueInput | ServicePhotoWhereUniqueInput[]
    update?: ServicePhotoUpdateWithWhereUniqueWithoutServiceInput | ServicePhotoUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePhotoUpdateManyWithWhereWithoutServiceInput | ServicePhotoUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePhotoScalarWhereInput | ServicePhotoScalarWhereInput[]
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput> | ServiceAssignmentCreateWithoutServiceInput[] | ServiceAssignmentUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceAssignmentCreateOrConnectWithoutServiceInput | ServiceAssignmentCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceAssignmentUpsertWithWhereUniqueWithoutServiceInput | ServiceAssignmentUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceAssignmentCreateManyServiceInputEnvelope
    set?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    disconnect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    delete?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    connect?: ServiceAssignmentWhereUniqueInput | ServiceAssignmentWhereUniqueInput[]
    update?: ServiceAssignmentUpdateWithWhereUniqueWithoutServiceInput | ServiceAssignmentUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceAssignmentUpdateManyWithWhereWithoutServiceInput | ServiceAssignmentUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
  }

  export type ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutServiceInput | ServiceRatingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutServiceInput | ServiceRatingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutServiceInput | ServiceRatingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServiceRequestCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<ServiceRequestCreateWithoutAssignmentsInput, ServiceRequestUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAssignmentsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStaffServicesInput = {
    create?: XOR<UserCreateWithoutStaffServicesInput, UserUncheckedCreateWithoutStaffServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffServicesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServiceAssignmentsInput = {
    create?: XOR<UserCreateWithoutServiceAssignmentsInput, UserUncheckedCreateWithoutServiceAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceAssignmentsInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceRequestUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutAssignmentsInput, ServiceRequestUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutAssignmentsInput
    upsert?: ServiceRequestUpsertWithoutAssignmentsInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutAssignmentsInput, ServiceRequestUpdateWithoutAssignmentsInput>, ServiceRequestUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserUpdateOneRequiredWithoutStaffServicesNestedInput = {
    create?: XOR<UserCreateWithoutStaffServicesInput, UserUncheckedCreateWithoutStaffServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffServicesInput
    upsert?: UserUpsertWithoutStaffServicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffServicesInput, UserUpdateWithoutStaffServicesInput>, UserUncheckedUpdateWithoutStaffServicesInput>
  }

  export type UserUpdateOneWithoutServiceAssignmentsNestedInput = {
    create?: XOR<UserCreateWithoutServiceAssignmentsInput, UserUncheckedCreateWithoutServiceAssignmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutServiceAssignmentsInput
    upsert?: UserUpsertWithoutServiceAssignmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServiceAssignmentsInput, UserUpdateWithoutServiceAssignmentsInput>, UserUncheckedUpdateWithoutServiceAssignmentsInput>
  }

  export type ServiceRequestCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ServiceRequestCreateWithoutPhotosInput, ServiceRequestUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPhotosInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type ServiceRequestUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutPhotosInput, ServiceRequestUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutPhotosInput
    upsert?: ServiceRequestUpsertWithoutPhotosInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutPhotosInput, ServiceRequestUpdateWithoutPhotosInput>, ServiceRequestUncheckedUpdateWithoutPhotosInput>
  }

  export type ServiceRequestCreateNestedOneWithoutRatingsInput = {
    create?: XOR<ServiceRequestCreateWithoutRatingsInput, ServiceRequestUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutRatingsInput
    connect?: ServiceRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRatedServicesInput = {
    create?: XOR<UserCreateWithoutRatedServicesInput, UserUncheckedCreateWithoutRatedServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatedServicesInput
    connect?: UserWhereUniqueInput
  }

  export type ServiceRequestUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<ServiceRequestCreateWithoutRatingsInput, ServiceRequestUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: ServiceRequestCreateOrConnectWithoutRatingsInput
    upsert?: ServiceRequestUpsertWithoutRatingsInput
    connect?: ServiceRequestWhereUniqueInput
    update?: XOR<XOR<ServiceRequestUpdateToOneWithWhereWithoutRatingsInput, ServiceRequestUpdateWithoutRatingsInput>, ServiceRequestUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneWithoutRatedServicesNestedInput = {
    create?: XOR<UserCreateWithoutRatedServicesInput, UserUncheckedCreateWithoutRatedServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatedServicesInput
    upsert?: UserUpsertWithoutRatedServicesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatedServicesInput, UserUpdateWithoutRatedServicesInput>, UserUncheckedUpdateWithoutRatedServicesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuditEntityType
  }

  export type EnumAuditActionFieldUpdateOperationsInput = {
    set?: $Enums.AuditAction
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableFilter<$PrismaModel> | $Enums.OrderStatus | null
  }

  export type NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumOrderStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumServiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusFilter<$PrismaModel> | $Enums.ServiceStatus
  }

  export type NestedEnumServicePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ServicePriority | EnumServicePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumServicePriorityFilter<$PrismaModel> | $Enums.ServicePriority
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceStatus | EnumServiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceStatus[] | ListEnumServiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ServiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceStatusFilter<$PrismaModel>
    _max?: NestedEnumServiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumServicePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServicePriority | EnumServicePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServicePriority[] | ListEnumServicePriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumServicePriorityWithAggregatesFilter<$PrismaModel> | $Enums.ServicePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServicePriorityFilter<$PrismaModel>
    _max?: NestedEnumServicePriorityFilter<$PrismaModel>
  }

  export type NestedEnumAuditEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeFilter<$PrismaModel> | $Enums.AuditEntityType
  }

  export type NestedEnumAuditActionFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionFilter<$PrismaModel> | $Enums.AuditAction
  }

  export type NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditEntityType | EnumAuditEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditEntityType[] | ListEnumAuditEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuditEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumAuditEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumAuditActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditAction | EnumAuditActionFieldRefInput<$PrismaModel>
    in?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditAction[] | ListEnumAuditActionFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditActionWithAggregatesFilter<$PrismaModel> | $Enums.AuditAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditActionFilter<$PrismaModel>
    _max?: NestedEnumAuditActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AddressCreateWithoutUserInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutDeliveryAddressInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: number
    orderNumber: string
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutCustomerInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    address?: AddressCreateNestedOneWithoutServiceRequestsInput
    photos?: ServicePhotoCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateWithoutCustomerInput = {
    id?: number
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ServicePhotoUncheckedCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestCreateOrConnectWithoutCustomerInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceRequestCreateManyCustomerInputEnvelope = {
    data: ServiceRequestCreateManyCustomerInput | ServiceRequestCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutSalesmanInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSalesmanInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSalesmanInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput>
  }

  export type OrderCreateManySalesmanInputEnvelope = {
    data: OrderCreateManySalesmanInput | OrderCreateManySalesmanInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutDriverInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDriverInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDriverInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput>
  }

  export type OrderCreateManyDriverInputEnvelope = {
    data: OrderCreateManyDriverInput | OrderCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAssignmentCreateWithoutStaffInput = {
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
    service: ServiceRequestCreateNestedOneWithoutAssignmentsInput
    assignedBy?: UserCreateNestedOneWithoutServiceAssignmentsInput
  }

  export type ServiceAssignmentUncheckedCreateWithoutStaffInput = {
    id?: number
    serviceId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceAssignmentCreateOrConnectWithoutStaffInput = {
    where: ServiceAssignmentWhereUniqueInput
    create: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput>
  }

  export type ServiceAssignmentCreateManyStaffInputEnvelope = {
    data: ServiceAssignmentCreateManyStaffInput | ServiceAssignmentCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ContactMessageCreateWithoutUserInput = {
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    handledBy?: UserCreateNestedOneWithoutHandledMessagesInput
  }

  export type ContactMessageUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    handledById?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ContactMessageCreateOrConnectWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    create: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput>
  }

  export type ContactMessageCreateManyUserInputEnvelope = {
    data: ContactMessageCreateManyUserInput | ContactMessageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ContactMessageCreateWithoutHandledByInput = {
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutContactMessagesInput
  }

  export type ContactMessageUncheckedCreateWithoutHandledByInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    userId?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ContactMessageCreateOrConnectWithoutHandledByInput = {
    where: ContactMessageWhereUniqueInput
    create: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput>
  }

  export type ContactMessageCreateManyHandledByInputEnvelope = {
    data: ContactMessageCreateManyHandledByInput | ContactMessageCreateManyHandledByInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRatingCreateWithoutCustomerInput = {
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
    service: ServiceRequestCreateNestedOneWithoutRatingsInput
    staff?: UserCreateNestedOneWithoutRatedServicesInput
  }

  export type ServiceRatingUncheckedCreateWithoutCustomerInput = {
    id?: number
    serviceId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingCreateOrConnectWithoutCustomerInput = {
    where: ServiceRatingWhereUniqueInput
    create: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceRatingCreateManyCustomerInputEnvelope = {
    data: ServiceRatingCreateManyCustomerInput | ServiceRatingCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRatingCreateWithoutStaffInput = {
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
    service: ServiceRequestCreateNestedOneWithoutRatingsInput
    customer: UserCreateNestedOneWithoutRatingsInput
  }

  export type ServiceRatingUncheckedCreateWithoutStaffInput = {
    id?: number
    serviceId: number
    customerId: number
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingCreateOrConnectWithoutStaffInput = {
    where: ServiceRatingWhereUniqueInput
    create: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput>
  }

  export type ServiceRatingCreateManyStaffInputEnvelope = {
    data: ServiceRatingCreateManyStaffInput | ServiceRatingCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutActorInput = {
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutActorInput = {
    id?: number
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogCreateManyActorInputEnvelope = {
    data: AuditLogCreateManyActorInput | AuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type OrderStatusHistoryCreateWithoutChangedByInput = {
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    note?: string | null
    order: OrderCreateNestedOneWithoutStatusHistoryInput
  }

  export type OrderStatusHistoryUncheckedCreateWithoutChangedByInput = {
    id?: number
    orderId: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    note?: string | null
  }

  export type OrderStatusHistoryCreateOrConnectWithoutChangedByInput = {
    where: OrderStatusHistoryWhereUniqueInput
    create: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type OrderStatusHistoryCreateManyChangedByInputEnvelope = {
    data: OrderStatusHistoryCreateManyChangedByInput | OrderStatusHistoryCreateManyChangedByInput[]
    skipDuplicates?: boolean
  }

  export type DeliveryProofCreateWithoutDriverInput = {
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    order: OrderCreateNestedOneWithoutDeliveryProofInput
  }

  export type DeliveryProofUncheckedCreateWithoutDriverInput = {
    id?: number
    orderId: number
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
  }

  export type DeliveryProofCreateOrConnectWithoutDriverInput = {
    where: DeliveryProofWhereUniqueInput
    create: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput>
  }

  export type DeliveryProofCreateManyDriverInputEnvelope = {
    data: DeliveryProofCreateManyDriverInput | DeliveryProofCreateManyDriverInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAssignmentCreateWithoutAssignedByInput = {
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
    service: ServiceRequestCreateNestedOneWithoutAssignmentsInput
    staff: UserCreateNestedOneWithoutStaffServicesInput
  }

  export type ServiceAssignmentUncheckedCreateWithoutAssignedByInput = {
    id?: number
    serviceId: number
    staffId: number
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceAssignmentCreateOrConnectWithoutAssignedByInput = {
    where: ServiceAssignmentWhereUniqueInput
    create: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ServiceAssignmentCreateManyAssignedByInputEnvelope = {
    data: ServiceAssignmentCreateManyAssignedByInput | ServiceAssignmentCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: IntFilter<"Address"> | number
    userId?: IntFilter<"Address"> | number
    label?: StringNullableFilter<"Address"> | string | null
    line1?: StringFilter<"Address"> | string
    line2?: StringNullableFilter<"Address"> | string | null
    city?: StringFilter<"Address"> | string
    postalCode?: StringFilter<"Address"> | string
    country?: StringFilter<"Address"> | string
    isDefault?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: IntFilter<"Order"> | number
    orderNumber?: StringFilter<"Order"> | string
    customerId?: IntFilter<"Order"> | number
    deliveryAddressId?: IntNullableFilter<"Order"> | number | null
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    notes?: StringNullableFilter<"Order"> | string | null
    imageUrl?: StringNullableFilter<"Order"> | string | null
    totalPrice?: DecimalFilter<"Order"> | Decimal | DecimalJsLike | number | string
    salesmanId?: IntNullableFilter<"Order"> | number | null
    driverId?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutCustomerInput, ServiceRequestUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServiceRequestCreateWithoutCustomerInput, ServiceRequestUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutCustomerInput, ServiceRequestUncheckedUpdateWithoutCustomerInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutCustomerInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServiceRequestScalarWhereInput = {
    AND?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    OR?: ServiceRequestScalarWhereInput[]
    NOT?: ServiceRequestScalarWhereInput | ServiceRequestScalarWhereInput[]
    id?: IntFilter<"ServiceRequest"> | number
    requestNumber?: StringFilter<"ServiceRequest"> | string
    customerId?: IntFilter<"ServiceRequest"> | number
    type?: EnumServiceTypeFilter<"ServiceRequest"> | $Enums.ServiceType
    status?: EnumServiceStatusFilter<"ServiceRequest"> | $Enums.ServiceStatus
    priority?: EnumServicePriorityFilter<"ServiceRequest"> | $Enums.ServicePriority
    title?: StringFilter<"ServiceRequest"> | string
    description?: StringFilter<"ServiceRequest"> | string
    addressId?: IntNullableFilter<"ServiceRequest"> | number | null
    requestedDate?: DateTimeNullableFilter<"ServiceRequest"> | Date | string | null
    notes?: StringNullableFilter<"ServiceRequest"> | string | null
    createdAt?: DateTimeFilter<"ServiceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceRequest"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutSalesmanInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutSalesmanInput, OrderUncheckedUpdateWithoutSalesmanInput>
    create: XOR<OrderCreateWithoutSalesmanInput, OrderUncheckedCreateWithoutSalesmanInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutSalesmanInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutSalesmanInput, OrderUncheckedUpdateWithoutSalesmanInput>
  }

  export type OrderUpdateManyWithWhereWithoutSalesmanInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutSalesmanInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutDriverInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDriverInput, OrderUncheckedUpdateWithoutDriverInput>
    create: XOR<OrderCreateWithoutDriverInput, OrderUncheckedCreateWithoutDriverInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDriverInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDriverInput, OrderUncheckedUpdateWithoutDriverInput>
  }

  export type OrderUpdateManyWithWhereWithoutDriverInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutDriverInput>
  }

  export type ServiceAssignmentUpsertWithWhereUniqueWithoutStaffInput = {
    where: ServiceAssignmentWhereUniqueInput
    update: XOR<ServiceAssignmentUpdateWithoutStaffInput, ServiceAssignmentUncheckedUpdateWithoutStaffInput>
    create: XOR<ServiceAssignmentCreateWithoutStaffInput, ServiceAssignmentUncheckedCreateWithoutStaffInput>
  }

  export type ServiceAssignmentUpdateWithWhereUniqueWithoutStaffInput = {
    where: ServiceAssignmentWhereUniqueInput
    data: XOR<ServiceAssignmentUpdateWithoutStaffInput, ServiceAssignmentUncheckedUpdateWithoutStaffInput>
  }

  export type ServiceAssignmentUpdateManyWithWhereWithoutStaffInput = {
    where: ServiceAssignmentScalarWhereInput
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyWithoutStaffInput>
  }

  export type ServiceAssignmentScalarWhereInput = {
    AND?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
    OR?: ServiceAssignmentScalarWhereInput[]
    NOT?: ServiceAssignmentScalarWhereInput | ServiceAssignmentScalarWhereInput[]
    id?: IntFilter<"ServiceAssignment"> | number
    serviceId?: IntFilter<"ServiceAssignment"> | number
    staffId?: IntFilter<"ServiceAssignment"> | number
    assignedById?: IntNullableFilter<"ServiceAssignment"> | number | null
    assignedAt?: DateTimeFilter<"ServiceAssignment"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"ServiceAssignment"> | Date | string | null
    status?: EnumServiceStatusFilter<"ServiceAssignment"> | $Enums.ServiceStatus
    notes?: StringNullableFilter<"ServiceAssignment"> | string | null
  }

  export type ContactMessageUpsertWithWhereUniqueWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    update: XOR<ContactMessageUpdateWithoutUserInput, ContactMessageUncheckedUpdateWithoutUserInput>
    create: XOR<ContactMessageCreateWithoutUserInput, ContactMessageUncheckedCreateWithoutUserInput>
  }

  export type ContactMessageUpdateWithWhereUniqueWithoutUserInput = {
    where: ContactMessageWhereUniqueInput
    data: XOR<ContactMessageUpdateWithoutUserInput, ContactMessageUncheckedUpdateWithoutUserInput>
  }

  export type ContactMessageUpdateManyWithWhereWithoutUserInput = {
    where: ContactMessageScalarWhereInput
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyWithoutUserInput>
  }

  export type ContactMessageScalarWhereInput = {
    AND?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
    OR?: ContactMessageScalarWhereInput[]
    NOT?: ContactMessageScalarWhereInput | ContactMessageScalarWhereInput[]
    id?: IntFilter<"ContactMessage"> | number
    name?: StringFilter<"ContactMessage"> | string
    email?: StringFilter<"ContactMessage"> | string
    phone?: StringNullableFilter<"ContactMessage"> | string | null
    subject?: StringFilter<"ContactMessage"> | string
    message?: StringFilter<"ContactMessage"> | string
    userId?: IntNullableFilter<"ContactMessage"> | number | null
    handledById?: IntNullableFilter<"ContactMessage"> | number | null
    handledAt?: DateTimeNullableFilter<"ContactMessage"> | Date | string | null
    status?: StringFilter<"ContactMessage"> | string
    createdAt?: DateTimeFilter<"ContactMessage"> | Date | string
  }

  export type ContactMessageUpsertWithWhereUniqueWithoutHandledByInput = {
    where: ContactMessageWhereUniqueInput
    update: XOR<ContactMessageUpdateWithoutHandledByInput, ContactMessageUncheckedUpdateWithoutHandledByInput>
    create: XOR<ContactMessageCreateWithoutHandledByInput, ContactMessageUncheckedCreateWithoutHandledByInput>
  }

  export type ContactMessageUpdateWithWhereUniqueWithoutHandledByInput = {
    where: ContactMessageWhereUniqueInput
    data: XOR<ContactMessageUpdateWithoutHandledByInput, ContactMessageUncheckedUpdateWithoutHandledByInput>
  }

  export type ContactMessageUpdateManyWithWhereWithoutHandledByInput = {
    where: ContactMessageScalarWhereInput
    data: XOR<ContactMessageUpdateManyMutationInput, ContactMessageUncheckedUpdateManyWithoutHandledByInput>
  }

  export type ServiceRatingUpsertWithWhereUniqueWithoutCustomerInput = {
    where: ServiceRatingWhereUniqueInput
    update: XOR<ServiceRatingUpdateWithoutCustomerInput, ServiceRatingUncheckedUpdateWithoutCustomerInput>
    create: XOR<ServiceRatingCreateWithoutCustomerInput, ServiceRatingUncheckedCreateWithoutCustomerInput>
  }

  export type ServiceRatingUpdateWithWhereUniqueWithoutCustomerInput = {
    where: ServiceRatingWhereUniqueInput
    data: XOR<ServiceRatingUpdateWithoutCustomerInput, ServiceRatingUncheckedUpdateWithoutCustomerInput>
  }

  export type ServiceRatingUpdateManyWithWhereWithoutCustomerInput = {
    where: ServiceRatingScalarWhereInput
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyWithoutCustomerInput>
  }

  export type ServiceRatingScalarWhereInput = {
    AND?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
    OR?: ServiceRatingScalarWhereInput[]
    NOT?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
    id?: IntFilter<"ServiceRating"> | number
    serviceId?: IntFilter<"ServiceRating"> | number
    customerId?: IntFilter<"ServiceRating"> | number
    staffId?: IntNullableFilter<"ServiceRating"> | number | null
    score?: IntFilter<"ServiceRating"> | number
    review?: StringNullableFilter<"ServiceRating"> | string | null
    wouldRecommend?: BoolFilter<"ServiceRating"> | boolean
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
  }

  export type ServiceRatingUpsertWithWhereUniqueWithoutStaffInput = {
    where: ServiceRatingWhereUniqueInput
    update: XOR<ServiceRatingUpdateWithoutStaffInput, ServiceRatingUncheckedUpdateWithoutStaffInput>
    create: XOR<ServiceRatingCreateWithoutStaffInput, ServiceRatingUncheckedCreateWithoutStaffInput>
  }

  export type ServiceRatingUpdateWithWhereUniqueWithoutStaffInput = {
    where: ServiceRatingWhereUniqueInput
    data: XOR<ServiceRatingUpdateWithoutStaffInput, ServiceRatingUncheckedUpdateWithoutStaffInput>
  }

  export type ServiceRatingUpdateManyWithWhereWithoutStaffInput = {
    where: ServiceRatingScalarWhereInput
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyWithoutStaffInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: IntFilter<"Session"> | number
    userId?: IntFilter<"Session"> | number
    token?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AuditLogCreateWithoutActorInput, AuditLogUncheckedCreateWithoutActorInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutActorInput, AuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    entityType?: EnumAuditEntityTypeFilter<"AuditLog"> | $Enums.AuditEntityType
    entityId?: IntFilter<"AuditLog"> | number
    action?: EnumAuditActionFilter<"AuditLog"> | $Enums.AuditAction
    actorId?: IntNullableFilter<"AuditLog"> | number | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type OrderStatusHistoryUpsertWithWhereUniqueWithoutChangedByInput = {
    where: OrderStatusHistoryWhereUniqueInput
    update: XOR<OrderStatusHistoryUpdateWithoutChangedByInput, OrderStatusHistoryUncheckedUpdateWithoutChangedByInput>
    create: XOR<OrderStatusHistoryCreateWithoutChangedByInput, OrderStatusHistoryUncheckedCreateWithoutChangedByInput>
  }

  export type OrderStatusHistoryUpdateWithWhereUniqueWithoutChangedByInput = {
    where: OrderStatusHistoryWhereUniqueInput
    data: XOR<OrderStatusHistoryUpdateWithoutChangedByInput, OrderStatusHistoryUncheckedUpdateWithoutChangedByInput>
  }

  export type OrderStatusHistoryUpdateManyWithWhereWithoutChangedByInput = {
    where: OrderStatusHistoryScalarWhereInput
    data: XOR<OrderStatusHistoryUpdateManyMutationInput, OrderStatusHistoryUncheckedUpdateManyWithoutChangedByInput>
  }

  export type OrderStatusHistoryScalarWhereInput = {
    AND?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
    OR?: OrderStatusHistoryScalarWhereInput[]
    NOT?: OrderStatusHistoryScalarWhereInput | OrderStatusHistoryScalarWhereInput[]
    id?: IntFilter<"OrderStatusHistory"> | number
    orderId?: IntFilter<"OrderStatusHistory"> | number
    from?: EnumOrderStatusNullableFilter<"OrderStatusHistory"> | $Enums.OrderStatus | null
    to?: EnumOrderStatusFilter<"OrderStatusHistory"> | $Enums.OrderStatus
    changedAt?: DateTimeFilter<"OrderStatusHistory"> | Date | string
    changedById?: IntNullableFilter<"OrderStatusHistory"> | number | null
    note?: StringNullableFilter<"OrderStatusHistory"> | string | null
  }

  export type DeliveryProofUpsertWithWhereUniqueWithoutDriverInput = {
    where: DeliveryProofWhereUniqueInput
    update: XOR<DeliveryProofUpdateWithoutDriverInput, DeliveryProofUncheckedUpdateWithoutDriverInput>
    create: XOR<DeliveryProofCreateWithoutDriverInput, DeliveryProofUncheckedCreateWithoutDriverInput>
  }

  export type DeliveryProofUpdateWithWhereUniqueWithoutDriverInput = {
    where: DeliveryProofWhereUniqueInput
    data: XOR<DeliveryProofUpdateWithoutDriverInput, DeliveryProofUncheckedUpdateWithoutDriverInput>
  }

  export type DeliveryProofUpdateManyWithWhereWithoutDriverInput = {
    where: DeliveryProofScalarWhereInput
    data: XOR<DeliveryProofUpdateManyMutationInput, DeliveryProofUncheckedUpdateManyWithoutDriverInput>
  }

  export type DeliveryProofScalarWhereInput = {
    AND?: DeliveryProofScalarWhereInput | DeliveryProofScalarWhereInput[]
    OR?: DeliveryProofScalarWhereInput[]
    NOT?: DeliveryProofScalarWhereInput | DeliveryProofScalarWhereInput[]
    id?: IntFilter<"DeliveryProof"> | number
    orderId?: IntFilter<"DeliveryProof"> | number
    photoUrl?: StringFilter<"DeliveryProof"> | string
    note?: StringNullableFilter<"DeliveryProof"> | string | null
    deliveredAt?: DateTimeFilter<"DeliveryProof"> | Date | string
    driverId?: IntNullableFilter<"DeliveryProof"> | number | null
  }

  export type ServiceAssignmentUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: ServiceAssignmentWhereUniqueInput
    update: XOR<ServiceAssignmentUpdateWithoutAssignedByInput, ServiceAssignmentUncheckedUpdateWithoutAssignedByInput>
    create: XOR<ServiceAssignmentCreateWithoutAssignedByInput, ServiceAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ServiceAssignmentUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: ServiceAssignmentWhereUniqueInput
    data: XOR<ServiceAssignmentUpdateWithoutAssignedByInput, ServiceAssignmentUncheckedUpdateWithoutAssignedByInput>
  }

  export type ServiceAssignmentUpdateManyWithWhereWithoutAssignedByInput = {
    where: ServiceAssignmentScalarWhereInput
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type UserCreateWithoutSessionsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateWithoutAddressesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type OrderCreateWithoutDeliveryAddressInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryAddressInput = {
    id?: number
    orderNumber: string
    customerId: number
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrderCreateManyDeliveryAddressInputEnvelope = {
    data: OrderCreateManyDeliveryAddressInput | OrderCreateManyDeliveryAddressInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRequestCreateWithoutAddressInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutServiceRequestsInput
    photos?: ServicePhotoCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateWithoutAddressInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ServicePhotoUncheckedCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestCreateOrConnectWithoutAddressInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput>
  }

  export type ServiceRequestCreateManyAddressInputEnvelope = {
    data: ServiceRequestCreateManyAddressInput | ServiceRequestCreateManyAddressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutDeliveryAddressInput, OrderUncheckedUpdateWithoutDeliveryAddressInput>
    create: XOR<OrderCreateWithoutDeliveryAddressInput, OrderUncheckedCreateWithoutDeliveryAddressInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutDeliveryAddressInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutDeliveryAddressInput, OrderUncheckedUpdateWithoutDeliveryAddressInput>
  }

  export type OrderUpdateManyWithWhereWithoutDeliveryAddressInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutDeliveryAddressInput>
  }

  export type ServiceRequestUpsertWithWhereUniqueWithoutAddressInput = {
    where: ServiceRequestWhereUniqueInput
    update: XOR<ServiceRequestUpdateWithoutAddressInput, ServiceRequestUncheckedUpdateWithoutAddressInput>
    create: XOR<ServiceRequestCreateWithoutAddressInput, ServiceRequestUncheckedCreateWithoutAddressInput>
  }

  export type ServiceRequestUpdateWithWhereUniqueWithoutAddressInput = {
    where: ServiceRequestWhereUniqueInput
    data: XOR<ServiceRequestUpdateWithoutAddressInput, ServiceRequestUncheckedUpdateWithoutAddressInput>
  }

  export type ServiceRequestUpdateManyWithWhereWithoutAddressInput = {
    where: ServiceRequestScalarWhereInput
    data: XOR<ServiceRequestUpdateManyMutationInput, ServiceRequestUncheckedUpdateManyWithoutAddressInput>
  }

  export type UserCreateWithoutContactMessagesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutContactMessagesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutContactMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
  }

  export type UserCreateWithoutHandledMessagesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutHandledMessagesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutHandledMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHandledMessagesInput, UserUncheckedCreateWithoutHandledMessagesInput>
  }

  export type UserUpsertWithoutContactMessagesInput = {
    update: XOR<UserUpdateWithoutContactMessagesInput, UserUncheckedUpdateWithoutContactMessagesInput>
    create: XOR<UserCreateWithoutContactMessagesInput, UserUncheckedCreateWithoutContactMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutContactMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutContactMessagesInput, UserUncheckedUpdateWithoutContactMessagesInput>
  }

  export type UserUpdateWithoutContactMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutContactMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutHandledMessagesInput = {
    update: XOR<UserUpdateWithoutHandledMessagesInput, UserUncheckedUpdateWithoutHandledMessagesInput>
    create: XOR<UserCreateWithoutHandledMessagesInput, UserUncheckedCreateWithoutHandledMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHandledMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHandledMessagesInput, UserUncheckedUpdateWithoutHandledMessagesInput>
  }

  export type UserUpdateWithoutHandledMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutHandledMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type FoodItemCreateWithoutCategoryInput = {
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: FoodImageCreateNestedManyWithoutFoodItemInput
    orderItems?: OrderItemCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemUncheckedCreateWithoutCategoryInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: FoodImageUncheckedCreateNestedManyWithoutFoodItemInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemCreateOrConnectWithoutCategoryInput = {
    where: FoodItemWhereUniqueInput
    create: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput>
  }

  export type FoodItemCreateManyCategoryInputEnvelope = {
    data: FoodItemCreateManyCategoryInput | FoodItemCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type FoodItemUpsertWithWhereUniqueWithoutCategoryInput = {
    where: FoodItemWhereUniqueInput
    update: XOR<FoodItemUpdateWithoutCategoryInput, FoodItemUncheckedUpdateWithoutCategoryInput>
    create: XOR<FoodItemCreateWithoutCategoryInput, FoodItemUncheckedCreateWithoutCategoryInput>
  }

  export type FoodItemUpdateWithWhereUniqueWithoutCategoryInput = {
    where: FoodItemWhereUniqueInput
    data: XOR<FoodItemUpdateWithoutCategoryInput, FoodItemUncheckedUpdateWithoutCategoryInput>
  }

  export type FoodItemUpdateManyWithWhereWithoutCategoryInput = {
    where: FoodItemScalarWhereInput
    data: XOR<FoodItemUpdateManyMutationInput, FoodItemUncheckedUpdateManyWithoutCategoryInput>
  }

  export type FoodItemScalarWhereInput = {
    AND?: FoodItemScalarWhereInput | FoodItemScalarWhereInput[]
    OR?: FoodItemScalarWhereInput[]
    NOT?: FoodItemScalarWhereInput | FoodItemScalarWhereInput[]
    id?: IntFilter<"FoodItem"> | number
    name?: StringFilter<"FoodItem"> | string
    slug?: StringFilter<"FoodItem"> | string
    description?: StringNullableFilter<"FoodItem"> | string | null
    price?: DecimalFilter<"FoodItem"> | Decimal | DecimalJsLike | number | string
    sku?: StringNullableFilter<"FoodItem"> | string | null
    stock?: IntFilter<"FoodItem"> | number
    isActive?: BoolFilter<"FoodItem"> | boolean
    categoryId?: IntFilter<"FoodItem"> | number
    mainImageUrl?: StringNullableFilter<"FoodItem"> | string | null
    createdAt?: DateTimeFilter<"FoodItem"> | Date | string
    updatedAt?: DateTimeFilter<"FoodItem"> | Date | string
  }

  export type FoodCategoryCreateWithoutItemsInput = {
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCategoryUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodCategoryCreateOrConnectWithoutItemsInput = {
    where: FoodCategoryWhereUniqueInput
    create: XOR<FoodCategoryCreateWithoutItemsInput, FoodCategoryUncheckedCreateWithoutItemsInput>
  }

  export type FoodImageCreateWithoutFoodItemInput = {
    url: string
    position?: number
    createdAt?: Date | string
  }

  export type FoodImageUncheckedCreateWithoutFoodItemInput = {
    id?: number
    url: string
    position?: number
    createdAt?: Date | string
  }

  export type FoodImageCreateOrConnectWithoutFoodItemInput = {
    where: FoodImageWhereUniqueInput
    create: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput>
  }

  export type FoodImageCreateManyFoodItemInputEnvelope = {
    data: FoodImageCreateManyFoodItemInput | FoodImageCreateManyFoodItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutFoodItemInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutItemsInput
  }

  export type OrderItemUncheckedCreateWithoutFoodItemInput = {
    id?: number
    orderId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutFoodItemInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput>
  }

  export type OrderItemCreateManyFoodItemInputEnvelope = {
    data: OrderItemCreateManyFoodItemInput | OrderItemCreateManyFoodItemInput[]
    skipDuplicates?: boolean
  }

  export type FoodCategoryUpsertWithoutItemsInput = {
    update: XOR<FoodCategoryUpdateWithoutItemsInput, FoodCategoryUncheckedUpdateWithoutItemsInput>
    create: XOR<FoodCategoryCreateWithoutItemsInput, FoodCategoryUncheckedCreateWithoutItemsInput>
    where?: FoodCategoryWhereInput
  }

  export type FoodCategoryUpdateToOneWithWhereWithoutItemsInput = {
    where?: FoodCategoryWhereInput
    data: XOR<FoodCategoryUpdateWithoutItemsInput, FoodCategoryUncheckedUpdateWithoutItemsInput>
  }

  export type FoodCategoryUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodCategoryUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageUpsertWithWhereUniqueWithoutFoodItemInput = {
    where: FoodImageWhereUniqueInput
    update: XOR<FoodImageUpdateWithoutFoodItemInput, FoodImageUncheckedUpdateWithoutFoodItemInput>
    create: XOR<FoodImageCreateWithoutFoodItemInput, FoodImageUncheckedCreateWithoutFoodItemInput>
  }

  export type FoodImageUpdateWithWhereUniqueWithoutFoodItemInput = {
    where: FoodImageWhereUniqueInput
    data: XOR<FoodImageUpdateWithoutFoodItemInput, FoodImageUncheckedUpdateWithoutFoodItemInput>
  }

  export type FoodImageUpdateManyWithWhereWithoutFoodItemInput = {
    where: FoodImageScalarWhereInput
    data: XOR<FoodImageUpdateManyMutationInput, FoodImageUncheckedUpdateManyWithoutFoodItemInput>
  }

  export type FoodImageScalarWhereInput = {
    AND?: FoodImageScalarWhereInput | FoodImageScalarWhereInput[]
    OR?: FoodImageScalarWhereInput[]
    NOT?: FoodImageScalarWhereInput | FoodImageScalarWhereInput[]
    id?: IntFilter<"FoodImage"> | number
    foodItemId?: IntFilter<"FoodImage"> | number
    url?: StringFilter<"FoodImage"> | string
    position?: IntFilter<"FoodImage"> | number
    createdAt?: DateTimeFilter<"FoodImage"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutFoodItemInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutFoodItemInput, OrderItemUncheckedUpdateWithoutFoodItemInput>
    create: XOR<OrderItemCreateWithoutFoodItemInput, OrderItemUncheckedCreateWithoutFoodItemInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutFoodItemInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutFoodItemInput, OrderItemUncheckedUpdateWithoutFoodItemInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutFoodItemInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutFoodItemInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    foodItemId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: DecimalFilter<"OrderItem"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type FoodItemCreateWithoutImagesInput = {
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: FoodCategoryCreateNestedOneWithoutItemsInput
    orderItems?: OrderItemCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemUncheckedCreateWithoutImagesInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    categoryId: number
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemCreateOrConnectWithoutImagesInput = {
    where: FoodItemWhereUniqueInput
    create: XOR<FoodItemCreateWithoutImagesInput, FoodItemUncheckedCreateWithoutImagesInput>
  }

  export type FoodItemUpsertWithoutImagesInput = {
    update: XOR<FoodItemUpdateWithoutImagesInput, FoodItemUncheckedUpdateWithoutImagesInput>
    create: XOR<FoodItemCreateWithoutImagesInput, FoodItemUncheckedCreateWithoutImagesInput>
    where?: FoodItemWhereInput
  }

  export type FoodItemUpdateToOneWithWhereWithoutImagesInput = {
    where?: FoodItemWhereInput
    data: XOR<FoodItemUpdateWithoutImagesInput, FoodItemUncheckedUpdateWithoutImagesInput>
  }

  export type FoodItemUpdateWithoutImagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: FoodCategoryUpdateOneRequiredWithoutItemsNestedInput
    orderItems?: OrderItemUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemUncheckedUpdateWithoutImagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutFoodItemNestedInput
  }

  export type UserCreateWithoutOrdersInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type AddressCreateWithoutOrdersInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutAddressInput
  }

  export type AddressUncheckedCreateWithoutOrdersInput = {
    id?: number
    userId: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutAddressInput
  }

  export type AddressCreateOrConnectWithoutOrdersInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
  }

  export type OrderStatusHistoryCreateWithoutOrderInput = {
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    note?: string | null
    changedBy?: UserCreateNestedOneWithoutOrderStatusChangesInput
  }

  export type OrderStatusHistoryUncheckedCreateWithoutOrderInput = {
    id?: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    changedById?: number | null
    note?: string | null
  }

  export type OrderStatusHistoryCreateOrConnectWithoutOrderInput = {
    where: OrderStatusHistoryWhereUniqueInput
    create: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusHistoryCreateManyOrderInputEnvelope = {
    data: OrderStatusHistoryCreateManyOrderInput | OrderStatusHistoryCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    foodItem: FoodItemCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    foodItemId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutSalesmanOrdersInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutSalesmanOrdersInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutSalesmanOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesmanOrdersInput, UserUncheckedCreateWithoutSalesmanOrdersInput>
  }

  export type UserCreateWithoutDriverOrdersInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutDriverOrdersInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutDriverOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriverOrdersInput, UserUncheckedCreateWithoutDriverOrdersInput>
  }

  export type PaymentCreateWithoutOrderInput = {
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    provider?: string | null
    status?: string
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutOrderInput = {
    id?: number
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    provider?: string | null
    status?: string
    transactionId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutOrderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
  }

  export type DeliveryProofCreateWithoutOrderInput = {
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    driver?: UserCreateNestedOneWithoutDeliveryProofsInput
  }

  export type DeliveryProofUncheckedCreateWithoutOrderInput = {
    id?: number
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
    driverId?: number | null
  }

  export type DeliveryProofCreateOrConnectWithoutOrderInput = {
    where: DeliveryProofWhereUniqueInput
    create: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type AddressUpsertWithoutOrdersInput = {
    update: XOR<AddressUpdateWithoutOrdersInput, AddressUncheckedUpdateWithoutOrdersInput>
    create: XOR<AddressCreateWithoutOrdersInput, AddressUncheckedCreateWithoutOrdersInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutOrdersInput, AddressUncheckedUpdateWithoutOrdersInput>
  }

  export type AddressUpdateWithoutOrdersInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type OrderStatusHistoryUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusHistoryWhereUniqueInput
    update: XOR<OrderStatusHistoryUpdateWithoutOrderInput, OrderStatusHistoryUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderStatusHistoryCreateWithoutOrderInput, OrderStatusHistoryUncheckedCreateWithoutOrderInput>
  }

  export type OrderStatusHistoryUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderStatusHistoryWhereUniqueInput
    data: XOR<OrderStatusHistoryUpdateWithoutOrderInput, OrderStatusHistoryUncheckedUpdateWithoutOrderInput>
  }

  export type OrderStatusHistoryUpdateManyWithWhereWithoutOrderInput = {
    where: OrderStatusHistoryScalarWhereInput
    data: XOR<OrderStatusHistoryUpdateManyMutationInput, OrderStatusHistoryUncheckedUpdateManyWithoutOrderInput>
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type UserUpsertWithoutSalesmanOrdersInput = {
    update: XOR<UserUpdateWithoutSalesmanOrdersInput, UserUncheckedUpdateWithoutSalesmanOrdersInput>
    create: XOR<UserCreateWithoutSalesmanOrdersInput, UserUncheckedCreateWithoutSalesmanOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesmanOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesmanOrdersInput, UserUncheckedUpdateWithoutSalesmanOrdersInput>
  }

  export type UserUpdateWithoutSalesmanOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesmanOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutDriverOrdersInput = {
    update: XOR<UserUpdateWithoutDriverOrdersInput, UserUncheckedUpdateWithoutDriverOrdersInput>
    create: XOR<UserCreateWithoutDriverOrdersInput, UserUncheckedCreateWithoutDriverOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriverOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriverOrdersInput, UserUncheckedUpdateWithoutDriverOrdersInput>
  }

  export type UserUpdateWithoutDriverOrdersInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDriverOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type PaymentUpsertWithoutOrderInput = {
    update: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentCreateWithoutOrderInput, PaymentUncheckedCreateWithoutOrderInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutOrderInput, PaymentUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentUpdateWithoutOrderInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    transactionId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryProofUpsertWithoutOrderInput = {
    update: XOR<DeliveryProofUpdateWithoutOrderInput, DeliveryProofUncheckedUpdateWithoutOrderInput>
    create: XOR<DeliveryProofCreateWithoutOrderInput, DeliveryProofUncheckedCreateWithoutOrderInput>
    where?: DeliveryProofWhereInput
  }

  export type DeliveryProofUpdateToOneWithWhereWithoutOrderInput = {
    where?: DeliveryProofWhereInput
    data: XOR<DeliveryProofUpdateWithoutOrderInput, DeliveryProofUncheckedUpdateWithoutOrderInput>
  }

  export type DeliveryProofUpdateWithoutOrderInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: UserUpdateOneWithoutDeliveryProofsNestedInput
  }

  export type DeliveryProofUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderCreateWithoutItemsInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutItemsInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
  }

  export type FoodItemCreateWithoutOrderItemsInput = {
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: FoodCategoryCreateNestedOneWithoutItemsInput
    images?: FoodImageCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    categoryId: number
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: FoodImageUncheckedCreateNestedManyWithoutFoodItemInput
  }

  export type FoodItemCreateOrConnectWithoutOrderItemsInput = {
    where: FoodItemWhereUniqueInput
    create: XOR<FoodItemCreateWithoutOrderItemsInput, FoodItemUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderUpsertWithoutItemsInput = {
    update: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
    create: XOR<OrderCreateWithoutItemsInput, OrderUncheckedCreateWithoutItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutItemsInput, OrderUncheckedUpdateWithoutItemsInput>
  }

  export type OrderUpdateWithoutItemsInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type FoodItemUpsertWithoutOrderItemsInput = {
    update: XOR<FoodItemUpdateWithoutOrderItemsInput, FoodItemUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<FoodItemCreateWithoutOrderItemsInput, FoodItemUncheckedCreateWithoutOrderItemsInput>
    where?: FoodItemWhereInput
  }

  export type FoodItemUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: FoodItemWhereInput
    data: XOR<FoodItemUpdateWithoutOrderItemsInput, FoodItemUncheckedUpdateWithoutOrderItemsInput>
  }

  export type FoodItemUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: FoodCategoryUpdateOneRequiredWithoutItemsNestedInput
    images?: FoodImageUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    categoryId?: IntFieldUpdateOperationsInput | number
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: FoodImageUncheckedUpdateManyWithoutFoodItemNestedInput
  }

  export type OrderCreateWithoutStatusHistoryInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutStatusHistoryInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutStatusHistoryInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutStatusHistoryInput, OrderUncheckedCreateWithoutStatusHistoryInput>
  }

  export type UserCreateWithoutOrderStatusChangesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutOrderStatusChangesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutOrderStatusChangesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrderStatusChangesInput, UserUncheckedCreateWithoutOrderStatusChangesInput>
  }

  export type OrderUpsertWithoutStatusHistoryInput = {
    update: XOR<OrderUpdateWithoutStatusHistoryInput, OrderUncheckedUpdateWithoutStatusHistoryInput>
    create: XOR<OrderCreateWithoutStatusHistoryInput, OrderUncheckedCreateWithoutStatusHistoryInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutStatusHistoryInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutStatusHistoryInput, OrderUncheckedUpdateWithoutStatusHistoryInput>
  }

  export type OrderUpdateWithoutStatusHistoryInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutStatusHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type UserUpsertWithoutOrderStatusChangesInput = {
    update: XOR<UserUpdateWithoutOrderStatusChangesInput, UserUncheckedUpdateWithoutOrderStatusChangesInput>
    create: XOR<UserCreateWithoutOrderStatusChangesInput, UserUncheckedCreateWithoutOrderStatusChangesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrderStatusChangesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrderStatusChangesInput, UserUncheckedUpdateWithoutOrderStatusChangesInput>
  }

  export type UserUpdateWithoutOrderStatusChangesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutOrderStatusChangesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type OrderCreateWithoutPaymentInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    deliveryProof?: DeliveryProofCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    deliveryProof?: DeliveryProofUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateWithoutDeliveryProofInput = {
    orderNumber: string
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutOrdersInput
    deliveryAddress?: AddressCreateNestedOneWithoutOrdersInput
    statusHistory?: OrderStatusHistoryCreateNestedManyWithoutOrderInput
    items?: OrderItemCreateNestedManyWithoutOrderInput
    salesman?: UserCreateNestedOneWithoutSalesmanOrdersInput
    driver?: UserCreateNestedOneWithoutDriverOrdersInput
    payment?: PaymentCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDeliveryProofInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    statusHistory?: OrderStatusHistoryUncheckedCreateNestedManyWithoutOrderInput
    items?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDeliveryProofInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDeliveryProofInput, OrderUncheckedCreateWithoutDeliveryProofInput>
  }

  export type UserCreateWithoutDeliveryProofsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutDeliveryProofsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutDeliveryProofsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeliveryProofsInput, UserUncheckedCreateWithoutDeliveryProofsInput>
  }

  export type OrderUpsertWithoutDeliveryProofInput = {
    update: XOR<OrderUpdateWithoutDeliveryProofInput, OrderUncheckedUpdateWithoutDeliveryProofInput>
    create: XOR<OrderCreateWithoutDeliveryProofInput, OrderUncheckedCreateWithoutDeliveryProofInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDeliveryProofInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDeliveryProofInput, OrderUncheckedUpdateWithoutDeliveryProofInput>
  }

  export type OrderUpdateWithoutDeliveryProofInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryProofInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type UserUpsertWithoutDeliveryProofsInput = {
    update: XOR<UserUpdateWithoutDeliveryProofsInput, UserUncheckedUpdateWithoutDeliveryProofsInput>
    create: XOR<UserCreateWithoutDeliveryProofsInput, UserUncheckedCreateWithoutDeliveryProofsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeliveryProofsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeliveryProofsInput, UserUncheckedUpdateWithoutDeliveryProofsInput>
  }

  export type UserUpdateWithoutDeliveryProofsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDeliveryProofsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateWithoutServiceRequestsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutServiceRequestsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutServiceRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
  }

  export type AddressCreateWithoutServiceRequestsInput = {
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
    orders?: OrderCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressUncheckedCreateWithoutServiceRequestsInput = {
    id?: number
    userId: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutDeliveryAddressInput
  }

  export type AddressCreateOrConnectWithoutServiceRequestsInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutServiceRequestsInput, AddressUncheckedCreateWithoutServiceRequestsInput>
  }

  export type ServicePhotoCreateWithoutServiceInput = {
    url: string
    isBefore?: boolean
    createdAt?: Date | string
  }

  export type ServicePhotoUncheckedCreateWithoutServiceInput = {
    id?: number
    url: string
    isBefore?: boolean
    createdAt?: Date | string
  }

  export type ServicePhotoCreateOrConnectWithoutServiceInput = {
    where: ServicePhotoWhereUniqueInput
    create: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput>
  }

  export type ServicePhotoCreateManyServiceInputEnvelope = {
    data: ServicePhotoCreateManyServiceInput | ServicePhotoCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceAssignmentCreateWithoutServiceInput = {
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
    staff: UserCreateNestedOneWithoutStaffServicesInput
    assignedBy?: UserCreateNestedOneWithoutServiceAssignmentsInput
  }

  export type ServiceAssignmentUncheckedCreateWithoutServiceInput = {
    id?: number
    staffId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceAssignmentCreateOrConnectWithoutServiceInput = {
    where: ServiceAssignmentWhereUniqueInput
    create: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAssignmentCreateManyServiceInputEnvelope = {
    data: ServiceAssignmentCreateManyServiceInput | ServiceAssignmentCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceRatingCreateWithoutServiceInput = {
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
    customer: UserCreateNestedOneWithoutRatingsInput
    staff?: UserCreateNestedOneWithoutRatedServicesInput
  }

  export type ServiceRatingUncheckedCreateWithoutServiceInput = {
    id?: number
    customerId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingCreateOrConnectWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    create: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRatingCreateManyServiceInputEnvelope = {
    data: ServiceRatingCreateManyServiceInput | ServiceRatingCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutServiceRequestsInput = {
    update: XOR<UserUpdateWithoutServiceRequestsInput, UserUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<UserCreateWithoutServiceRequestsInput, UserUncheckedCreateWithoutServiceRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceRequestsInput, UserUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type UserUpdateWithoutServiceRequestsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type AddressUpsertWithoutServiceRequestsInput = {
    update: XOR<AddressUpdateWithoutServiceRequestsInput, AddressUncheckedUpdateWithoutServiceRequestsInput>
    create: XOR<AddressCreateWithoutServiceRequestsInput, AddressUncheckedCreateWithoutServiceRequestsInput>
    where?: AddressWhereInput
  }

  export type AddressUpdateToOneWithWhereWithoutServiceRequestsInput = {
    where?: AddressWhereInput
    data: XOR<AddressUpdateWithoutServiceRequestsInput, AddressUncheckedUpdateWithoutServiceRequestsInput>
  }

  export type AddressUpdateWithoutServiceRequestsInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
    orders?: OrderUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutServiceRequestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput
  }

  export type ServicePhotoUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServicePhotoWhereUniqueInput
    update: XOR<ServicePhotoUpdateWithoutServiceInput, ServicePhotoUncheckedUpdateWithoutServiceInput>
    create: XOR<ServicePhotoCreateWithoutServiceInput, ServicePhotoUncheckedCreateWithoutServiceInput>
  }

  export type ServicePhotoUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServicePhotoWhereUniqueInput
    data: XOR<ServicePhotoUpdateWithoutServiceInput, ServicePhotoUncheckedUpdateWithoutServiceInput>
  }

  export type ServicePhotoUpdateManyWithWhereWithoutServiceInput = {
    where: ServicePhotoScalarWhereInput
    data: XOR<ServicePhotoUpdateManyMutationInput, ServicePhotoUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServicePhotoScalarWhereInput = {
    AND?: ServicePhotoScalarWhereInput | ServicePhotoScalarWhereInput[]
    OR?: ServicePhotoScalarWhereInput[]
    NOT?: ServicePhotoScalarWhereInput | ServicePhotoScalarWhereInput[]
    id?: IntFilter<"ServicePhoto"> | number
    serviceId?: IntFilter<"ServicePhoto"> | number
    url?: StringFilter<"ServicePhoto"> | string
    isBefore?: BoolFilter<"ServicePhoto"> | boolean
    createdAt?: DateTimeFilter<"ServicePhoto"> | Date | string
  }

  export type ServiceAssignmentUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceAssignmentWhereUniqueInput
    update: XOR<ServiceAssignmentUpdateWithoutServiceInput, ServiceAssignmentUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceAssignmentCreateWithoutServiceInput, ServiceAssignmentUncheckedCreateWithoutServiceInput>
  }

  export type ServiceAssignmentUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceAssignmentWhereUniqueInput
    data: XOR<ServiceAssignmentUpdateWithoutServiceInput, ServiceAssignmentUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceAssignmentUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceAssignmentScalarWhereInput
    data: XOR<ServiceAssignmentUpdateManyMutationInput, ServiceAssignmentUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceRatingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    update: XOR<ServiceRatingUpdateWithoutServiceInput, ServiceRatingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRatingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    data: XOR<ServiceRatingUpdateWithoutServiceInput, ServiceRatingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceRatingUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceRatingScalarWhereInput
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceRequestCreateWithoutAssignmentsInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutServiceRequestsInput
    address?: AddressCreateNestedOneWithoutServiceRequestsInput
    photos?: ServicePhotoCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ServicePhotoUncheckedCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestCreateOrConnectWithoutAssignmentsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutAssignmentsInput, ServiceRequestUncheckedCreateWithoutAssignmentsInput>
  }

  export type UserCreateWithoutStaffServicesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutStaffServicesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutStaffServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffServicesInput, UserUncheckedCreateWithoutStaffServicesInput>
  }

  export type UserCreateWithoutServiceAssignmentsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
  }

  export type UserUncheckedCreateWithoutServiceAssignmentsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
  }

  export type UserCreateOrConnectWithoutServiceAssignmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServiceAssignmentsInput, UserUncheckedCreateWithoutServiceAssignmentsInput>
  }

  export type ServiceRequestUpsertWithoutAssignmentsInput = {
    update: XOR<ServiceRequestUpdateWithoutAssignmentsInput, ServiceRequestUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<ServiceRequestCreateWithoutAssignmentsInput, ServiceRequestUncheckedCreateWithoutAssignmentsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutAssignmentsInput, ServiceRequestUncheckedUpdateWithoutAssignmentsInput>
  }

  export type ServiceRequestUpdateWithoutAssignmentsInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    address?: AddressUpdateOneWithoutServiceRequestsNestedInput
    photos?: ServicePhotoUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutStaffServicesInput = {
    update: XOR<UserUpdateWithoutStaffServicesInput, UserUncheckedUpdateWithoutStaffServicesInput>
    create: XOR<UserCreateWithoutStaffServicesInput, UserUncheckedCreateWithoutStaffServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffServicesInput, UserUncheckedUpdateWithoutStaffServicesInput>
  }

  export type UserUpdateWithoutStaffServicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutServiceAssignmentsInput = {
    update: XOR<UserUpdateWithoutServiceAssignmentsInput, UserUncheckedUpdateWithoutServiceAssignmentsInput>
    create: XOR<UserCreateWithoutServiceAssignmentsInput, UserUncheckedCreateWithoutServiceAssignmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServiceAssignmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServiceAssignmentsInput, UserUncheckedUpdateWithoutServiceAssignmentsInput>
  }

  export type UserUpdateWithoutServiceAssignmentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
  }

  export type UserUncheckedUpdateWithoutServiceAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type ServiceRequestCreateWithoutPhotosInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutServiceRequestsInput
    address?: AddressCreateNestedOneWithoutServiceRequestsInput
    assignments?: ServiceAssignmentCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateWithoutPhotosInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestCreateOrConnectWithoutPhotosInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutPhotosInput, ServiceRequestUncheckedCreateWithoutPhotosInput>
  }

  export type ServiceRequestUpsertWithoutPhotosInput = {
    update: XOR<ServiceRequestUpdateWithoutPhotosInput, ServiceRequestUncheckedUpdateWithoutPhotosInput>
    create: XOR<ServiceRequestCreateWithoutPhotosInput, ServiceRequestUncheckedCreateWithoutPhotosInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutPhotosInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutPhotosInput, ServiceRequestUncheckedUpdateWithoutPhotosInput>
  }

  export type ServiceRequestUpdateWithoutPhotosInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    address?: AddressUpdateOneWithoutServiceRequestsNestedInput
    assignments?: ServiceAssignmentUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutPhotosInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestCreateWithoutRatingsInput = {
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: UserCreateNestedOneWithoutServiceRequestsInput
    address?: AddressCreateNestedOneWithoutServiceRequestsInput
    photos?: ServicePhotoCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestUncheckedCreateWithoutRatingsInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photos?: ServicePhotoUncheckedCreateNestedManyWithoutServiceInput
    assignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceRequestCreateOrConnectWithoutRatingsInput = {
    where: ServiceRequestWhereUniqueInput
    create: XOR<ServiceRequestCreateWithoutRatingsInput, ServiceRequestUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutRatingsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutRatedServicesInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutRatedServicesInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutActorInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutRatedServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatedServicesInput, UserUncheckedCreateWithoutRatedServicesInput>
  }

  export type ServiceRequestUpsertWithoutRatingsInput = {
    update: XOR<ServiceRequestUpdateWithoutRatingsInput, ServiceRequestUncheckedUpdateWithoutRatingsInput>
    create: XOR<ServiceRequestCreateWithoutRatingsInput, ServiceRequestUncheckedCreateWithoutRatingsInput>
    where?: ServiceRequestWhereInput
  }

  export type ServiceRequestUpdateToOneWithWhereWithoutRatingsInput = {
    where?: ServiceRequestWhereInput
    data: XOR<ServiceRequestUpdateWithoutRatingsInput, ServiceRequestUncheckedUpdateWithoutRatingsInput>
  }

  export type ServiceRequestUpdateWithoutRatingsInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    address?: AddressUpdateOneWithoutServiceRequestsNestedInput
    photos?: ServicePhotoUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUpsertWithoutRatedServicesInput = {
    update: XOR<UserUpdateWithoutRatedServicesInput, UserUncheckedUpdateWithoutRatedServicesInput>
    create: XOR<UserCreateWithoutRatedServicesInput, UserUncheckedCreateWithoutRatedServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatedServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatedServicesInput, UserUncheckedUpdateWithoutRatedServicesInput>
  }

  export type UserUpdateWithoutRatedServicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRatedServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutActorNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressCreateNestedManyWithoutUserInput
    orders?: OrderCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingCreateNestedManyWithoutStaffInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    orderStatusChanges?: OrderStatusHistoryCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentCreateNestedManyWithoutAssignedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    passwordHash: string
    name: string
    phone?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    emailVerified?: Date | string | null
    profileImage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    orders?: OrderUncheckedCreateNestedManyWithoutCustomerInput
    serviceRequests?: ServiceRequestUncheckedCreateNestedManyWithoutCustomerInput
    salesmanOrders?: OrderUncheckedCreateNestedManyWithoutSalesmanInput
    driverOrders?: OrderUncheckedCreateNestedManyWithoutDriverInput
    staffServices?: ServiceAssignmentUncheckedCreateNestedManyWithoutStaffInput
    contactMessages?: ContactMessageUncheckedCreateNestedManyWithoutUserInput
    handledMessages?: ContactMessageUncheckedCreateNestedManyWithoutHandledByInput
    ratings?: ServiceRatingUncheckedCreateNestedManyWithoutCustomerInput
    ratedServices?: ServiceRatingUncheckedCreateNestedManyWithoutStaffInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    orderStatusChanges?: OrderStatusHistoryUncheckedCreateNestedManyWithoutChangedByInput
    deliveryProofs?: DeliveryProofUncheckedCreateNestedManyWithoutDriverInput
    serviceAssignments?: ServiceAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUpdateManyWithoutUserNestedInput
    orders?: OrderUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUpdateManyWithoutStaffNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    orderStatusChanges?: OrderStatusHistoryUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUpdateManyWithoutAssignedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    orders?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutCustomerNestedInput
    salesmanOrders?: OrderUncheckedUpdateManyWithoutSalesmanNestedInput
    driverOrders?: OrderUncheckedUpdateManyWithoutDriverNestedInput
    staffServices?: ServiceAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    contactMessages?: ContactMessageUncheckedUpdateManyWithoutUserNestedInput
    handledMessages?: ContactMessageUncheckedUpdateManyWithoutHandledByNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutCustomerNestedInput
    ratedServices?: ServiceRatingUncheckedUpdateManyWithoutStaffNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    orderStatusChanges?: OrderStatusHistoryUncheckedUpdateManyWithoutChangedByNestedInput
    deliveryProofs?: DeliveryProofUncheckedUpdateManyWithoutDriverNestedInput
    serviceAssignments?: ServiceAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
  }

  export type AddressCreateManyUserInput = {
    id?: number
    label?: string | null
    line1: string
    line2?: string | null
    city: string
    postalCode: string
    country?: string
    isDefault?: boolean
    createdAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: number
    orderNumber: string
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestCreateManyCustomerInput = {
    id?: number
    requestNumber: string
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    addressId?: number | null
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManySalesmanInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyDriverInput = {
    id?: number
    orderNumber: string
    customerId: number
    deliveryAddressId?: number | null
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceAssignmentCreateManyStaffInput = {
    id?: number
    serviceId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ContactMessageCreateManyUserInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    handledById?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ContactMessageCreateManyHandledByInput = {
    id?: number
    name: string
    email: string
    phone?: string | null
    subject: string
    message: string
    userId?: number | null
    handledAt?: Date | string | null
    status?: string
    createdAt?: Date | string
  }

  export type ServiceRatingCreateManyCustomerInput = {
    id?: number
    serviceId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServiceRatingCreateManyStaffInput = {
    id?: number
    serviceId: number
    customerId: number
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type AuditLogCreateManyActorInput = {
    id?: number
    entityType: $Enums.AuditEntityType
    entityId: number
    action: $Enums.AuditAction
    ipAddress?: string | null
    userAgent?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type OrderStatusHistoryCreateManyChangedByInput = {
    id?: number
    orderId: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    note?: string | null
  }

  export type DeliveryProofCreateManyDriverInput = {
    id?: number
    orderId: number
    photoUrl: string
    note?: string | null
    deliveredAt?: Date | string
  }

  export type ServiceAssignmentCreateManyAssignedByInput = {
    id?: number
    serviceId: number
    staffId: number
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type AddressUpdateWithoutUserInput = {
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutDeliveryAddressNestedInput
    serviceRequests?: ServiceRequestUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutDeliveryAddressNestedInput
    serviceRequests?: ServiceRequestUncheckedUpdateManyWithoutAddressNestedInput
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    label?: NullableStringFieldUpdateOperationsInput | string | null
    line1?: StringFieldUpdateOperationsInput | string
    line2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    postalCode?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpdateWithoutCustomerInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: AddressUpdateOneWithoutServiceRequestsNestedInput
    photos?: ServicePhotoUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    addressId?: NullableIntFieldUpdateOperationsInput | number | null
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutSalesmanInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSalesmanInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutSalesmanInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutDriverInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    deliveryAddress?: AddressUpdateOneWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    deliveryAddressId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentUpdateWithoutStaffInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceRequestUpdateOneRequiredWithoutAssignmentsNestedInput
    assignedBy?: UserUpdateOneWithoutServiceAssignmentsNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContactMessageUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledBy?: UserUpdateOneWithoutHandledMessagesNestedInput
  }

  export type ContactMessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledById?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledById?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUpdateWithoutHandledByInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutContactMessagesNestedInput
  }

  export type ContactMessageUncheckedUpdateWithoutHandledByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactMessageUncheckedUpdateManyWithoutHandledByInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    handledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUpdateWithoutCustomerInput = {
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceRequestUpdateOneRequiredWithoutRatingsNestedInput
    staff?: UserUpdateOneWithoutRatedServicesNestedInput
  }

  export type ServiceRatingUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUpdateWithoutStaffInput = {
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceRequestUpdateOneRequiredWithoutRatingsNestedInput
    customer?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type ServiceRatingUncheckedUpdateWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUncheckedUpdateManyWithoutStaffInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutActorInput = {
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: IntFieldUpdateOperationsInput | number
    entityType?: EnumAuditEntityTypeFieldUpdateOperationsInput | $Enums.AuditEntityType
    entityId?: IntFieldUpdateOperationsInput | number
    action?: EnumAuditActionFieldUpdateOperationsInput | $Enums.AuditAction
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusHistoryUpdateWithoutChangedByInput = {
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutStatusHistoryNestedInput
  }

  export type OrderStatusHistoryUncheckedUpdateWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusHistoryUncheckedUpdateManyWithoutChangedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeliveryProofUpdateWithoutDriverInput = {
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutDeliveryProofNestedInput
  }

  export type DeliveryProofUncheckedUpdateWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeliveryProofUncheckedUpdateManyWithoutDriverInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    photoUrl?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    deliveredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentUpdateWithoutAssignedByInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceRequestUpdateOneRequiredWithoutAssignmentsNestedInput
    staff?: UserUpdateOneRequiredWithoutStaffServicesNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateWithoutAssignedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutAssignedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceId?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyDeliveryAddressInput = {
    id?: number
    orderNumber: string
    customerId: number
    status?: $Enums.OrderStatus
    notes?: string | null
    imageUrl?: string | null
    totalPrice: Decimal | DecimalJsLike | number | string
    salesmanId?: number | null
    driverId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceRequestCreateManyAddressInput = {
    id?: number
    requestNumber: string
    customerId: number
    type: $Enums.ServiceType
    status?: $Enums.ServiceStatus
    priority?: $Enums.ServicePriority
    title: string
    description: string
    requestedDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutDeliveryAddressInput = {
    orderNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutOrdersNestedInput
    statusHistory?: OrderStatusHistoryUpdateManyWithoutOrderNestedInput
    items?: OrderItemUpdateManyWithoutOrderNestedInput
    salesman?: UserUpdateOneWithoutSalesmanOrdersNestedInput
    driver?: UserUpdateOneWithoutDriverOrdersNestedInput
    payment?: PaymentUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statusHistory?: OrderStatusHistoryUncheckedUpdateManyWithoutOrderNestedInput
    items?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentUncheckedUpdateOneWithoutOrderNestedInput
    deliveryProof?: DeliveryProofUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutDeliveryAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    salesmanId?: NullableIntFieldUpdateOperationsInput | number | null
    driverId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRequestUpdateWithoutAddressInput = {
    requestNumber?: StringFieldUpdateOperationsInput | string
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutServiceRequestsNestedInput
    photos?: ServicePhotoUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photos?: ServicePhotoUncheckedUpdateManyWithoutServiceNestedInput
    assignments?: ServiceAssignmentUncheckedUpdateManyWithoutServiceNestedInput
    ratings?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceRequestUncheckedUpdateManyWithoutAddressInput = {
    id?: IntFieldUpdateOperationsInput | number
    requestNumber?: StringFieldUpdateOperationsInput | string
    customerId?: IntFieldUpdateOperationsInput | number
    type?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    priority?: EnumServicePriorityFieldUpdateOperationsInput | $Enums.ServicePriority
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodItemCreateManyCategoryInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    price: Decimal | DecimalJsLike | number | string
    sku?: string | null
    stock?: number
    isActive?: boolean
    mainImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FoodItemUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: FoodImageUpdateManyWithoutFoodItemNestedInput
    orderItems?: OrderItemUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: FoodImageUncheckedUpdateManyWithoutFoodItemNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutFoodItemNestedInput
  }

  export type FoodItemUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    stock?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mainImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageCreateManyFoodItemInput = {
    id?: number
    url: string
    position?: number
    createdAt?: Date | string
  }

  export type OrderItemCreateManyFoodItemInput = {
    id?: number
    orderId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type FoodImageUpdateWithoutFoodItemInput = {
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageUncheckedUpdateWithoutFoodItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FoodImageUncheckedUpdateManyWithoutFoodItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutFoodItemInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutFoodItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutFoodItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderStatusHistoryCreateManyOrderInput = {
    id?: number
    from?: $Enums.OrderStatus | null
    to: $Enums.OrderStatus
    changedAt?: Date | string
    changedById?: number | null
    note?: string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    foodItemId: number
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type OrderStatusHistoryUpdateWithoutOrderInput = {
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: UserUpdateOneWithoutOrderStatusChangesNestedInput
  }

  export type OrderStatusHistoryUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderStatusHistoryUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    from?: NullableEnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus | null
    to?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    changedById?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foodItem?: FoodItemUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    foodItemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePhotoCreateManyServiceInput = {
    id?: number
    url: string
    isBefore?: boolean
    createdAt?: Date | string
  }

  export type ServiceAssignmentCreateManyServiceInput = {
    id?: number
    staffId: number
    assignedById?: number | null
    assignedAt?: Date | string
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    status?: $Enums.ServiceStatus
    notes?: string | null
  }

  export type ServiceRatingCreateManyServiceInput = {
    id?: number
    customerId: number
    staffId?: number | null
    score: number
    review?: string | null
    wouldRecommend?: boolean
    createdAt?: Date | string
  }

  export type ServicePhotoUpdateWithoutServiceInput = {
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePhotoUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePhotoUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    isBefore?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceAssignmentUpdateWithoutServiceInput = {
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    staff?: UserUpdateOneRequiredWithoutStaffServicesNestedInput
    assignedBy?: UserUpdateOneWithoutServiceAssignmentsNestedInput
  }

  export type ServiceAssignmentUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceAssignmentUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    staffId?: IntFieldUpdateOperationsInput | number
    assignedById?: NullableIntFieldUpdateOperationsInput | number | null
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumServiceStatusFieldUpdateOperationsInput | $Enums.ServiceStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceRatingUpdateWithoutServiceInput = {
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: UserUpdateOneRequiredWithoutRatingsNestedInput
    staff?: UserUpdateOneWithoutRatedServicesNestedInput
  }

  export type ServiceRatingUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceRatingUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    staffId?: NullableIntFieldUpdateOperationsInput | number | null
    score?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    wouldRecommend?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressCountOutputTypeDefaultArgs instead
     */
    export type AddressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodCategoryCountOutputTypeDefaultArgs instead
     */
    export type FoodCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodItemCountOutputTypeDefaultArgs instead
     */
    export type FoodItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderCountOutputTypeDefaultArgs instead
     */
    export type OrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceRequestCountOutputTypeDefaultArgs instead
     */
    export type ServiceRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AddressDefaultArgs instead
     */
    export type AddressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AddressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ContactMessageDefaultArgs instead
     */
    export type ContactMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ContactMessageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodCategoryDefaultArgs instead
     */
    export type FoodCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodItemDefaultArgs instead
     */
    export type FoodItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FoodImageDefaultArgs instead
     */
    export type FoodImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FoodImageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderDefaultArgs instead
     */
    export type OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderStatusHistoryDefaultArgs instead
     */
    export type OrderStatusHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderStatusHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DeliveryProofDefaultArgs instead
     */
    export type DeliveryProofArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DeliveryProofDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceRequestDefaultArgs instead
     */
    export type ServiceRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceAssignmentDefaultArgs instead
     */
    export type ServiceAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServicePhotoDefaultArgs instead
     */
    export type ServicePhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServicePhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceRatingDefaultArgs instead
     */
    export type ServiceRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceRatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}