# Full-Stack Next.js Platform: Database & Image Storage Architecture Decision Analysis

**Document Date:** December 8, 2025  
**Stack:** Next.js (App Router) + TypeScript + Prisma ORM + NextAuth.js  
**Focus:** PostgreSQL vs MongoDB + Image Upload Strategy

---

## Executive Summary

Your original TSD specified **PostgreSQL** with Prisma migrations. You're now considering a **pivot to MongoDB** with hosted image uploads (Google Cloud Storage or AWS S3). This document provides:

1. **Database Comparison** (PostgreSQL vs MongoDB)
2. **Cost Analysis** (hosting + operations)
3. **Image Upload Architecture** (3 approaches)
4. **Recommended Solution** with implementation path
5. **Deployment Strategy** for Next.js backend

---

## 1. DATABASE DECISION ANALYSIS

### 1.1 PostgreSQL (Original Choice)

**Strengths:**
- ✅ **ACID Compliance**: Reliable transactional ordering (critical for your food orders & services)
- ✅ **Complex Joins**: Your relational data (Orders → Users → Addresses, Services → Staff) needs efficient SQL
- ✅ **Cost**: 100% free open-source. Only pay for hosting
- ✅ **Mature Ecosystem**: Proven, battle-tested, excellent tooling
- ✅ **Prisma Native**: First-class support; migrations work seamlessly

**Challenges:**
- Requires schema planning upfront
- Vertical scaling (though sufficient for most apps)
- Self-hosted complexity if not using managed services

**Best For:** Your use case (structured, relational, transactional data)

---

### 1.2 MongoDB (Proposed Alternative)

**Strengths:**
- ✅ **Flexible Schema**: Add fields without migrations
- ✅ **Horizontal Scaling**: Built-in sharding for massive scale
- ✅ **Fast Development**: Less schema planning needed upfront

**Challenges:**
- ❌ **ACID Guarantees Weaker**: Multi-document transactions have limitations (added in 4.0+, still not ideal for complex workflows)
- ❌ **Complex Queries**: Your order + service request status flows need strong consistency guarantees
- ❌ **Costs**: Managed MongoDB Atlas has operational overhead; serverless model less mature than PostgreSQL alternatives
- ❌ **Joins**: Application-level joins (slower, more complex code)
- ❌ **GDPR Compliance**: Document-based storage makes data export/deletion harder

**Best For:** Unstructured, rapidly-evolving data (content management, real-time feeds)

---

### 1.3 Verdict: **STICK WITH PostgreSQL**

**Why:**
1. Your system has **transactional requirements** (order status changes, service assignments, payment ledger)
2. **Relational data** is core: Users → Orders → Items → Delivery Tracking; Users → ServiceRequests → Staff assignments
3. **Cost-neutral switch**: MongoDB adds operational complexity without benefit
4. **Prisma support**: You'll keep the same Prisma integration, reducing migration risk
5. **Scaling**: PostgreSQL handles your projected scale (thousands of orders/day) without horizontal sharding

---

## 2. HOSTED PostgreSQL DEPLOYMENT OPTIONS (2025)

### Pricing Comparison (per month, small deployment)

| Provider | Free Tier | Starter ($) | CPU | RAM | Storage | Notes |
|----------|-----------|-------------|-----|-----|---------|-------|
| **Neon** | 3GB / 1 proj | Free forever | 0.25 | 1GB | 3GB | Scale-to-zero; branching; storage separation |
| **Supabase** | 500MB / 2 proj | $25 | Shared | Shared | 8GB | Auth + storage included; real-time API |
| **Vercel Postgres** | N/A | Pay-as-you-go | Serverless | Serverless | ⚡ | Integrated with Vercel; connection limits |
| **Railway** | 500 hours/mo free | $5/mo | Flexible | Flexible | Flexible | Docker-based; pay-per-resource |
| **DigitalOcean** | N/A | $15/mo | 1 vCPU | 1GB | 10GB | Simple, predictable pricing |

### Recommendation for Your Platform

**Primary:** **Neon** (with optional Vercel Postgres for preview environments)

**Why Neon:**
- ✅ Free tier covers development (3GB, branching for dev/staging/prod)
- ✅ Pay-as-you-go: Only pay when compute runs ($0.32/hr for 2vCPU)
- ✅ Auto-suspend: Scale to zero when idle (perfect for startup costs)
- ✅ Point-in-time recovery included (free backup protection)
- ✅ Prisma integration: Official support & guides available

**Cost Estimate (First Year):**
- **Dev/Staging:** Free (autosuspend when not in use)
- **Production:** ~$19/mo startup plan (includes 10GB, branching)
- **Growth:** ~$50/mo at moderate scale (10K+ users)
- **Peak:** <$100/mo unless you exceed 100GB storage

---

## 3. IMAGE UPLOAD ARCHITECTURE DECISION

You have **3 viable approaches**:

### Option A: Direct Database Storage (❌ NOT RECOMMENDED)
**Approach:** Store image blobs in PostgreSQL `bytea` field

**Pros:**
- Single source of truth
- Transaction consistency

**Cons:**
- ❌ Bloats database (slow queries, expensive backups)
- ❌ Neon charges per-GB for storage (expensive at scale)
- ❌ No CDN distribution (slow global delivery)
- ❌ Poor user experience (large binary payloads)

**Cost:** 10MB image = ~$0.0015/month per image on Neon; 1000 images = $1.50/month + query slowdown

---

### Option B: AWS S3 (✅ RECOMMENDED FOR HIGH VOLUME)
**Approach:** Upload directly to S3 via pre-signed URLs → store URL in DB

#### Architecture Flow:
```
1. User selects image in Next.js frontend
2. Frontend calls /api/upload (your backend)
3. Backend generates S3 pre-signed URL (valid 15 minutes)
4. Frontend uploads directly to S3 (bypasses your server)
5. S3 returns public URL
6. Frontend stores URL in database via order/product submission
```

**Pros:**
- ✅ Infinite scale (Amazon-backed CDN)
- ✅ Cost-efficient at high volume
- ✅ Server doesn't bottleneck (client → S3 direct)
- ✅ Built-in versioning, lifecycle policies
- ✅ Integrates with AWS ecosystem (CloudFront, Lambda)

**Cons:**
- CORS complexity (solvable with pre-signed URLs)
- AWS requires credit card (even free tier)

#### S3 Pricing (December 2025):
| Metric | Cost |
|--------|------|
| Storage (S3 Standard) | $0.023/GB/mo (first 50TB) |
| Data transfer OUT | $0.09/GB (first 1GB free/mo) |
| PUT requests | $0.005 per 1,000 |
| GET requests | $0.0004 per 1,000 |

**Cost Example (1000 images, 3MB avg, 1000 downloads/mo):**
- Storage: (3GB × 1000 / 1024) × $0.023 = ~$0.07/mo
- Transfer: (3GB downloads × 0.9 × $0.09) = ~$0.24/mo
- Requests: (1000 PUTs × $0.005/1000) + (1000 GETs × $0.0004/1000) = ~$0.005/mo
- **Total: ~$0.31/mo** ✅ (negligible)

---

### Option C: Google Cloud Storage (✅ RECOMMENDED FOR QUICK START)
**Approach:** Same as S3, but with Google Cloud

#### Architecture Flow:
```
Same as S3 above, but using GCS service account + Signed URLs
```

**Pros:**
- ✅ Competitive pricing, simpler pricing model
- ✅ Better for analytics/BigQuery integration (future)
- ✅ Free tier generous: 5GB/month egress from Google products
- ✅ Multi-region redundancy included
- ✅ Easier CORS setup than S3

**Cons:**
- Requires Google Cloud account setup
- Slightly less mature ecosystem than AWS

#### GCS Pricing (December 2025):
| Metric | Cost |
|--------|------|
| Storage (Standard) | $0.020/GB/mo (cheaper than S3) |
| Data transfer OUT | $0.12/GB (egress) |
| Class A ops (write) | $0.005 per 1,000 |
| Class B ops (read) | $0.0004 per 1,000 |

**Cost Example (same 1000 images scenario):**
- Storage: (3GB × $0.020) = ~$0.06/mo
- Transfer: (3GB × $0.12) = ~$0.36/mo
- Operations: ~$0.005/mo
- **Total: ~$0.42/mo** (slightly higher due to egress)

---

### **FINAL VERDICT: Use Google Cloud Storage**

**Why GCS over S3:**
1. ✅ Simpler pricing (no request tiers complexity)
2. ✅ Slightly cheaper for your use case (image-heavy, moderate download volume)
3. ✅ Better future integration with BigQuery (analytics dashboard requirement)
4. ✅ Free tier egress from Google products (scales as you grow)
5. ✅ Easier to set up than S3 (straightforward service account + signed URLs)

---

## 4. RECOMMENDED ARCHITECTURE

### 4.1 Tech Stack (Final)
```
Frontend:
├── Next.js 15 (App Router)
├── TypeScript
├── Tailwind CSS + shadcn/ui
├── Redux Toolkit + RTK Query
├── React Hook Form + Zod
└── Next.js Image component (for GCS CDN optimization)

Backend:
├── Next.js API Routes (Node.js/Edge runtime)
├── NextAuth.js (JWT-based sessions)
├── Prisma ORM (PostgreSQL client)
├── Nodemailer (email notifications)
├── Google Cloud Storage SDK (image uploads)
└── Upstash Ratelimit (rate limiting)

Database:
├── Neon (Managed PostgreSQL)
└── Point-in-time recovery (included)

External Services:
├── Google Cloud Storage (image storage)
└── SendGrid/SMTP (email delivery)
```

### 4.2 Database Schema Structure (PostgreSQL)

```sql
-- Core Tables
User (id, email, password_hash, role, is_approved, created_at)
├── ADMIN, CUSTOMER, SHOP_OWNER, SALESMAN, DRIVER, CLEANER, IT_STAFF

Category (id, name, description, image_url)
  └── image_url: String (GCS signed URL)

FoodItem (id, category_id, name, price, stock, image_url)
  └── image_url: String (GCS URL)

Order (id, user_id, total_price, status, created_at)
├── PENDING → ACCEPTED → PREPARING → OUT_FOR_DELIVERY → DELIVERED
└── image_url: String (receipt/proof of delivery)

OrderItem (id, order_id, item_id, quantity)

ServiceRequest (id, user_id, type, status, created_at)
├── type: CLEANING | IT_SUPPORT
├── status: RECEIVED → ASSIGNED → IN_PROGRESS → RESOLVED
└── image_url: String (before/after photos)

StaffAssignment (id, service_request_id, staff_id, status)

AuditLog (id, entity_type, entity_id, action, actor_id, timestamp)
```

---

## 5. IMAGE UPLOAD IMPLEMENTATION (Next.js + GCS)

### 5.1 Backend: Generate Signed URL

```typescript
// app/api/upload/gcs-signed-url/route.ts
import { Storage } from '@google-cloud/storage';
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/auth.config';

const storage = new Storage({
  projectId: process.env.GCS_PROJECT_ID,
  credentials: {
    client_email: process.env.GCS_CLIENT_EMAIL,
    private_key: process.env.GCS_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
});

const bucket = storage.bucket(process.env.GCS_BUCKET_NAME!);

export async function POST(req: NextRequest) {
  try {
    // Authenticate user
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { filename, fileType } = await req.json();

    // Validate file
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
    if (!allowedTypes.includes(fileType)) {
      return NextResponse.json(
        { error: 'Invalid file type' },
        { status: 400 }
      );
    }

    // Max 5MB
    const maxSize = 5 * 1024 * 1024;
    // (Note: frontend will also enforce this)

    // Generate unique filename
    const timestamp = Date.now();
    const userId = session.user.id;
    const uniqueName = `${userId}/${timestamp}-${filename}`;

    // Generate signed URL (valid for 15 minutes)
    const [signedUrl] = await bucket.file(uniqueName).getSignedUrl({
      version: 'v4',
      action: 'write',
      expires: Date.now() + 15 * 60 * 1000,
      contentType: fileType,
    });

    return NextResponse.json({
      signedUrl,
      fileName: uniqueName,
      bucketName: process.env.GCS_BUCKET_NAME,
    });
  } catch (error) {
    console.error('GCS signed URL error:', error);
    return NextResponse.json(
      { error: 'Failed to generate upload URL' },
      { status: 500 }
    );
  }
}
```

### 5.2 Frontend: Upload Image

```typescript
// hooks/useGcsUpload.ts
import { useState } from 'react';

export function useGcsUpload() {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const uploadImage = async (file: File): Promise<string | null> => {
    try {
      setIsUploading(true);
      setError(null);

      // Validate file size
      if (file.size > 5 * 1024 * 1024) {
        setError('File too large (max 5MB)');
        return null;
      }

      // Step 1: Get signed URL from backend
      const signedUrlRes = await fetch('/api/upload/gcs-signed-url', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filename: file.name,
          fileType: file.type,
        }),
      });

      if (!signedUrlRes.ok) {
        throw new Error('Failed to get upload URL');
      }

      const { signedUrl, fileName } = await signedUrlRes.json();

      // Step 2: Upload directly to GCS
      const uploadRes = await fetch(signedUrl, {
        method: 'PUT',
        headers: { 'Content-Type': file.type },
        body: file,
      });

      if (!uploadRes.ok) {
        throw new Error('Upload to GCS failed');
      }

      // Step 3: Construct public URL
      const publicUrl = `https://storage.googleapis.com/${process.env.NEXT_PUBLIC_GCS_BUCKET}/${fileName}`;

      return publicUrl;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed';
      setError(message);
      return null;
    } finally {
      setIsUploading(false);
    }
  };

  return { uploadImage, isUploading, error };
}
```

### 5.3 Prisma Schema

```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Category {
  id        String   @id @default(cuid())
  name      String   @unique
  description String?
  imageUrl  String?  // GCS signed URL
  items     FoodItem[]
  createdAt DateTime @default(now())
}

model FoodItem {
  id         String   @id @default(cuid())
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  name       String
  price      Float
  stock      Int      @default(0)
  imageUrl   String?  // GCS signed URL
  description String?
  orderItems OrderItem[]
  createdAt  DateTime @default(now())

  @@index([categoryId])
}

model Order {
  id            String      @id @default(cuid())
  userId        String
  user          User        @relation(fields: [userId], references: [id])
  items         OrderItem[]
  totalPrice    Float
  status        OrderStatus @default(PENDING)
  deliveryAddress String
  proofImageUrl String?     // GCS URL for delivery proof
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  logs          AuditLog[]

  @@index([userId])
  @@index([status])
}

enum OrderStatus {
  PENDING
  ACCEPTED
  PREPARING
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELED
}
```

---

## 6. DEPLOYMENT STRATEGY

### 6.1 Development Environment
```
Frontend & Backend:
└── Vercel (free tier)
    ├── Environment: Next.js App Router (SSR/SSG)
    ├── Preview deployments on PR
    └── Automatic redeployment on git push

Database:
└── Neon (free tier)
    ├── 3GB included
    ├── Auto-suspend when idle
    └── Automatic backup & recovery

Image Storage:
└── Google Cloud Storage
    ├── 5GB free tier (first month)
    └── Developer bucket for testing
```

### 6.2 Production Environment (Year 1)
```
Frontend:
└── Vercel Production
    ├── ~$20/mo (Pro plan for priority support)
    ├── Automatic HTTPS, CDN global
    └── Analytics included

Backend:
└── Next.js API Routes on Vercel
    ├── Serverless functions (pay-per-invocation)
    ├── 100 GB-hours free per month
    └── Estimated: $0-10/mo at launch

Database:
└── Neon Launch Plan
    ├── $19/mo (includes 10GB storage)
    ├── Auto-scaling compute
    └── Point-in-time recovery

Image Storage:
└── Google Cloud Storage
    ├── Estimated: $50-100/mo (at scale)
    │   ├── ~30GB storage
    │   ├── 10GB outbound transfer
    │   └── Request operations
    └── Auto-scaling

Total Monthly Cost (Production Year 1): **~$100-150/mo**

vs.

Original PostgreSQL (self-hosted) + AWS S3: **$80-120/mo**
MongoDB Atlas + GCS: **$120-180/mo**
```

---

## 7. DATA MIGRATION PATH (PostgreSQL Focused)

If you've already started with MongoDB, here's the migration:

### Step 1: Set Up PostgreSQL + Prisma
```bash
# Install Prisma
npm install @prisma/client
npm install -D prisma

# Initialize Neon database
# (Get connection string from Neon dashboard)

# Create schema
npx prisma init
# Edit .env: DATABASE_URL=<neon-connection-string>
```

### Step 2: Define Schema
```bash
npx prisma migrate dev --name init
```

### Step 3: Data Migration Script
```typescript
// scripts/migrate-mongo-to-postgres.ts
import { PrismaClient as PostgresPrisma } from '@prisma/client';
import { MongoClient } from 'mongodb';

async function migrateData() {
  const pgClient = new PostgresPrisma();
  const mongoClient = new MongoClient(process.env.MONGODB_URI!);

  try {
    await mongoClient.connect();
    const mongoDb = mongoClient.db('your-app');

    // Migrate users
    const users = await mongoDb.collection('users').find({}).toArray();
    for (const user of users) {
      await pgClient.user.upsert({
        where: { id: user._id.toString() },
        update: { /* ... */ },
        create: {
          id: user._id.toString(),
          email: user.email,
          role: user.role,
          // ... other fields
        },
      });
    }

    console.log('✅ Migration complete');
  } finally {
    await pgClient.$disconnect();
    await mongoClient.close();
  }
}

migrateData().catch(console.error);
```

---

## 8. SECURITY CHECKLIST (GCS + PostgreSQL)

- [ ] **GCS Bucket Policies**
  - [ ] Block public read (only signed URLs work)
  - [ ] Enable versioning (recover from accidental deletes)
  - [ ] Set lifecycle: delete old versions after 30 days

- [ ] **PostgreSQL (Neon)**
  - [ ] Enable SSL connections (default on Neon)
  - [ ] Set row-level security (users only see own data)
  - [ ] Regular backups (included free with Neon)

- [ ] **Next.js API Routes**
  - [ ] Rate limit `/api/upload` (e.g., 10 uploads/hour per user)
  - [ ] Validate file MIME type server-side
  - [ ] Scan uploads for malware (optional: ClamAV)
  - [ ] Store upload audit logs

- [ ] **Environment Variables**
  - [ ] GCS credentials: `GCS_PRIVATE_KEY` (never in git)
  - [ ] Database URL: encrypted in Vercel secrets
  - [ ] NextAuth secret: Strong random string

---

## 9. FUTURE EXTENSIBILITY

### Phase 1 (MVP - Months 1-3)
- PostgreSQL + Neon
- GCS image storage
- Basic order management
- Email notifications

### Phase 2 (Months 4-6)
- Real-time order tracking (WebSocket layer)
- Analytics dashboard (BigQuery integration)
- GPS tracking for drivers (PostGIS extension on Neon)

### Phase 3 (Months 7-12)
- Payment processing (Stripe API)
- Loyalty program (Redis cache for points)
- Mobile app (React Native sharing API routes)

### Phase 4+ (Year 2+)
- Microservices split (if exceeds $200/mo)
- Machine learning (product recommendations)
- Multi-region replication (Neon supports this)

---

## 10. QUICK START CHECKLIST

### Week 1: Database Setup
- [ ] Create Neon account, set up PostgreSQL
- [ ] Copy `DATABASE_URL` to `.env.local`
- [ ] Run `npx prisma migrate dev --name init`
- [ ] Test connection: `npx prisma studio`

### Week 2: GCS Setup
- [ ] Create Google Cloud project
- [ ] Enable Cloud Storage API
- [ ] Create service account & download JSON key
- [ ] Create GCS bucket (e.g., `myapp-uploads`)
- [ ] Set CORS policy on bucket

### Week 3: Integration
- [ ] Install GCS SDK: `npm install @google-cloud/storage`
- [ ] Implement upload API route (see 5.1)
- [ ] Test frontend upload flow
- [ ] Set up environment variables in Vercel

### Week 4: Deployment
- [ ] Connect Vercel to Neon
- [ ] Deploy to Vercel preview
- [ ] Test production upload flow
- [ ] Set up monitoring (Sentry for errors)

---

## 11. COST PROJECTION (First Year + Scaling)

| Scenario | Database | Storage | Backend | Total/mo |
|----------|----------|---------|---------|----------|
| **MVP (500 users)** | $0 Neon free | $1 GCS | $5 Vercel | **$6** |
| **Growth (5K users)** | $19 Neon Launch | $20 GCS | $10 Vercel | **$49** |
| **Scale (50K users)** | $50 Neon Pro | $80 GCS | $30 Vercel | **$160** |
| **Enterprise (200K+ users)** | $100-200 Neon | $200-400 GCS | $100-200 Vercel | **$400-800** |

**At 50K users:** Still cheaper than self-managed PostgreSQL + S3 ✅

---

## FINAL RECOMMENDATION

| Decision | Recommendation | Rationale |
|----------|----------------|-----------|
| **Database** | PostgreSQL (Neon) | ACID compliance, relational data, cost-effective |
| **Image Storage** | Google Cloud Storage | Competitive pricing, simpler setup, BigQuery integration |
| **Backend Deployment** | Vercel (Next.js API Routes) | Zero-config, auto-scaling, integrated with frontend |
| **Migration Path** | Keep PostgreSQL, skip MongoDB | Avoid operational complexity, maintain Prisma continuity |

---

## References

- Neon Documentation: https://neon.tech/docs
- Google Cloud Storage Setup: https://cloud.google.com/storage/docs/quickstart
- Prisma + Next.js Guide: https://www.prisma.io/nextjs
- Vercel Postgres Integration: https://vercel.com/docs/postgres
- AWS S3 vs GCS Comparison: Industry benchmarks (2025)

---

**Document Status:** Final  
**Next Steps:** Implement Week 1 database setup; feedback welcome  
**Last Updated:** December 8, 2025