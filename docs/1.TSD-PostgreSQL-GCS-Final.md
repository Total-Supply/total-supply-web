# Technical Specification Document (TSD) - FINAL
## Full-Stack E-Commerce & Service Management Platform
**Next.js + PostgreSQL + Google Cloud Storage**

**Document Version:** 3.0 (Production-Ready)  
**Last Updated:** December 9, 2025  
**Status:** Approved for Development  
**Team:** Sri Lankan Startup / University Deployment

---

## EXECUTIVE SUMMARY

This TSD defines a **secure, scalable, cost-efficient** platform combining food e-commerce, cleaning services, and IT support into a single unified application. The stack is **battle-tested**, **production-ready**, and **optimized for Sri Lankan deployment**.

### Final Tech Stack (Authoritative)

**Frontend:**
- Next.js 15 (App Router) + TypeScript + Tailwind CSS + shadcn/ui
- Redux Toolkit + RTK Query for state management
- React Hook Form + Zod for form validation

**Backend:**
- Next.js API Routes (Node.js/Edge runtime) + NextAuth.js
- Prisma ORM for type-safe database access
- Nodemailer for email notifications

**Database:**
- **PostgreSQL on Neon** (managed, auto-scaling, free tier available)
- Point-in-time recovery included
- Connection pooling via Prisma

**File Storage:**
- **Google Cloud Storage** (signed URLs, CDN delivery, competitive pricing)
- Regional bucket in Asia (Singapore) for optimal SL latency
- Direct upload from client → GCS (bypasses server)

**Deployment:**
- **Vercel** for frontend + Next.js API Routes
- Serverless functions (auto-scaling)
- Preview environments for every PR
- Integrated with GitHub/GitLab

---

## 1. SYSTEM OVERVIEW & ARCHITECTURE

### 1.1 Business Capabilities

#### Landing & Portfolio
- ✅ Hero section with brand introduction
- ✅ Services grid: Food Delivery, Cleaning Services, IT Support
- ✅ Testimonials carousel
- ✅ CTA buttons: Register / Login / Contact
- ✅ Responsive mobile design

#### Customer/Shop Owner Portal
- ✅ Browse food items with filters (category, price range, search)
- ✅ Shopping cart with real-time price updates
- ✅ Checkout with address validation
- ✅ Order tracking with status timeline
- ✅ Create/track cleaning service requests
- ✅ Create/track IT support requests
- ✅ Account profile & settings
- ✅ Order history with receipts (PDF export)
- ✅ Image uploads for service photos (GCS integration)

#### Admin Dashboard
- ✅ User management (approve, suspend, role assignment)
- ✅ Product catalog CRUD (categories, items, stock levels)
- ✅ Order management (list, filter, drill-down details)
- ✅ Service request queue management
- ✅ Staff assignment & tracking
- ✅ Analytics: Revenue, order volume, top products
- ✅ Audit logs (all actions tracked with actor/timestamp)
- ✅ Email notification management

#### Staff Dashboards (Role-Based)

**Salesman:**
- ✅ View assigned orders
- ✅ Accept/Prepare orders
- ✅ Mark order status transitions
- ✅ View customer details

**Driver:**
- ✅ Delivery queue
- ✅ Mark as "Out for Delivery"
- ✅ Confirm delivery with photo proof
- ✅ Access Google Maps for directions (future: real GPS)

**Cleaner/IT Staff:**
- ✅ Service request queue (assigned jobs)
- ✅ Accept/decline assignments
- ✅ Update progress (In Progress)
- ✅ Mark complete with before/after photos
- ✅ Schedule management

### 1.2 Business Objectives

1. **Secure Multi-Role Platform** → RBAC with NextAuth + JWT
2. **Reliable Transactional Ordering** → PostgreSQL ACID guarantees
3. **Clear Audit Trails** → Every action logged with actor/reason/timestamp
4. **Image Management** → GCS for scalable file storage
5. **Cost Efficiency** → Pay-as-you-grow model (free tier → enterprise)
6. **Future Extensibility** → Stripe payments, GPS tracking, loyalty program

---

## 2. ARCHITECTURE

### 2.1 System Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                     VERCEL (Frontend + Backend)                 │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Next.js 15 (App Router)                                │  │
│  │  ├─ React Components (Tailwind + shadcn/ui)             │  │
│  │  ├─ Redux Toolkit + RTK Query                           │  │
│  │  └─ NextAuth.js (Session Management)                    │  │
│  └──────────────────┬───────────────────────────────────────┘  │
│                     │                                           │
│  ┌──────────────────▼───────────────────────────────────────┐  │
│  │  Next.js API Routes (Node.js Runtime)                   │  │
│  │  ├─ /api/auth/* (NextAuth endpoints)                    │  │
│  │  ├─ /api/upload (GCS signed URL generation)             │  │
│  │  ├─ /api/orders (CRUD operations)                       │  │
│  │  ├─ /api/services (Service request management)          │  │
│  │  ├─ /api/admin/* (Admin only endpoints)                 │  │
│  │  └─ /api/notifications/email (Nodemailer)               │  │
│  └──────────────────┬───────────────────────────────────────┘  │
│                     │                                           │
└─────────────────────┼───────────────────────────────────────────┘
                      │
                      │ (HTTPS)
                      │
        ┌─────────────┼─────────────┐
        │             │             │
        ▼             ▼             ▼
   ┌─────────┐   ┌─────────┐   ┌──────────────┐
   │ Neon    │   │   GCS   │   │ SendGrid/    │
   │ Postgres│   │ Storage │   │ SMTP Relay   │
   │         │   │         │   │              │
   │ (ACID)  │   │ (CDN)   │   │ (Email)      │
   └─────────┘   └─────────┘   └──────────────┘
        │
   Prisma ORM
   (Type-safe)
```

### 2.2 Data Flow: Food Order (Example)

```
1. Customer selects items in Next.js UI
   ↓
2. Shopping cart stored in Redux (client-side)
   ↓
3. Customer clicks "Checkout"
   ↓
4. Form validation via Zod (client-side)
   ↓
5. Optional: Customer uploads photo → POST /api/upload
   ├─ Backend generates GCS signed URL
   ├─ Frontend uploads directly to GCS
   └─ Returns public URL (stored later)
   ↓
6. Customer submits order → POST /api/orders
   ├─ Server validates with getServerSession()
   ├─ Checks stock levels (PostgreSQL query)
   ├─ Creates Order record (with proofImageUrl if provided)
   ├─ Creates OrderItem records
   ├─ Logs action to AuditLog
   └─ Returns order ID
   ↓
7. Nodemailer sends confirmation email
   ↓
8. Admin dashboard shows "New Order" notification
   ↓
9. Salesman accepts order → status: PENDING → ACCEPTED
   ├─ PostgreSQL transaction updates status
   ├─ AuditLog records action
   └─ Customer notified via email
   ↓
10. Salesman marks prepared → PREPARING → (if needed, photo of items)
    ├─ Optional photo upload to GCS
    └─ Logged in AuditLog
    ↓
11. Driver accepts delivery → OUT_FOR_DELIVERY
    ├─ SMS alert sent (future)
    └─ Logged in AuditLog
    ↓
12. Driver confirms delivery with photo proof
    ├─ Upload photo to GCS
    ├─ Update order: proofImageUrl = GCS URL
    ├─ Status: DELIVERED
    ├─ Email receipt sent to customer
    └─ Logged in AuditLog
```

### 2.3 Technology Stack Detail

| Layer | Technology | Justification |
|-------|-----------|----------------|
| **Frontend UI** | Next.js + React + TypeScript | Type-safe, fast builds, SSR for SEO |
| **Styling** | Tailwind CSS + shadcn/ui | Rapid development, accessible components |
| **State** | Redux Toolkit + RTK Query | Predictable state, data fetching |
| **Forms** | React Hook Form + Zod | Performant, schema validation |
| **Backend** | Next.js API Routes | Collocated frontend/backend, serverless |
| **Auth** | NextAuth.js | Industry standard, stateless JWT |
| **Database** | PostgreSQL (Neon) | ACID, relational, free tier, auto-scaling |
| **ORM** | Prisma | Type-safe, migrations, schema DSL |
| **File Storage** | GCS + signed URLs | CDN, scalable, competitive pricing |
| **Email** | Nodemailer + SendGrid | Reliable transactional emails |
| **Deployment** | Vercel | Zero-config, auto-scaling, integrated |
| **Observability** | Sentry + Next-Logger | Error tracking, request logging |

---

## 3. DETAILED REQUIREMENTS

### 3.1 Functional Requirements

#### FR-1: User Authentication & Authorization
- [ ] Email/password registration with email verification
- [ ] NextAuth credentials provider with bcrypt hashing
- [ ] Admin approval gate before customer access
- [ ] JWT session with role claims (ADMIN, CUSTOMER, SHOP_OWNER, etc.)
- [ ] Role-based middleware for route protection
- [ ] Session timeout after 30 days
- [ ] "Remember me" functionality (optional)

#### FR-2: Food E-Commerce
- [ ] Browse food categories (Beef, Spices, Grains, etc.)
- [ ] Filter by price, rating, availability
- [ ] Full-text search on item name/description
- [ ] Add to cart with quantity
- [ ] Cart persistence (Redis cache + localStorage fallback)
- [ ] Checkout with address validation
- [ ] Order summary with itemized breakdown
- [ ] Image support for food items (GCS URLs)

#### FR-3: Order Management
- [ ] Order creation with transaction isolation
- [ ] Status machine: PENDING → ACCEPTED → PREPARING → OUT_FOR_DELIVERY → DELIVERED
- [ ] Admin can cancel orders (with reason logged)
- [ ] Salesman can accept/prepare orders
- [ ] Driver can confirm delivery with photo proof (uploaded to GCS)
- [ ] Customer can track order in real-time
- [ ] Email notifications at each status change
- [ ] Audit trail for every status transition

#### FR-4: Service Request Management (Cleaning/IT)
- [ ] Create service request (type, description, photos via GCS)
- [ ] Admin assigns to available staff
- [ ] Staff accept/decline with reason
- [ ] Status machine: RECEIVED → ASSIGNED → IN_PROGRESS → RESOLVED
- [ ] Before/after photo uploads (GCS)
- [ ] Priority levels (LOW, MEDIUM, HIGH, URGENT)
- [ ] Scheduling: Date/time slots for service
- [ ] Customer can cancel request (with reason)
- [ ] Audit trail for every action

#### FR-5: Admin Dashboard
- [ ] User approval queue (with pagination)
- [ ] User role management
- [ ] Suspend/reactivate users
- [ ] Catalog management: CRUD categories, items, stock
- [ ] Bulk upload items (CSV → PostgreSQL)
- [ ] Order analytics: daily volume, revenue, top items
- [ ] Service request queue
- [ ] Staff performance metrics
- [ ] Audit log viewer (search, filter by actor/entity)
- [ ] Email template management

#### FR-6: Image Upload & Storage
- [ ] GCS bucket integration with signed URLs
- [ ] Server-side validation: file type, size (max 5MB)
- [ ] Direct client→GCS upload (no server bottleneck)
- [ ] Rate limiting: 10 uploads per user per hour
- [ ] Image compression (client-side via Sharp)
- [ ] Served via CDN (Google Cloud CDN automatic)
- [ ] EXIF data stripping for privacy

#### FR-7: Email Notifications
- [ ] Order confirmation email
- [ ] Status change notifications
- [ ] Service request assignment email
- [ ] Weekly order summary for customers
- [ ] Admin alerts for high-priority issues
- [ ] Unsubscribe functionality

### 3.2 Non-Functional Requirements

#### Performance
- [ ] Page load time < 2 seconds (90th percentile)
- [ ] Order creation API < 500ms
- [ ] Image upload < 3 seconds (5MB file)
- [ ] Search queries < 200ms (10K records)
- [ ] Pagination: 50 items per page

#### Scalability
- [ ] Support 50K concurrent users
- [ ] PostgreSQL: Auto-scaling with Neon
- [ ] Vercel: Unlimited serverless functions
- [ ] GCS: Unlimited storage & egress
- [ ] Horizontal scaling ready (stateless API)

#### Security
- [ ] HTTPS only (enforced via Vercel)
- [ ] HSTS header (1 year)
- [ ] CSRF protection (NextAuth built-in)
- [ ] XSS prevention (DOMPurify for rich text)
- [ ] SQL injection prevention (Prisma parameterized queries)
- [ ] Rate limiting: 100 req/min per IP
- [ ] JWT secret rotation (60 days)
- [ ] Audit log immutable (append-only)

#### Availability
- [ ] 99.9% uptime SLA (Vercel + Neon)
- [ ] RTO: 1 hour (database backup)
- [ ] RPO: 15 minutes (Neon point-in-time recovery)
- [ ] Auto-failover for database connections
- [ ] CDN fallback for image delivery

#### Compliance
- [ ] GDPR: Data export for users (done via Prisma)
- [ ] GDPR: Data deletion (cascade delete)
- [ ] Local data residency (GCS Asia region)
- [ ] PCI-DSS ready (no payment processing in MVP)
- [ ] Audit trails retained for 2 years

---

## 4. SECURITY & COMPLIANCE

### 4.1 Authentication & Authorization

#### Session Management
```typescript
// NextAuth JWT session with minimal payload
interface JWT {
  sub: string;              // User ID
  email: string;
  role: 'ADMIN' | 'CUSTOMER' | 'SALESMAN' | 'DRIVER' | 'CLEANER' | 'IT_STAFF';
  isApproved: boolean;      // Gated access until approved
  iat: number;              // Issued at
  exp: number;              // Expires in 30 days
}

// Server-side role check
async function assertRole(session, allowedRoles: string[]) {
  if (!session?.user?.role || !allowedRoles.includes(session.user.role)) {
    throw new UnauthorizedError('Insufficient permissions');
  }
}
```

#### Password Security
- ✅ Bcrypt hashing via NextAuth adapter (10 salt rounds)
- ✅ Password min 8 characters, complexity rules
- ✅ No password history reuse
- ✅ Email verification before account activation
- ✅ Admin approval before customer access

### 4.2 GCS Security

#### Bucket Configuration
```json
{
  "bucketName": "myapp-uploads-prod",
  "location": "asia-southeast1",
  "storageClass": "STANDARD",
  "publicAccessPrevention": "ENFORCED",
  "uniformBucketLevelAccess": true,
  "versioningEnabled": true,
  "lifecycleRules": [
    {
      "action": "Delete",
      "condition": { "age": 30 }  // Delete old versions after 30 days
    }
  ]
}
```

#### Signed URL Security
- ✅ Valid for 15 minutes only
- ✅ Includes content-type header check
- ✅ Limited to specific service account (no public access)
- ✅ Logs all PUT operations in GCS audit trail

### 4.3 PostgreSQL Security

#### Connection Security
```
DATABASE_URL=postgresql://user:password@ep-xxx.neon.tech/dbname?sslmode=require
```
- ✅ SSL/TLS enforced (Neon default)
- ✅ No unencrypted connections allowed
- ✅ Connection pooling via Prisma (prevents connection bombing)

#### Data Protection
```sql
-- Row-Level Security (optional, future enhancement)
CREATE POLICY user_isolation ON orders
  FOR SELECT USING (user_id = current_user_id);

-- Audit triggers
CREATE TRIGGER audit_order_update AFTER UPDATE ON orders
  FOR EACH ROW EXECUTE FUNCTION log_audit();
```

### 4.4 API Security

#### Rate Limiting
```typescript
// Per-IP: 100 requests/minute
// Per-user: 10 uploads/hour, 50 orders/day
// Per-endpoint specific limits

import { Ratelimit } from '@upstash/ratelimit';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(100, '60 s'),
});

export async function middleware(req) {
  const ip = req.ip || req.headers.get('x-forwarded-for');
  const { success } = await ratelimit.limit(ip);
  
  if (!success) return new Response('Rate limit exceeded', { status: 429 });
}
```

#### CORS & XSS
- ✅ CORS locked to own domain (Vercel)
- ✅ Content-Security-Policy header set
- ✅ X-Frame-Options: DENY
- ✅ DOMPurify for admin-entered rich text

#### CSRF
- ✅ Built-in NextAuth CSRF tokens
- ✅ SameSite=Lax cookie policy
- ✅ POST endpoints require valid session

### 4.5 Data Privacy

#### Audit Logging
```sql
CREATE TABLE AuditLog (
  id CUID PRIMARY KEY,
  entityType VARCHAR(50),        -- 'Order', 'Service', 'User'
  entityId CUID,
  action VARCHAR(20),            -- 'CREATE', 'UPDATE', 'DELETE'
  actorId CUID FOREIGN KEY User,
  details TEXT,                  -- JSON payload (sanitized)
  ip_address INET,
  user_agent TEXT,
  createdAt TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_audit_entity ON AuditLog(entityType, entityId);
CREATE INDEX idx_audit_actor ON AuditLog(actorId);
```

#### Data Minimization
- ✅ Only collect email, name, address (no SSN, credit card)
- ✅ Images: Store in GCS, reference by URL in DB
- ✅ No sensitive data in logs

#### Deletion Policy
```sql
-- User deletion cascades to orders, services, audit logs (anonymized)
DELETE FROM users WHERE id = '...';

-- Anonymization for GDPR:
UPDATE users SET 
  email = MD5(CONCAT(id, 'anonymized')),
  name = 'Deleted User',
  address = NULL
WHERE id = '...'
```

---

## 5. DATABASE SCHEMA

### 5.1 Entity Relationship Diagram (Text)

```
User (1) ──────────────────┬────────────── (M) Order
  ├─ id (PK)               │
  ├─ email (UQ)            └────────────── (M) ServiceRequest
  ├─ passwordHash          │
  ├─ role (ENUM)           └────────────── (1) StaffProfile
  ├─ isApproved (Bool)
  └─ createdAt

Order (1) ────────────────────── (M) OrderItem
  ├─ id (PK)               │
  ├─ userId (FK)           └────────────── (M) FoodItem
  ├─ status (ENUM)
  ├─ totalPrice
  ├─ proofImageUrl (GCS)
  ├─ createdAt
  └─ updatedAt

ServiceRequest (1) ────────────────────── (1) StaffAssignment
  ├─ id (PK)               │
  ├─ userId (FK)           └─ (FK) User (staff)
  ├─ status (ENUM)
  ├─ type (ENUM: CLEANING, IT_SUPPORT)
  ├─ imageUrl (GCS)
  ├─ priority
  ├─ scheduledDate
  ├─ createdAt
  └─ updatedAt

FoodItem (M) ────────────────────── (1) Category
  ├─ id (PK)
  ├─ categoryId (FK)
  ├─ name
  ├─ price
  ├─ stock
  ├─ imageUrl (GCS)
  └─ description

AuditLog (append-only)
  ├─ id (PK)
  ├─ entityType, entityId
  ├─ action (CREATE|UPDATE|DELETE)
  ├─ actorId (FK)
  ├─ details (JSON)
  ├─ ipAddress
  └─ createdAt
```

### 5.2 Full Prisma Schema

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ============ USERS & AUTH ============

model User {
  id            String      @id @default(cuid())
  email         String      @unique
  passwordHash  String
  firstName     String
  lastName      String
  phoneNumber   String?
  
  role          Role        @default(CUSTOMER)
  isApproved    Boolean     @default(false)  // Gate: Admin approval required
  isSuspended   Boolean     @default(false)
  
  address       String?
  city          String?
  postalCode    String?
  
  // Relations
  orders        Order[]
  serviceRequests ServiceRequest[]
  staffProfile  StaffProfile?
  staffAssignments StaffAssignment[]
  auditLogs     AuditLog[]
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([email])
  @@index([role])
  @@index([isApproved])
}

enum Role {
  ADMIN
  CUSTOMER
  SHOP_OWNER
  SALESMAN
  DRIVER
  CLEANER
  IT_STAFF
}

model StaffProfile {
  id            String      @id @default(cuid())
  userId        String      @unique
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  department    String      // "Sales", "Delivery", "Cleaning", "IT Support"
  joinDate      DateTime    @default(now())
  rating        Float       @default(5.0)  // Out of 5 stars
  totalJobs     Int         @default(0)
  completedJobs Int         @default(0)
  
  assignedServices StaffAssignment[]
}

// ============ PRODUCTS ============

model Category {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  imageUrl    String?     // GCS URL
  
  items       FoodItem[]
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}

model FoodItem {
  id          String      @id @default(cuid())
  categoryId  String
  category    Category    @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  name        String
  description String?
  price       Float
  stock       Int         @default(0)
  imageUrl    String?     // GCS URL
  sku         String      @unique
  
  orderItems  OrderItem[]
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  @@index([categoryId])
  @@index([sku])
}

// ============ ORDERS ============

model Order {
  id                String      @id @default(cuid())
  userId            String
  user              User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  items             OrderItem[]
  totalPrice        Float
  status            OrderStatus @default(PENDING)
  
  deliveryAddress   String
  deliveryCity      String
  deliveryPostal    String
  
  notes             String?
  proofImageUrl     String?     // GCS URL: delivery photo
  
  assignedSalesmanId String?
  assignedDriverId  String?
  
  logs              AuditLog[]
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

enum OrderStatus {
  PENDING           // New order, awaiting acceptance
  ACCEPTED          // Salesman accepted
  PREPARING         // Being prepared
  OUT_FOR_DELIVERY  // Driver has package
  DELIVERED         // Customer received
  CANCELED          // Canceled by admin (reason logged)
}

model OrderItem {
  id          String      @id @default(cuid())
  orderId     String
  order       Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  foodItemId  String
  foodItem    FoodItem    @relation(fields: [foodItemId], references: [id])
  
  quantity    Int
  unitPrice   Float       // Price at time of order
  
  @@unique([orderId, foodItemId])
  @@index([orderId])
}

// ============ SERVICES ============

model ServiceRequest {
  id              String          @id @default(cuid())
  userId          String
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type            ServiceType
  description     String
  imageUrl        String?         // GCS URL: before photos
  
  status          ServiceStatus   @default(RECEIVED)
  priority        Priority        @default(MEDIUM)
  
  scheduledDate   DateTime?
  completedDate   DateTime?
  completionNotes String?
  
  assignment      StaffAssignment?
  logs            AuditLog[]
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([scheduledDate])
}

enum ServiceType {
  CLEANING
  IT_SUPPORT
}

enum ServiceStatus {
  RECEIVED        // New request
  ASSIGNED        // Assigned to staff
  IN_PROGRESS     // Staff working on it
  RESOLVED        // Completed
  CANCELED        // Canceled by user/admin
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model StaffAssignment {
  id                String          @id @default(cuid())
  serviceRequestId  String          @unique
  serviceRequest    ServiceRequest  @relation(fields: [serviceRequestId], references: [id], onDelete: Cascade)
  
  staffId           String
  staff             User            @relation(fields: [staffId], references: [id])
  
  assignmentDate    DateTime        @default(now())
  acceptanceDate    DateTime?
  completionDate    DateTime?
  
  status            AssignmentStatus @default(PENDING)
  notes             String?
  
  @@index([staffId])
  @@index([status])
}

enum AssignmentStatus {
  PENDING         // Waiting for staff acceptance
  ACCEPTED        // Staff accepted
  REJECTED        // Staff declined
  COMPLETED       // Job done
}

// ============ NOTIFICATIONS ============

model EmailNotification {
  id          String      @id @default(cuid())
  userId      String
  
  type        NotificationType
  entityType  String      // "Order", "Service"
  entityId    String
  
  subject     String
  body        String      // HTML email body
  
  sentAt      DateTime?
  failureReason String?
  
  createdAt   DateTime    @default(now())

  @@index([userId])
  @@index([sentAt])
}

enum NotificationType {
  ORDER_CONFIRMATION
  ORDER_STATUS_CHANGE
  SERVICE_ASSIGNED
  SERVICE_COMPLETE
  DELIVERY_CONFIRMATION
  WEEKLY_SUMMARY
}

// ============ AUDIT LOG (Immutable) ============

model AuditLog {
  id          String      @id @default(cuid())
  
  entityType  String      // "Order", "ServiceRequest", "User", etc.
  entityId    String
  action      String      // "CREATE", "UPDATE", "DELETE", "STATUS_CHANGE"
  
  actorId     String
  actor       User        @relation(fields: [actorId], references: [id])
  
  details     String?     // JSON: { field: oldValue → newValue }
  reason      String?     // Why (e.g., cancellation reason)
  
  ipAddress   String?
  userAgent   String?
  
  createdAt   DateTime    @default(now())

  @@index([entityType, entityId])
  @@index([actorId])
  @@index([createdAt])
}
```

---

## 6. API ENDPOINTS

### 6.1 Authentication Routes

| Method | Endpoint | Auth | Purpose |
|--------|----------|------|---------|
| POST | `/api/auth/register` | ❌ | User registration + email verification |
| POST | `/api/auth/callback/credentials` | ❌ | Credentials login (NextAuth) |
| POST | `/api/auth/signout` | ✅ | Logout |
| GET | `/api/auth/session` | ✅ | Get current session |
| POST | `/api/auth/verify-email` | ❌ | Verify email token |

### 6.2 Upload Routes

| Method | Endpoint | Auth | Body | Purpose |
|--------|----------|------|------|---------|
| POST | `/api/upload` | ✅ CUSTOMER+ | `{filename, fileType}` | Get GCS signed URL |
| GET | `/api/upload/verify` | ✅ CUSTOMER+ | `{gcsUrl}` | Verify upload completed |

### 6.3 Food & Orders Routes

| Method | Endpoint | Auth | Purpose |
|--------|----------|------|---------|
| GET | `/api/categories` | ❌ | List all categories |
| GET | `/api/categories/[id]/items` | ❌ | Get items in category |
| GET | `/api/items` | ❌ | Search/filter all items |
| GET | `/api/items/[id]` | ❌ | Get item details |
| POST | `/api/orders` | ✅ CUSTOMER | Create order |
| GET | `/api/orders` | ✅ CUSTOMER | Get my orders |
| GET | `/api/orders/[id]` | ✅ CUSTOMER | Get order details |
| PATCH | `/api/orders/[id]/status` | ✅ STAFF | Update order status |
| PATCH | `/api/orders/[id]/cancel` | ✅ ADMIN | Cancel order (reason required) |

### 6.4 Service Request Routes

| Method | Endpoint | Auth | Purpose |
|--------|----------|------|---------|
| POST | `/api/services` | ✅ CUSTOMER | Create service request |
| GET | `/api/services` | ✅ CUSTOMER | Get my requests |
| GET | `/api/services/[id]` | ✅ CUSTOMER/STAFF | Get details |
| PATCH | `/api/services/[id]/status` | ✅ STAFF | Update status |
| POST | `/api/services/[id]/assign` | ✅ ADMIN | Assign staff |
| POST | `/api/services/[id]/accept` | ✅ STAFF | Accept assignment |

### 6.5 Admin Routes

| Method | Endpoint | Auth | Purpose |
|--------|----------|------|---------|
| GET | `/api/admin/users` | ✅ ADMIN | List users (paginated) |
| PATCH | `/api/admin/users/[id]/approve` | ✅ ADMIN | Approve user |
| PATCH | `/api/admin/users/[id]/suspend` | ✅ ADMIN | Suspend user |
| PATCH | `/api/admin/users/[id]/role` | ✅ ADMIN | Change user role |
| GET | `/api/admin/orders` | ✅ ADMIN | List all orders (filters) |
| GET | `/api/admin/services` | ✅ ADMIN | List all service requests |
| GET | `/api/admin/analytics` | ✅ ADMIN | Revenue, order volume, etc. |
| GET | `/api/admin/audit-logs` | ✅ ADMIN | Search audit logs |

---

## 7. STATUS MACHINES & WORKFLOWS

### 7.1 Order Status Machine

```
PENDING (Initial)
  ↓ [Salesman clicks Accept]
  ACCEPTED
  ↓ [Salesman clicks Prepare]
  PREPARING
  ↓ [Driver picks up]
  OUT_FOR_DELIVERY
  ↓ [Driver confirms + photo proof]
  DELIVERED (Final)

From ANY state:
  ↓ [Admin clicks Cancel + reason]
  CANCELED (Final)

Business Rules:
✅ Only salesman can transition PENDING → ACCEPTED
✅ Only salesman can transition ACCEPTED → PREPARING
✅ Only driver can transition PREPARING → OUT_FOR_DELIVERY
✅ Only driver can transition OUT_FOR_DELIVERY → DELIVERED (requires photo)
✅ Only admin can cancel (with reason audit logged)
✅ Cannot transition if required fields missing (e.g., driver assignment)
```

### 7.2 Service Request Status Machine

```
RECEIVED (Initial)
  ↓ [Admin assigns staff]
  ASSIGNED
  ↓ [Staff accepts]
  IN_PROGRESS
  ↓ [Staff completes + notes]
  RESOLVED (Final)

From ANY state:
  ↓ [Admin/User cancels + reason]
  CANCELED (Final)

From ASSIGNED:
  ↓ [Staff declines]
  RECEIVED (returns to queue)

Business Rules:
✅ Only assigned staff can move to IN_PROGRESS
✅ Only assigned staff can move to RESOLVED (with completion notes)
✅ Can schedule for future date (scheduledDate field)
✅ Priority affects queue ordering (URGENT first)
✅ All transitions logged in AuditLog
```

### 7.3 User Approval Workflow

```
New User Registration
  ↓ [Email verification sent]
Waiting for Email Verification
  ↓ [User clicks email link]
Verified (isApproved = false)
  ↓ [Admin reviews in dashboard]
  ↓ [Admin clicks Approve]
Approved (isApproved = true, can access platform)

Or:
  ↓ [Admin clicks Suspend]
Suspended (isSuspended = true, cannot login)
```

---

## 8. IMAGE MANAGEMENT (GCS Integration)

### 8.1 Upload Flow

```
1. User selects file in Next.js form
   └─ Client-side validation (type, size)

2. Frontend calls POST /api/upload
   ├─ Backend checks auth & rate limit
   ├─ Validates file metadata
   ├─ Generates GCS signed URL (valid 15 min)
   └─ Returns signed URL to frontend

3. Frontend uploads directly to GCS
   ├─ PUT request with signed URL
   ├─ No server involved (direct client→GCS)
   └─ Returns 200 OK

4. Frontend gets public GCS URL
   └─ Stored in database (proofImageUrl, imageUrl fields)

5. Database saves URL reference (not file blob)
   └─ Lightweight, fast queries

6. Images served via CDN (Google Cloud CDN)
   └─ Fast, global distribution to Sri Lanka
```

### 8.2 GCS Bucket Configuration

```json
{
  "name": "myapp-uploads-prod",
  "location": "asia-southeast1",       // Singapore for SL proximity
  "storageClass": "STANDARD",          // Cost-effective
  "publicAccessPrevention": "ENFORCED",
  "uniformBucketLevelAccess": true,
  "versioning": {
    "enabled": true
  },
  "lifecycle": {
    "rule": [
      {
        "action": { "type": "Delete" },
        "condition": { "numNewerVersions": 1 }  // Keep only current version
      }
    ]
  },
  "cors": [
    {
      "origin": ["https://myapp.vercel.app"],
      "method": ["PUT"],
      "responseHeader": ["Content-Type"],
      "maxAgeSeconds": 3600
    }
  ]
}
```

### 8.3 Image Types & Storage

| Image Type | Entity | Max Size | Retention |
|------------|--------|----------|-----------|
| Food item photo | FoodItem.imageUrl | 2MB | Permanent |
| Category photo | Category.imageUrl | 2MB | Permanent |
| Order proof (delivery) | Order.proofImageUrl | 5MB | 2 years |
| Service before photo | ServiceRequest.imageUrl | 5MB | 2 years |
| Service after photo | StaffAssignment.afterImageUrl | 5MB | 2 years |

---

## 9. EMAIL NOTIFICATIONS

### 9.1 Email Templates

| Event | Recipient | Template | Trigger |
|-------|-----------|----------|---------|
| Welcome | New user | Verify email link | Registration |
| Order Confirmation | Customer | Order #, items, total | Order created |
| Order Accepted | Customer | Salesman name, ETA | Status → ACCEPTED |
| Order Preparing | Customer | Preparing message | Status → PREPARING |
| Out for Delivery | Customer | Driver name, phone | Status → OUT_FOR_DELIVERY |
| Delivery Confirmed | Customer | Receipt, PDF link | Status → DELIVERED |
| Service Assigned | Staff | Details, date/time | Assignment created |
| Service Complete | Customer | Rating prompt | Status → RESOLVED |
| Weekly Summary | Customer | Orders, spending | Every Monday 9 AM |

### 9.2 Email Service (Nodemailer)

```typescript
// Using SendGrid SMTP relay
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  host: process.env.SENDGRID_HOST,    // smtp.sendgrid.net
  port: 587,
  auth: {
    user: 'apikey',
    pass: process.env.SENDGRID_API_KEY,
  },
});

// Send example
await transporter.sendMail({
  from: 'noreply@myapp.com',
  to: customer.email,
  subject: `Order #${order.id} Delivered`,
  html: `<h1>Delivery Confirmed</h1>...`,
  attachments: [
    {
      filename: 'receipt.pdf',
      path: '/tmp/receipt.pdf',
    },
  ],
});
```

---

## 10. DEPLOYMENT STRATEGY

### 10.1 Infrastructure Stack

```
Development (Free)
├─ Vercel: Next.js dev branch
├─ Neon: Free tier (3GB, 4 connections)
└─ GCS: Free tier (5GB/month egress)

Staging
├─ Vercel: Preview deployments (automatic on PR)
├─ Neon: Staging database (separate project)
└─ GCS: Staging bucket

Production
├─ Vercel: Main branch deployment
│  ├─ Auto-scaling serverless functions
│  ├─ CDN caching for Next.js assets
│  └─ Analytics & monitoring built-in
├─ Neon: Production database
│  ├─ Auto-scaling compute
│  ├─ Point-in-time recovery (included)
│  ├─ Automated backups (daily)
│  └─ Connection pooling
└─ GCS: Production bucket
   ├─ CDN delivery (Google Cloud CDN)
   ├─ Versioning enabled
   ├─ Lifecycle policies (30-day retention)
   └─ Regional redundancy
```

### 10.2 Deployment Pipeline

```
GitHub Push (main branch)
  ↓ [GitHub Actions]
  Run Tests & Linting
  ├─ npm run test
  ├─ npm run lint
  └─ type-check
  ↓ [All pass]
  Build Next.js
  ├─ npm run build
  └─ Output: .next/
  ↓
  Deploy to Vercel
  ├─ Upload .next/ + public/
  ├─ Run database migrations (Vercel Postgres integration)
  └─ Health check endpoint
  ↓
  Production Live
  ├─ HTTPS enabled automatically
  ├─ CDN cache warmed
  └─ Email alerts sent

Rollback (if needed):
  ↓ [GitHub: Revert commit]
  Vercel auto-redeploys previous commit
```

### 10.3 Cost Breakdown (Sri Lankan Rupees/Month)

#### Free Tier (Development)
```
Neon PostgreSQL:     LKR 0     (free: 3GB)
GCS Storage:         LKR 0     (free: 5GB egress/month)
Vercel:              LKR 0     (free: 100GB-hours)
SendGrid:            LKR 0     (free: 100 emails/day)
                     ─────────
TOTAL:               LKR 0/month
```

#### Startup Tier (500-5K users, Year 1)
```
Neon PostgreSQL:     LKR 2,500   ($19/mo Launch plan)
GCS Storage:         LKR 2,600   ($20/mo avg)
Vercel Pro:          LKR 3,250   ($25/mo)
SendGrid:            LKR 1,300   ($10/mo for 10K emails)
Monitoring (Sentry): LKR 1,300   ($10/mo)
                     ─────────
TOTAL:               LKR 10,950/month (~USD $85/month)
```

#### Growth Tier (10K-50K users)
```
Neon:                LKR 6,500   ($50/mo with scaling)
GCS:                 LKR 10,400  ($80/mo for 30GB storage)
Vercel:              LKR 3,900   ($30/mo)
SendGrid:            LKR 3,250   ($25/mo for 100K emails)
Monitoring:          LKR 1,300   ($10/mo)
                     ─────────
TOTAL:               LKR 25,350/month (~USD $195/month)
```

#### Enterprise Tier (100K+ users)
```
Neon:                LKR 13,000  ($100/mo dedicated)
GCS:                 LKR 26,000  ($200/mo large scale)
Vercel:              LKR 13,000  ($100/mo pro plan)
SendGrid:            LKR 6,500   ($50/mo)
Monitoring:          LKR 2,600   ($20/mo advanced)
                     ─────────
TOTAL:               LKR 61,100/month (~USD $470/month)
```

---

## 11. SECURITY CHECKLIST

- [ ] HTTPS enforced (Vercel default)
- [ ] HSTS header set (1 year)
- [ ] CSRF tokens on all POST/PUT/DELETE
- [ ] Rate limiting configured (Upstash)
- [ ] Password hashing (bcrypt 10 rounds)
- [ ] Email verification required
- [ ] Admin approval gate enabled
- [ ] JWT secret rotated (60 days)
- [ ] GCS bucket: public access blocked
- [ ] GCS bucket: versioning enabled
- [ ] GCS bucket: lifecycle policies set
- [ ] PostgreSQL: SSL/TLS enforced
- [ ] Secrets in Vercel environment (not .env)
- [ ] Audit logging immutable (append-only)
- [ ] XSS prevention (DOMPurify)
- [ ] SQL injection prevention (Prisma)
- [ ] CORS locked to own domain
- [ ] Content-Security-Policy header set
- [ ] X-Frame-Options: DENY
- [ ] Sentry error tracking enabled
- [ ] Request logging with correlation IDs

---

## 12. MONITORING & OBSERVABILITY

### 12.1 Key Metrics

```typescript
// Sentry setup
import * as Sentry from "@sentry/nextjs";

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
  integrations: [
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
});

// Application logging
import pino from 'pino';

const logger = pino({
  transport: {
    target: 'pino-pretty',
    options: { colorize: true },
  },
});

// Example: Log order creation
logger.info({
  event: 'order_created',
  orderId: order.id,
  userId: session.user.id,
  totalPrice: order.totalPrice,
  itemCount: order.items.length,
});
```

### 12.2 Monitoring Dashboards

| Metric | Tool | Alert Threshold |
|--------|------|-----------------|
| Error rate | Sentry | > 1% |
| API latency (p95) | Vercel Analytics | > 1 second |
| Database connections | Neon | > 80% pool usage |
| GCS egress | Google Cloud | > $200/day |
| Email failure rate | SendGrid | > 5% |
| Uptime | Vercel | < 99.9% SLA |

---

## 13. DEVELOPMENT ROADMAP

### Phase 1 (MVP - Months 1-2)
- ✅ User auth (email/password, NextAuth)
- ✅ Food catalog (browse, add to cart)
- ✅ Ordering (checkout, confirmation email)
- ✅ Admin dashboard (user approval, order list)
- ✅ Salesman dashboard (accept/prepare orders)
- ✅ Driver dashboard (delivery confirmation with photo)
- ✅ GCS image uploads (food & delivery photos)
- ✅ Deploy to Vercel + Neon

### Phase 2 (Service Features - Months 3-4)
- [ ] Service request creation (Cleaning, IT Support)
- [ ] Admin service queue management
- [ ] Staff assignment workflow
- [ ] Service status tracking
- [ ] Before/after photo uploads (GCS)
- [ ] Scheduling for service appointments
- [ ] Service completion email

### Phase 3 (Analytics & Scale - Months 5-6)
- [ ] Admin analytics dashboard (revenue, top products)
- [ ] Customer order history & receipts (PDF)
- [ ] Staff performance metrics
- [ ] Search & filtering improvements
- [ ] BigQuery integration (future)

### Phase 4 (Payments & Advanced - Months 7-12)
- [ ] Stripe payment integration
- [ ] Order total calculation with taxes
- [ ] Wallet/prepaid account
- [ ] Real GPS tracking for drivers
- [ ] Loyalty program (points/discounts)
- [ ] Mobile app (React Native, shared API)
- [ ] Real-time order updates (WebSocket)

### Phase 5+ (Enterprise Features - Year 2+)
- [ ] Multi-vendor support
- [ ] Inventory management
- [ ] Supplier integration
- [ ] Franchise management
- [ ] Machine learning recommendations
- [ ] Advanced analytics (BigQuery)
- [ ] Multi-region deployment

---

## 14. GLOSSARY & DEFINITIONS

| Term | Definition |
|------|-----------|
| **ACID** | Atomicity, Consistency, Isolation, Durability (database transaction guarantees) |
| **GCS** | Google Cloud Storage (image/file hosting) |
| **JWT** | JSON Web Token (stateless authentication) |
| **NextAuth** | Authentication library for Next.js |
| **ORM** | Object-Relational Mapping (Prisma) |
| **Prisma** | Type-safe database client + migrations |
| **Neon** | Managed PostgreSQL hosting |
| **Vercel** | Serverless deployment platform for Next.js |
| **CDN** | Content Delivery Network (fast global distribution) |
| **Signed URL** | Time-limited URL to access/upload to GCS |
| **RBAC** | Role-Based Access Control |
| **Audit Log** | Immutable record of all system actions |
| **ETR** | Estimated Time to Resolve (for services) |
| **SKU** | Stock-Keeping Unit (product identifier) |

---

## 15. APPENDICES

### A. Environment Variables

```bash
# Database
DATABASE_URL=postgresql://user:pass@ep-xxx.neon.tech/dbname

# NextAuth
NEXTAUTH_SECRET=<strong-random-string>
NEXTAUTH_URL=https://myapp.vercel.app

# GCS
NEXT_PUBLIC_GCS_BUCKET=myapp-uploads-prod
GCS_PROJECT_ID=myapp-gcs-12345
GCS_CLIENT_EMAIL=app-uploader@myapp-gcs.iam.gserviceaccount.com
GCS_PRIVATE_KEY=<json-key-from-service-account>

# Email
SENDGRID_API_KEY=<sendgrid-api-key>
SENDGRID_HOST=smtp.sendgrid.net

# Monitoring
SENTRY_DSN=<sentry-dsn>

# Rate Limiting
UPSTASH_REDIS_REST_URL=<upstash-url>
UPSTASH_REDIS_REST_TOKEN=<upstash-token>
```

### B. Database Initialization

```bash
# 1. Install dependencies
npm install @prisma/client prisma next-auth nodemailer

# 2. Initialize Prisma
npx prisma init

# 3. Create migrations
npx prisma migrate dev --name init

# 4. Generate Prisma client
npx prisma generate

# 5. Seed initial data (optional)
npx prisma db seed

# 6. Open Prisma Studio
npx prisma studio
```

### C. Key Implementation Files

```
project-root/
├─ app/
│  ├─ (auth)/
│  │  ├─ register/page.tsx
│  │  └─ login/page.tsx
│  ├─ (dashboard)/
│  │  ├─ customer/orders/page.tsx
│  │  ├─ admin/users/page.tsx
│  │  └─ staff/queue/page.tsx
│  └─ api/
│     ├─ auth/[...nextauth]/route.ts
│     ├─ upload/route.ts
│     ├─ orders/route.ts
│     ├─ services/route.ts
│     └─ admin/
├─ lib/
│  ├─ auth.ts (NextAuth config)
│  ├─ prisma.ts (Prisma client)
│  └─ gcs.ts (Google Cloud Storage client)
├─ hooks/
│  ├─ useImageUpload.ts
│  └─ useOrders.ts
├─ components/
│  ├─ OrderForm.tsx
│  ├─ ProductCard.tsx
│  └─ AdminDashboard.tsx
├─ prisma/
│  ├─ schema.prisma
│  └─ migrations/
└─ .env.local
```

---

## DOCUMENT APPROVAL & SIGN-OFF

| Role | Name | Date | Signature |
|------|------|------|-----------|
| Product Owner | [Name] | [Date] | ☐ |
| Tech Lead | [Name] | [Date] | ☐ |
| Security Lead | [Name] | [Date] | ☐ |
| Project Manager | [Name] | [Date] | ☐ |

---

## REVISION HISTORY

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | Aug 2024 | Initial team | Original TSD |
| 2.0 | Nov 2024 | Team | Added Prisma schema |
| 3.0 | Dec 9, 2025 | Tech Review | **PostgreSQL + GCS finalized, cost analysis added, implementation guides created** |

---

**END OF TECHNICAL SPECIFICATION DOCUMENT**

**Next Steps:** Review this TSD with stakeholders → Approve → Begin development with Implementation Guide (separate document) → Deploy Phase 1 (MVP) within 8 weeks.