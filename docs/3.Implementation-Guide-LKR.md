# Implementation Guide: Next.js + PostgreSQL + GCS for Sri Lankan Developers

**Target Audience:** University of Moratuwa students / Sri Lankan startups  
**Currency:** Sri Lankan Rupees (LKR)  
**Difficulty:** Intermediate (assumes Next.js knowledge)

---

## Part 1: Environment Setup (30 minutes)

### Step 1.1: Neon PostgreSQL Setup

```bash
# 1. Go to https://neon.tech and sign up (free tier)
# 2. Create a new project: "myapp-prod"
# 3. Click "Connect" → Copy connection string
# 4. Add to your .env.local:

DATABASE_URL=postgresql://username:password@ep-xxx.neon.tech/dbname
```

**Verify Connection:**
```bash
npm install @prisma/client prisma
npx prisma db push  # Creates tables from schema
npx prisma studio  # Opens database GUI
```

---

### Step 1.2: Google Cloud Storage Setup

#### Create GCS Bucket
```bash
# 1. Go to https://console.cloud.google.com
# 2. Create new project: "myapp-gcs"
# 3. Enable Cloud Storage API
# 4. Create bucket: "myapp-uploads-[your-id]"
#    Region: Asia (Singapore) for fastest delivery to SL
#    Storage class: Standard
# 5. Block public access by default
```

#### Create Service Account
```bash
# 1. Go to IAM & Admin → Service Accounts
# 2. Create service account: "app-uploader"
# 3. Grant role: "Storage Object Admin"
# 4. Create JSON key → Download
# 5. Add to .env.local:

GCS_PROJECT_ID=myapp-gcs-12345
GCS_CLIENT_EMAIL=app-uploader@myapp-gcs.iam.gserviceaccount.com
GCS_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----"
GCS_BUCKET_NAME=myapp-uploads-abc
```

**Test Connection:**
```typescript
// test-gcs.ts
import { Storage } from '@google-cloud/storage';

const storage = new Storage({
  projectId: process.env.GCS_PROJECT_ID,
  credentials: {
    client_email: process.env.GCS_CLIENT_EMAIL,
    private_key: process.env.GCS_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
});

const bucket = storage.bucket(process.env.GCS_BUCKET_NAME!);
console.log('✅ GCS connected:', bucket.name);
```

---

## Part 2: API Routes (Backend)

### Step 2.1: Upload Signed URL Endpoint

Create file: `app/api/upload/route.ts`

```typescript
import { Storage } from '@google-cloud/storage';
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';

const storage = new Storage({
  projectId: process.env.GCS_PROJECT_ID,
  credentials: {
    client_email: process.env.GCS_CLIENT_EMAIL,
    private_key: process.env.GCS_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
});

// Rate limit: Track uploads per user
const uploadCounts = new Map<string, { count: number; resetTime: number }>();

function checkRateLimit(userId: string): boolean {
  const now = Date.now();
  const record = uploadCounts.get(userId);

  if (!record || now > record.resetTime) {
    uploadCounts.set(userId, { count: 1, resetTime: now + 3600000 }); // 1 hour window
    return true;
  }

  if (record.count >= 10) return false; // Max 10 uploads per hour
  record.count++;
  return true;
}

export async function POST(req: NextRequest) {
  try {
    // 1. Authenticate
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    // 2. Rate limit
    if (!checkRateLimit(session.user.id)) {
      return NextResponse.json(
        { error: 'Too many uploads. Try again later.' },
        { status: 429 }
      );
    }

    // 3. Parse request
    const { filename, fileType } = await req.json();

    // 4. Validate input
    const allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
    if (!allowedTypes.includes(fileType)) {
      return NextResponse.json(
        { error: 'Invalid file type. Allowed: JPEG, PNG, WebP, GIF' },
        { status: 400 }
      );
    }

    // Validate filename length
    if (!filename || filename.length > 100) {
      return NextResponse.json(
        { error: 'Invalid filename' },
        { status: 400 }
      );
    }

    // 5. Generate unique filename
    const timestamp = Date.now();
    const random = Math.random().toString(36).substring(7);
    const cleanFilename = filename.replace(/[^a-zA-Z0-9.-]/g, '_');
    const uniqueName = `uploads/${session.user.id}/${timestamp}-${random}-${cleanFilename}`;

    // 6. Get bucket and generate signed URL
    const bucket = storage.bucket(process.env.GCS_BUCKET_NAME!);
    const file = bucket.file(uniqueName);

    const [signedUrl] = await file.getSignedUrl({
      version: 'v4',
      action: 'write',
      expires: Date.now() + 15 * 60 * 1000, // 15 minutes
      contentType: fileType,
    });

    // 7. Return signed URL to frontend
    return NextResponse.json({
      signedUrl,
      fileName: uniqueName,
      publicUrl: `https://storage.googleapis.com/${process.env.GCS_BUCKET_NAME}/${uniqueName}`,
    });

  } catch (error) {
    console.error('Upload error:', error);
    return NextResponse.json(
      { error: 'Failed to generate upload URL' },
      { status: 500 }
    );
  }
}
```

### Step 2.2: Save Image URL to Database

Create file: `app/api/orders/route.ts`

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import prisma from '@/lib/prisma';
import { z } from 'zod';

// Validation schema
const CreateOrderSchema = z.object({
  items: z.array(z.object({
    foodItemId: z.string(),
    quantity: z.number().min(1),
  })).min(1),
  deliveryAddress: z.string().min(5),
  imageUrl: z.string().url().optional(), // GCS URL from signed upload
  notes: z.string().optional(),
});

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await req.json();
    const validated = CreateOrderSchema.parse(body);

    // Calculate total price
    const items = await prisma.foodItem.findMany({
      where: { id: { in: validated.items.map(i => i.foodItemId) } },
      select: { id: true, price: true, stock: true },
    });

    let totalPrice = 0;
    for (const item of validated.items) {
      const found = items.find(i => i.id === item.foodItemId);
      if (!found || found.stock < item.quantity) {
        return NextResponse.json(
          { error: 'Item out of stock' },
          { status: 400 }
        );
      }
      totalPrice += found.price * item.quantity;
    }

    // Create order with image URL
    const order = await prisma.order.create({
      data: {
        userId: session.user.id,
        totalPrice,
        deliveryAddress: validated.deliveryAddress,
        proofImageUrl: validated.imageUrl || null, // Store GCS URL
        notes: validated.notes,
        status: 'PENDING',
        items: {
          create: validated.items.map(item => ({
            foodItemId: item.foodItemId,
            quantity: item.quantity,
          })),
        },
      },
      include: { items: true },
    });

    // Log the action
    await prisma.auditLog.create({
      data: {
        entityType: 'Order',
        entityId: order.id,
        action: 'CREATE',
        actorId: session.user.id,
        details: `Order created with ${order.items.length} items`,
      },
    });

    return NextResponse.json(order, { status: 201 });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }
    console.error('Order creation error:', error);
    return NextResponse.json(
      { error: 'Failed to create order' },
      { status: 500 }
    );
  }
}
```

---

## Part 3: Frontend Components (React)

### Step 3.1: Image Upload Hook

Create file: `hooks/useImageUpload.ts`

```typescript
import { useState } from 'react';

export function useImageUpload() {
  const [isUploading, setIsUploading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const uploadImage = async (file: File): Promise<string | null> => {
    try {
      setIsUploading(true);
      setError(null);
      setProgress(0);

      // Step 1: Validate file
      if (file.size > 5 * 1024 * 1024) {
        throw new Error('File too large (max 5 MB)');
      }

      const validTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'];
      if (!validTypes.includes(file.type)) {
        throw new Error('Invalid file type');
      }

      // Step 2: Get signed URL from your backend
      setProgress(10);
      const signedUrlRes = await fetch('/api/upload', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filename: file.name,
          fileType: file.type,
        }),
      });

      if (!signedUrlRes.ok) {
        throw new Error('Failed to get upload URL');
      }

      const { signedUrl, publicUrl } = await signedUrlRes.json();
      setProgress(30);

      // Step 3: Upload directly to GCS using signed URL
      const uploadRes = await fetch(signedUrl, {
        method: 'PUT',
        headers: { 'Content-Type': file.type },
        body: file,
      });

      if (!uploadRes.ok) {
        throw new Error('Upload failed');
      }

      setProgress(100);
      return publicUrl; // Return URL to store in database

    } catch (err) {
      const message = err instanceof Error ? err.message : 'Upload failed';
      setError(message);
      return null;
    } finally {
      setIsUploading(false);
    }
  };

  return { uploadImage, isUploading, progress, error };
}
```

### Step 3.2: Food Order Form with Image Upload

Create file: `components/OrderForm.tsx`

```typescript
import { useState } from 'react';
import Image from 'next/image';
import { useImageUpload } from '@/hooks/useImageUpload';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const OrderFormSchema = z.object({
  items: z.array(z.object({
    foodItemId: z.string(),
    quantity: z.number().min(1),
  })).min(1),
  deliveryAddress: z.string().min(5),
  notes: z.string().optional(),
});

type OrderFormData = z.infer<typeof OrderFormSchema>;

export function OrderForm({ items }: { items: any[] }) {
  const { uploadImage, isUploading, progress, error: uploadError } = useImageUpload();
  const [uploadedImageUrl, setUploadedImageUrl] = useState<string | null>(null);
  const { register, handleSubmit, watch, formState: { errors, isSubmitting } } = useForm<OrderFormData>({
    resolver: zodResolver(OrderFormSchema),
  });

  const onImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!e.target.files?.[0]) return;

    const file = e.target.files[0];
    const url = await uploadImage(file);
    if (url) {
      setUploadedImageUrl(url);
    }
  };

  const onSubmit = async (data: OrderFormData) => {
    const payload = {
      ...data,
      imageUrl: uploadedImageUrl, // Include GCS URL
    };

    const res = await fetch('/api/orders', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });

    if (res.ok) {
      alert('Order placed successfully!');
      // Redirect to order tracking
    } else {
      alert('Failed to place order');
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="space-y-6 max-w-2xl">
      
      {/* Food Items Selection */}
      <div className="space-y-4">
        <h3 className="text-lg font-semibold">Select Items</h3>
        {items.map((item) => (
          <div key={item.id} className="flex items-center gap-4 p-4 border rounded">
            <Image 
              src={item.imageUrl} 
              alt={item.name}
              width={80}
              height={80}
              className="rounded"
            />
            <div className="flex-1">
              <h4 className="font-medium">{item.name}</h4>
              <p className="text-sm text-gray-600">LKR {item.price.toLocaleString()}</p>
            </div>
            <input 
              type="number" 
              min="1" 
              placeholder="Qty"
              className="w-16 px-2 py-1 border rounded"
              {...register(`items.${items.indexOf(item)}.foodItemId`)}
            />
          </div>
        ))}
      </div>

      {/* Delivery Address */}
      <div>
        <label className="block text-sm font-medium mb-2">Delivery Address</label>
        <textarea 
          className="w-full px-4 py-2 border rounded"
          {...register('deliveryAddress')}
          placeholder="123 Colombo Road, Colombo 7"
        />
        {errors.deliveryAddress && (
          <p className="text-red-600 text-sm mt-1">{errors.deliveryAddress.message}</p>
        )}
      </div>

      {/* Image Upload (e.g., photo proof or special request) */}
      <div>
        <label className="block text-sm font-medium mb-2">Upload Photo (Optional)</label>
        
        {/* File Input */}
        <input 
          type="file"
          accept="image/*"
          onChange={onImageChange}
          disabled={isUploading}
          className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:border file:rounded file:bg-blue-50 file:text-blue-700"
        />

        {/* Progress Bar */}
        {isUploading && (
          <div className="mt-2 w-full bg-gray-200 rounded h-2">
            <div 
              className="bg-blue-600 h-2 rounded transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>
        )}

        {/* Preview */}
        {uploadedImageUrl && (
          <Image 
            src={uploadedImageUrl}
            alt="Uploaded"
            width={200}
            height={200}
            className="mt-4 rounded"
          />
        )}

        {/* Error Message */}
        {uploadError && (
          <p className="text-red-600 text-sm mt-2">❌ {uploadError}</p>
        )}
      </div>

      {/* Notes */}
      <div>
        <label className="block text-sm font-medium mb-2">Special Requests</label>
        <textarea 
          className="w-full px-4 py-2 border rounded"
          {...register('notes')}
          placeholder="E.g., Less spicy, extra garlic..."
        />
      </div>

      {/* Submit Button */}
      <button 
        type="submit"
        disabled={isSubmitting || isUploading}
        className="w-full bg-blue-600 text-white py-3 rounded font-medium disabled:opacity-50"
      >
        {isSubmitting ? 'Placing Order...' : 'Place Order'}
      </button>
    </form>
  );
}
```

---

## Part 4: Prisma Schema Updates

Update `prisma/schema.prisma`:

```prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

// ... existing models ...

model Order {
  id              String      @id @default(cuid())
  userId          String
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  items           OrderItem[]
  totalPrice      Float
  status          OrderStatus @default(PENDING)
  deliveryAddress String
  
  // GCS image URL (can be receipt, proof, customer request photo, etc.)
  proofImageUrl   String?
  notes           String?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  logs            AuditLog[]

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model ServiceRequest {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  
  type            ServiceType
  description     String
  
  // Before/after photos for cleaning & IT services
  imageUrl        String?   // GCS URL
  
  status          ServiceStatus @default(RECEIVED)
  priority        Priority  @default(MEDIUM)
  
  assignedStaff   StaffAssignment?
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  logs            AuditLog[]

  @@index([userId])
  @@index([status])
}

enum ServiceType {
  CLEANING
  IT_SUPPORT
}

enum ServiceStatus {
  RECEIVED
  ASSIGNED
  IN_PROGRESS
  RESOLVED
  CANCELED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model AuditLog {
  id          String   @id @default(cuid())
  entityType  String   // 'Order', 'Service', 'User'
  entityId    String
  action      String   // 'CREATE', 'UPDATE', 'DELETE'
  actorId     String
  actor       User     @relation(fields: [actorId], references: [id])
  details     String?
  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([actorId])
}
```

**Apply schema:**
```bash
npx prisma migrate dev --name add_image_urls
```

---

## Part 5: Deployment to Vercel

### Step 5.1: Push to Git
```bash
git add .
git commit -m "feat: Add PostgreSQL + GCS image uploads"
git push origin main
```

### Step 5.2: Connect to Vercel
```bash
npm install -g vercel
vercel link
```

### Step 5.3: Set Environment Variables in Vercel
Go to **Settings → Environment Variables**:
```
DATABASE_URL=postgresql://...
GCS_PROJECT_ID=myapp-gcs-12345
GCS_CLIENT_EMAIL=app-uploader@...
GCS_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----
GCS_BUCKET_NAME=myapp-uploads-abc
```

### Step 5.4: Deploy
```bash
vercel --prod
```

---

## Part 6: Cost Breakdown (Sri Lankan Rupees)

### Free Tier (Development)
```
Database (Neon):        LKR 0     (free tier: 3GB)
Image Storage (GCS):    LKR 0     (free tier: 5GB/month)
Backend (Vercel):       LKR 0     (free tier: 100GB-hours)
                        ──────────
TOTAL:                  LKR 0/month
```

### Startup Tier (500-5,000 users)
```
Database (Neon):        LKR 2,500  (₹19/mo at exchange rate ~131)
Image Storage (GCS):    LKR 2,600  ($20/mo × 130 rupees)
Backend (Vercel Pro):   LKR 3,250  ($25/mo × 130 rupees)
                        ──────────
TOTAL:                  LKR 8,350/month
```

### Growth Tier (10,000-50,000 users)
```
Database (Neon):        LKR 6,500  ($50/mo compute + storage)
Image Storage (GCS):    LKR 10,400 ($80/mo for 50GB + transfer)
Backend (Vercel Pro):   LKR 3,900  ($30/mo)
                        ──────────
TOTAL:                  LKR 20,800/month (~USD $160/mo)
```

---

## Part 7: Testing & Verification

### Test Image Upload
```bash
curl -X POST http://localhost:3000/api/upload \
  -H "Content-Type: application/json" \
  -d '{"filename": "test.jpg", "fileType": "image/jpeg"}'
```

### Test Database Query
```bash
npx prisma studio
# Browse Order table → check if image URLs are saved
```

### Test Production
```bash
# After deploying to Vercel:
curl -X POST https://your-app.vercel.app/api/upload \
  -H "Authorization: Bearer <your-jwt-token>" \
  -H "Content-Type: application/json" \
  -d '{"filename": "test.jpg", "fileType": "image/jpeg"}'
```

---

## Part 8: Common Issues & Solutions

| Issue | Solution |
|-------|----------|
| **CORS error uploading to GCS** | Bucket should NOT be public. Use signed URLs from backend only. |
| **"Too many connections" error** | Neon free tier has 4 connections max. Use Prisma connection pooling. |
| **GCS bucket not found** | Check `GCS_BUCKET_NAME` env var matches exactly (case-sensitive). |
| **Image URL returns 403 Forbidden** | Ensure signed URL hasn't expired (valid for 15 min) or bucket not misconfigured. |
| **Upload fails with 413 Payload Too Large** | Check Vercel function size limit (50MB max). Compress images client-side first. |

---

## Part 9: Next Steps

1. **Week 1:** Complete database + GCS setup ✅
2. **Week 2:** Build upload API + test with Postman
3. **Week 3:** Create React components (use code above)
4. **Week 4:** Deploy to Vercel + monitor
5. **Week 5:** Add analytics dashboard
6. **Future:** Add Stripe payments, real-time order tracking, GPS for drivers

---

## Resources

- **Neon Docs:** https://neon.tech/docs
- **GCS Signed URLs:** https://cloud.google.com/storage/docs/access-control/signed-urls
- **Prisma PostgreSQL:** https://www.prisma.io/docs/getting-started/setup-prisma/add-to-existing-project/relational-databases
- **Vercel Deployment:** https://vercel.com/docs/deployments/overview
- **Next.js File Upload:** https://nextjs.org/docs/app/building-your-application/routing/route-handlers

---

**Last Updated:** December 8, 2025  
**Status:** Production-Ready  
**Tested On:** Next.js 15, Node.js 18+, PostgreSQL 15+